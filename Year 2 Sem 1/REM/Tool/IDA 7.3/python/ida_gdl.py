# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: gdl
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_gdl', [dirname(__file__)])
        except ImportError:
            import _ida_gdl
            return _ida_gdl
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_gdl', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_gdl = swig_import_helper()
    del swig_import_helper
else:
    import _ida_gdl
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
fcb_normal = _ida_gdl.fcb_normal
fcb_indjump = _ida_gdl.fcb_indjump
fcb_ret = _ida_gdl.fcb_ret
fcb_cndret = _ida_gdl.fcb_cndret
fcb_noret = _ida_gdl.fcb_noret
fcb_enoret = _ida_gdl.fcb_enoret
fcb_extern = _ida_gdl.fcb_extern
fcb_error = _ida_gdl.fcb_error
class node_iterator(object):
    """
    Proxy of C++ node_iterator class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _g, n) -> node_iterator
        """
        this = _ida_gdl.new_node_iterator(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, n) -> bool
        """
        return _ida_gdl.node_iterator___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, n) -> bool
        """
        return _ida_gdl.node_iterator___ne__(self, *args)

    def __ref__(self, *args):
        """
        __ref__(self) -> int
        """
        return _ida_gdl.node_iterator___ref__(self, *args)

    __swig_destroy__ = _ida_gdl.delete_node_iterator
    __del__ = lambda self : None;
node_iterator_swigregister = _ida_gdl.node_iterator_swigregister
node_iterator_swigregister(node_iterator)


def gen_gdl(*args):
  """
  gen_gdl(g, fname)


  Create GDL file for graph.
  
  
  @param g (C++: const  gdl_graph_t  *)
  @param fname (C++: const char *)
  """
  return _ida_gdl.gen_gdl(*args)

def display_gdl(*args):
  """
  display_gdl(fname) -> int


  Display GDL file by calling wingraph32. The exact name of the grapher
  is taken from the configuration file and set up by
  'setup_graph_subsystem()' .
  
  @param fname (C++: const char *)
  @return: error code from os, 0 if ok
  """
  return _ida_gdl.display_gdl(*args)

def gen_flow_graph(*args):
  """
  gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool


  Build and display a flow graph.
  
  @param filename: output file name. the file extension is not used.
                   maybe NULL. (C++: const char *)
  @param title: graph title (C++: const char *)
  @param pfn: function to graph (C++: func_t  *)
  @param ea1: if pfn == NULL, then the address range (C++: ea_t)
  @param ea2: if pfn == NULL, then the address range (C++: ea_t)
  @param gflags: combination of  Flow graph building flags . if none of
                 CHART_GEN_DOT ,  CHART_GEN_GDL ,  CHART_WINGRAPH  is
                 specified, the function will return false (C++: int)
  @return: success. if fails, a warning message is displayed on the
           screen
  """
  return _ida_gdl.gen_flow_graph(*args)
CHART_PRINT_NAMES = _ida_gdl.CHART_PRINT_NAMES
"""
print labels for each block?
"""
CHART_GEN_DOT = _ida_gdl.CHART_GEN_DOT
"""
generate .dot file (file extension is forced to .dot)
"""
CHART_GEN_GDL = _ida_gdl.CHART_GEN_GDL
"""
generate .gdl file (file extension is forced to .gdl)
"""
CHART_WINGRAPH = _ida_gdl.CHART_WINGRAPH
"""
call grapher to display the graph
"""

def gen_simple_call_chart(*args):
  """
  gen_simple_call_chart(filename, wait, title, gflags) -> bool


  Build and display a simple function call graph.
  
  @param filename: output file name. the file extension is not used.
                   maybe NULL. (C++: const char *)
  @param wait: message to display during graph building (C++: const char
               *)
  @param title: graph title (C++: const char *)
  @param gflags: combination of  CHART_NOLIBFUNCS  and  Flow graph
                 building flags . if none of  CHART_GEN_DOT ,
                 CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                 function will return false. (C++: int)
  @return: success. if fails, a warning message is displayed on the
           screen
  """
  return _ida_gdl.gen_simple_call_chart(*args)

def gen_complex_call_chart(*args):
  """
  gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool


  Build and display a complex xref graph.
  
  @param filename: output file name. the file extension is not used.
                   maybe NULL. (C++: const char *)
  @param wait: message to display during graph building (C++: const char
               *)
  @param title: graph title (C++: const char *)
  @param ea1: address range (C++: ea_t)
  @param ea2: address range (C++: ea_t)
  @param flags: combination of  Call chart building flags  and  Flow
                graph building flags . if none of  CHART_GEN_DOT ,
                CHART_GEN_GDL ,  CHART_WINGRAPH  is specified, the
                function will return false. (C++: int)
  @param recursion_depth: optional limit of recursion (C++: int32)
  @return: success. if fails, a warning message is displayed on the
           screen
  """
  return _ida_gdl.gen_complex_call_chart(*args)
CHART_NOLIBFUNCS = _ida_gdl.CHART_NOLIBFUNCS
"""
don't include library functions in the graph
"""
CHART_REFERENCING = _ida_gdl.CHART_REFERENCING
"""
references to the addresses in the list
"""
CHART_REFERENCED = _ida_gdl.CHART_REFERENCED
"""
references from the addresses in the list
"""
CHART_RECURSIVE = _ida_gdl.CHART_RECURSIVE
"""
analyze added blocks
"""
CHART_FOLLOW_DIRECTION = _ida_gdl.CHART_FOLLOW_DIRECTION
"""
analyze references to added blocks only in the direction of the
reference who discovered the current block
"""
CHART_IGNORE_XTRN = _ida_gdl.CHART_IGNORE_XTRN
CHART_IGNORE_DATA_BSS = _ida_gdl.CHART_IGNORE_DATA_BSS
CHART_IGNORE_LIB_TO = _ida_gdl.CHART_IGNORE_LIB_TO
"""
ignore references to library functions
"""
CHART_IGNORE_LIB_FROM = _ida_gdl.CHART_IGNORE_LIB_FROM
"""
ignore references from library functions
"""
CHART_PRINT_COMMENTS = _ida_gdl.CHART_PRINT_COMMENTS
CHART_PRINT_DOTS = _ida_gdl.CHART_PRINT_DOTS
"""
print dots if xrefs exist outside of the range recursion depth
"""
class qbasic_block_t(ida_range.range_t):
    """
    Proxy of C++ qbasic_block_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qbasic_block_t
        """
        this = _ida_gdl.new_qbasic_block_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_gdl.delete_qbasic_block_t
    __del__ = lambda self : None;
qbasic_block_t_swigregister = _ida_gdl.qbasic_block_t_swigregister
qbasic_block_t_swigregister(qbasic_block_t)


def is_noret_block(*args):
  """
  is_noret_block(btype) -> bool


  Does this block never return?
  
  
  @param btype (C++: fc_block_type_t)
  """
  return _ida_gdl.is_noret_block(*args)

def is_ret_block(*args):
  """
  is_ret_block(btype) -> bool


  Does this block return?
  
  
  @param btype (C++: fc_block_type_t)
  """
  return _ida_gdl.is_ret_block(*args)
FC_PRINT = _ida_gdl.FC_PRINT
"""
print names (used only by display_flow_chart())
"""
FC_NOEXT = _ida_gdl.FC_NOEXT
"""
do not compute external blocks. Use this to prevent jumps leaving the
function from appearing in the flow chart. Unless specified, the
targets of those outgoing jumps will be present in the flow chart
under the form of one-instruction blocks
"""
FC_PREDS = _ida_gdl.FC_PREDS
"""
compute predecessor lists
"""
FC_APPND = _ida_gdl.FC_APPND
"""
multirange flowchart (set by append_to_flowchart)
"""
FC_CHKBREAK = _ida_gdl.FC_CHKBREAK
"""
build_qflow_chart() may be aborted by user
"""
class qflow_chart_t(object):
    """
    Proxy of C++ qflow_chart_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    title = _swig_property(_ida_gdl.qflow_chart_t_title_get, _ida_gdl.qflow_chart_t_title_set)
    bounds = _swig_property(_ida_gdl.qflow_chart_t_bounds_get, _ida_gdl.qflow_chart_t_bounds_set)
    pfn = _swig_property(_ida_gdl.qflow_chart_t_pfn_get, _ida_gdl.qflow_chart_t_pfn_set)
    flags = _swig_property(_ida_gdl.qflow_chart_t_flags_get, _ida_gdl.qflow_chart_t_flags_set)
    nproper = _swig_property(_ida_gdl.qflow_chart_t_nproper_get, _ida_gdl.qflow_chart_t_nproper_set)
    def __init__(self, *args):
        """
        __init__(self) -> qflow_chart_t
        __init__(self, _title, _pfn, _ea1, _ea2, _flags) -> qflow_chart_t
        """
        this = _ida_gdl.new_qflow_chart_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def create(self, *args):
        """
        create(self, _title, _pfn, _ea1, _ea2, _flags)
        create(self, _title, ranges, _flags)
        """
        return _ida_gdl.qflow_chart_t_create(self, *args)

    def append_to_flowchart(self, *args):
        """
        append_to_flowchart(self, ea1, ea2)
        """
        return _ida_gdl.qflow_chart_t_append_to_flowchart(self, *args)

    def refresh(self, *args):
        """
        refresh(self)
        """
        return _ida_gdl.qflow_chart_t_refresh(self, *args)

    def calc_block_type(self, *args):
        """
        calc_block_type(self, blknum) -> fc_block_type_t
        """
        return _ida_gdl.qflow_chart_t_calc_block_type(self, *args)

    def is_ret_block(self, *args):
        """
        is_ret_block(self, blknum) -> bool
        """
        return _ida_gdl.qflow_chart_t_is_ret_block(self, *args)

    def is_noret_block(self, *args):
        """
        is_noret_block(self, blknum) -> bool
        """
        return _ida_gdl.qflow_chart_t_is_noret_block(self, *args)

    def print_node_attributes(self, *args):
        """
        print_node_attributes(self, arg2, arg3)
        """
        return _ida_gdl.qflow_chart_t_print_node_attributes(self, *args)

    def nsucc(self, *args):
        """
        nsucc(self, node) -> int
        """
        return _ida_gdl.qflow_chart_t_nsucc(self, *args)

    def npred(self, *args):
        """
        npred(self, node) -> int
        """
        return _ida_gdl.qflow_chart_t_npred(self, *args)

    def succ(self, *args):
        """
        succ(self, node, i) -> int
        """
        return _ida_gdl.qflow_chart_t_succ(self, *args)

    def pred(self, *args):
        """
        pred(self, node, i) -> int
        """
        return _ida_gdl.qflow_chart_t_pred(self, *args)

    def print_names(self, *args):
        """
        print_names(self) -> bool
        """
        return _ida_gdl.qflow_chart_t_print_names(self, *args)

    def get_node_label(self, *args):
        """
        get_node_label(self, arg2, arg3, arg4) -> char *
        """
        return _ida_gdl.qflow_chart_t_get_node_label(self, *args)

    def size(self, *args):
        """
        size(self) -> int
        """
        return _ida_gdl.qflow_chart_t_size(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, n) -> qbasic_block_t
        """
        return _ida_gdl.qflow_chart_t___getitem__(self, *args)

    __swig_destroy__ = _ida_gdl.delete_qflow_chart_t
    __del__ = lambda self : None;
qflow_chart_t_swigregister = _ida_gdl.qflow_chart_t_swigregister
qflow_chart_t_swigregister(qflow_chart_t)

#<pycode(py_gdl)>
import _ida_idaapi
import types
# -----------------------------------------------------------------------
class BasicBlock(object):
    """
    Basic block class. It is returned by the Flowchart class
    """
    def __init__(self, id, bb, fc):
        self._fc = fc

        self.id = id
        """
        Basic block ID
        """

        self.start_ea = bb.start_ea
        """
        start_ea of basic block
        """

        self.end_ea = bb.end_ea
        """
        end_ea of basic block
        """

        self.type  = self._fc._q.calc_block_type(self.id)
        """
        Block type (check fc_block_type_t enum)
        """


    def preds(self):
        """
        Iterates the predecessors list
        """
        q = self._fc._q
        for i in xrange(0, self._fc._q.npred(self.id)):
            yield self._fc[q.pred(self.id, i)]


    def succs(self):
        """
        Iterates the successors list
        """
        q = self._fc._q
        for i in xrange(0, q.nsucc(self.id)):
            yield self._fc[q.succ(self.id, i)]

    try:
        if _BC695:
            startEA = property(lambda self: self.start_ea, lambda self, ea: setattr(self, "start_ea", ea))
            endEA = property(lambda self: self.end_ea, lambda self, ea: setattr(self, "end_ea", ea))
    except:
        pass # BC695 not defined at compile-time

# -----------------------------------------------------------------------
class FlowChart(object):
    """
    Flowchart class used to determine basic blocks.
    Check ex_gdl_qflow_chart.py for sample usage.
    """
    def __init__(self, f=None, bounds=None, flags=0):
        """
        Constructor
        @param f: A func_t type, use get_func(ea) to get a reference
        @param bounds: A tuple of the form (start, end). Used if "f" is None
        @param flags: one of the FC_xxxx flags. One interesting flag is FC_PREDS
        """
        if (f is None) and (bounds is None or type(bounds) != tuple):
            raise Exception("Please specifiy either a function or start/end pair")

        if bounds is None:
            bounds = (_ida_idaapi.BADADDR, _ida_idaapi.BADADDR)

        # Create the flowchart
        self._q = qflow_chart_t("", f, bounds[0], bounds[1], flags)

    size = property(lambda self: self._q.size())
    """
    Number of blocks in the flow chart
    """


    def refresh(self):
        """
        Refreshes the flow chart
        """
        self._q.refresh()


    def _getitem(self, index):
        return BasicBlock(index, self._q[index], self)


    def __iter__(self):
        return (self._getitem(index) for index in xrange(0, self.size))


    def __getitem__(self, index):
        """
        Returns a basic block

        @return: BasicBlock
        """
        if index >= self.size:
            raise KeyError
        else:
            return self._getitem(index)

#</pycode(py_gdl)>


