# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: hexrays
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_hexrays', [dirname(__file__)])
        except ImportError:
            import _ida_hexrays
            return _ida_hexrays
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_hexrays', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_hexrays = swig_import_helper()
    del swig_import_helper
else:
    import _ida_hexrays
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_pro
import ida_xref
import ida_typeinf
import ida_idp

def _kludge_use_TPopupMenu(*args):
  """
  _kludge_use_TPopupMenu(m)
  """
  return _ida_hexrays._kludge_use_TPopupMenu(*args)
class array_of_bitsets(object):
    """
    Proxy of C++ qvector<(bitset_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> array_of_bitsets
        __init__(self, x) -> array_of_bitsets
        """
        this = _ida_hexrays.new_array_of_bitsets(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_array_of_bitsets
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.array_of_bitsets_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.array_of_bitsets_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.array_of_bitsets_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.array_of_bitsets_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.array_of_bitsets_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.array_of_bitsets_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=bitset_t())
        """
        return _ida_hexrays.array_of_bitsets_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.array_of_bitsets_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.array_of_bitsets_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.array_of_bitsets_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.array_of_bitsets_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.array_of_bitsets_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.array_of_bitsets___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.array_of_bitsets___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> bitset_t
        begin(self) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> bitset_t
        end(self) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> bitset_t
        erase(self, first, last) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> bitset_t
        find(self, x) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.array_of_bitsets_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.array_of_bitsets_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.array_of_bitsets__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.array_of_bitsets___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> bitset_t
        """
        return _ida_hexrays.array_of_bitsets___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.array_of_bitsets___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

array_of_bitsets_swigregister = _ida_hexrays.array_of_bitsets_swigregister
array_of_bitsets_swigregister(array_of_bitsets)

class mopvec_t(object):
    """
    Proxy of C++ qvector<(mop_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> mopvec_t
        __init__(self, x) -> mopvec_t
        """
        this = _ida_hexrays.new_mopvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_mopvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> mop_t
        """
        return _ida_hexrays.mopvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.mopvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.mopvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mopvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> mop_t
        """
        return _ida_hexrays.mopvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.mopvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.mopvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.mopvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=mop_t())
        """
        return _ida_hexrays.mopvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.mopvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.mopvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.mopvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.mopvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> mop_t
        """
        return _ida_hexrays.mopvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.mopvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.mopvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.mopvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> mop_t
        begin(self) -> mop_t
        """
        return _ida_hexrays.mopvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> mop_t
        end(self) -> mop_t
        """
        return _ida_hexrays.mopvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> mop_t
        """
        return _ida_hexrays.mopvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> mop_t
        erase(self, first, last) -> mop_t
        """
        return _ida_hexrays.mopvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> mop_t
        find(self, x) -> mop_t
        """
        return _ida_hexrays.mopvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.mopvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.mopvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.mopvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.mopvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> mop_t
        """
        return _ida_hexrays.mopvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.mopvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

mopvec_t_swigregister = _ida_hexrays.mopvec_t_swigregister
mopvec_t_swigregister(mopvec_t)

class mcallargs_t(object):
    """
    Proxy of C++ qvector<(mcallarg_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> mcallargs_t
        __init__(self, x) -> mcallargs_t
        """
        this = _ida_hexrays.new_mcallargs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_mcallargs_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.mcallargs_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.mcallargs_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mcallargs_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.mcallargs_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.mcallargs_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.mcallargs_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=mcallarg_t())
        """
        return _ida_hexrays.mcallargs_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.mcallargs_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.mcallargs_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.mcallargs_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.mcallargs_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.mcallargs_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.mcallargs_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.mcallargs_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> mcallarg_t
        begin(self) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> mcallarg_t
        end(self) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> mcallarg_t
        erase(self, first, last) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> mcallarg_t
        find(self, x) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.mcallargs_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.mcallargs_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.mcallargs_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.mcallargs_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> mcallarg_t
        """
        return _ida_hexrays.mcallargs_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.mcallargs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

mcallargs_t_swigregister = _ida_hexrays.mcallargs_t_swigregister
mcallargs_t_swigregister(mcallargs_t)

class block_chains_vec_t(object):
    """
    Proxy of C++ qvector<(block_chains_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> block_chains_vec_t
        __init__(self, x) -> block_chains_vec_t
        """
        this = _ida_hexrays.new_block_chains_vec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_block_chains_vec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.block_chains_vec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.block_chains_vec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.block_chains_vec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.block_chains_vec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.block_chains_vec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.block_chains_vec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=block_chains_t())
        """
        return _ida_hexrays.block_chains_vec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.block_chains_vec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.block_chains_vec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.block_chains_vec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.block_chains_vec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.block_chains_vec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> block_chains_t
        begin(self) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> block_chains_t
        end(self) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> block_chains_t
        erase(self, first, last) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.block_chains_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> block_chains_t
        """
        return _ida_hexrays.block_chains_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.block_chains_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

block_chains_vec_t_swigregister = _ida_hexrays.block_chains_vec_t_swigregister
block_chains_vec_t_swigregister(block_chains_vec_t)

class user_numforms_t(object):
    """
    Proxy of C++ std::map<(operand_locator_t,number_format_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> number_format_t
        """
        return _ida_hexrays.user_numforms_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_numforms_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_numforms_t
        """
        this = _ida_hexrays.new_user_numforms_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_numforms_t
    __del__ = lambda self : None;
user_numforms_t_swigregister = _ida_hexrays.user_numforms_t_swigregister
user_numforms_t_swigregister(user_numforms_t)

class lvar_mapping_t(object):
    """
    Proxy of C++ std::map<(lvar_locator_t,lvar_locator_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> lvar_locator_t
        """
        return _ida_hexrays.lvar_mapping_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.lvar_mapping_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvar_mapping_t
        """
        this = _ida_hexrays.new_lvar_mapping_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_mapping_t
    __del__ = lambda self : None;
lvar_mapping_t_swigregister = _ida_hexrays.lvar_mapping_t_swigregister
lvar_mapping_t_swigregister(lvar_mapping_t)

class hexwarns_t(object):
    """
    Proxy of C++ qvector<(hexwarn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> hexwarns_t
        __init__(self, x) -> hexwarns_t
        """
        this = _ida_hexrays.new_hexwarns_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_hexwarns_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.hexwarns_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.hexwarns_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.hexwarns_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.hexwarns_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.hexwarns_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=hexwarn_t())
        """
        return _ida_hexrays.hexwarns_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.hexwarns_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.hexwarns_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.hexwarns_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.hexwarns_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.hexwarns_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.hexwarns_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> hexwarn_t
        begin(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> hexwarn_t
        end(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> hexwarn_t
        erase(self, first, last) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> hexwarn_t
        find(self, x) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.hexwarns_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

hexwarns_t_swigregister = _ida_hexrays.hexwarns_t_swigregister
hexwarns_t_swigregister(hexwarns_t)

class ctree_items_t(object):
    """
    Proxy of C++ qvector<(p.citem_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> ctree_items_t
        __init__(self, x) -> ctree_items_t
        """
        this = _ida_hexrays.new_ctree_items_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ctree_items_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> citem_t *&
        """
        return _ida_hexrays.ctree_items_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.ctree_items_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.ctree_items_t_empty(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.ctree_items_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.ctree_items_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.ctree_items_t_resize(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.ctree_items_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.ctree_items_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.ctree_items_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> citem_t **
        """
        return _ida_hexrays.ctree_items_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.ctree_items_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ctree_items_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ctree_items_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qvector< citem_t * >::iterator
        begin(self) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qvector< citem_t * >::iterator
        end(self) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> qvector< citem_t * >::iterator
        """
        return _ida_hexrays.ctree_items_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> qvector< citem_t * >::iterator
        erase(self, first, last) -> qvector< citem_t * >::iterator
        """
        return _ida_hexrays.ctree_items_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> qvector< citem_t * >::iterator
        find(self, x) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> citem_t
        """
        return _ida_hexrays.ctree_items_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.ctree_items_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def at(self, *args):
        """
        at(self, n) -> citem_t
        """
        return _ida_hexrays.ctree_items_t_at(self, *args)

ctree_items_t_swigregister = _ida_hexrays.ctree_items_t_swigregister
ctree_items_t_swigregister(ctree_items_t)

class user_labels_t(object):
    """
    Proxy of C++ std::map<(int,qstring)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> _qstring< char > &
        """
        return _ida_hexrays.user_labels_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_labels_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_labels_t
        """
        this = _ida_hexrays.new_user_labels_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_labels_t
    __del__ = lambda self : None;
user_labels_t_swigregister = _ida_hexrays.user_labels_t_swigregister
user_labels_t_swigregister(user_labels_t)

class user_cmts_t(object):
    """
    Proxy of C++ std::map<(treeloc_t,citem_cmt_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> citem_cmt_t
        """
        return _ida_hexrays.user_cmts_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_cmts_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_cmts_t
        """
        this = _ida_hexrays.new_user_cmts_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_cmts_t
    __del__ = lambda self : None;
user_cmts_t_swigregister = _ida_hexrays.user_cmts_t_swigregister
user_cmts_t_swigregister(user_cmts_t)

class user_iflags_t(object):
    """
    Proxy of C++ std::map<(citem_locator_t,int32)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> int &
        """
        return _ida_hexrays.user_iflags_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_iflags_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_iflags_t
        """
        this = _ida_hexrays.new_user_iflags_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_iflags_t
    __del__ = lambda self : None;
user_iflags_t_swigregister = _ida_hexrays.user_iflags_t_swigregister
user_iflags_t_swigregister(user_iflags_t)

class user_unions_t(object):
    """
    Proxy of C++ std::map<(ea_t,intvec_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> intvec_t
        """
        return _ida_hexrays.user_unions_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_unions_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_unions_t
        """
        this = _ida_hexrays.new_user_unions_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_unions_t
    __del__ = lambda self : None;
user_unions_t_swigregister = _ida_hexrays.user_unions_t_swigregister
user_unions_t_swigregister(user_unions_t)

class cinsnptrvec_t(object):
    """
    Proxy of C++ qvector<(p.cinsn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> cinsnptrvec_t
        __init__(self, x) -> cinsnptrvec_t
        """
        this = _ida_hexrays.new_cinsnptrvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cinsnptrvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> cinsn_t *&
        """
        return _ida_hexrays.cinsnptrvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.cinsnptrvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_empty(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.cinsnptrvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.cinsnptrvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.cinsnptrvec_t_resize(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.cinsnptrvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.cinsnptrvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cinsnptrvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> cinsn_t **
        """
        return _ida_hexrays.cinsnptrvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.cinsnptrvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qvector< cinsn_t * >::iterator
        begin(self) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qvector< cinsn_t * >::iterator
        end(self) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> qvector< cinsn_t * >::iterator
        """
        return _ida_hexrays.cinsnptrvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> qvector< cinsn_t * >::iterator
        erase(self, first, last) -> qvector< cinsn_t * >::iterator
        """
        return _ida_hexrays.cinsnptrvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> qvector< cinsn_t * >::iterator
        find(self, x) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> cinsn_t
        """
        return _ida_hexrays.cinsnptrvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.cinsnptrvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def at(self, *args):
        """
        at(self, n) -> cinsn_t
        """
        return _ida_hexrays.cinsnptrvec_t_at(self, *args)

cinsnptrvec_t_swigregister = _ida_hexrays.cinsnptrvec_t_swigregister
cinsnptrvec_t_swigregister(cinsnptrvec_t)

class eamap_t(object):
    """
    Proxy of C++ std::map<(ea_t,cinsnptrvec_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> cinsnptrvec_t
        """
        return _ida_hexrays.eamap_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.eamap_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> eamap_t
        """
        this = _ida_hexrays.new_eamap_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_eamap_t
    __del__ = lambda self : None;
eamap_t_swigregister = _ida_hexrays.eamap_t_swigregister
eamap_t_swigregister(eamap_t)

class boundaries_t(object):
    """
    Proxy of C++ std::map<(p.cinsn_t,rangeset_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> rangeset_t
        """
        return _ida_hexrays.boundaries_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.boundaries_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> boundaries_t
        """
        this = _ida_hexrays.new_boundaries_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_boundaries_t
    __del__ = lambda self : None;
boundaries_t_swigregister = _ida_hexrays.boundaries_t_swigregister
boundaries_t_swigregister(boundaries_t)


def user_iflags_second(*args):
  """
  user_iflags_second(p) -> int32 const &


  Get reference to the current map value.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_second(*args)
class cfuncptr_t(object):
    """
    Proxy of C++ qrefcnt_t<(cfunc_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, p) -> cfuncptr_t
        __init__(self, r) -> cfuncptr_t
        """
        this = _ida_hexrays.new_cfuncptr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def reset(self, *args):
        """
        reset(self)
        """
        return _ida_hexrays.cfuncptr_t_reset(self, *args)

    def __deref__(self, *args):
        """
        __deref__(self) -> cfunc_t
        """
        return _ida_hexrays.cfuncptr_t___deref__(self, *args)

    def __ref__(self, *args):
        """
        __ref__(self) -> cfunc_t
        """
        return _ida_hexrays.cfuncptr_t___ref__(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cfuncptr_t
    __del__ = lambda self : None;
    entry_ea = _swig_property(_ida_hexrays.cfuncptr_t_entry_ea_get, _ida_hexrays.cfuncptr_t_entry_ea_set)
    mba = _swig_property(_ida_hexrays.cfuncptr_t_mba_get, _ida_hexrays.cfuncptr_t_mba_set)
    body = _swig_property(_ida_hexrays.cfuncptr_t_body_get, _ida_hexrays.cfuncptr_t_body_set)
    argidx = _swig_property(_ida_hexrays.cfuncptr_t_argidx_get)
    maturity = _swig_property(_ida_hexrays.cfuncptr_t_maturity_get, _ida_hexrays.cfuncptr_t_maturity_set)
    user_labels = _swig_property(_ida_hexrays.cfuncptr_t_user_labels_get, _ida_hexrays.cfuncptr_t_user_labels_set)
    user_cmts = _swig_property(_ida_hexrays.cfuncptr_t_user_cmts_get, _ida_hexrays.cfuncptr_t_user_cmts_set)
    numforms = _swig_property(_ida_hexrays.cfuncptr_t_numforms_get, _ida_hexrays.cfuncptr_t_numforms_set)
    user_iflags = _swig_property(_ida_hexrays.cfuncptr_t_user_iflags_get, _ida_hexrays.cfuncptr_t_user_iflags_set)
    user_unions = _swig_property(_ida_hexrays.cfuncptr_t_user_unions_get, _ida_hexrays.cfuncptr_t_user_unions_set)
    refcnt = _swig_property(_ida_hexrays.cfuncptr_t_refcnt_get, _ida_hexrays.cfuncptr_t_refcnt_set)
    statebits = _swig_property(_ida_hexrays.cfuncptr_t_statebits_get, _ida_hexrays.cfuncptr_t_statebits_set)
    hdrlines = _swig_property(_ida_hexrays.cfuncptr_t_hdrlines_get, _ida_hexrays.cfuncptr_t_hdrlines_set)
    treeitems = _swig_property(_ida_hexrays.cfuncptr_t_treeitems_get, _ida_hexrays.cfuncptr_t_treeitems_set)
    def release(self, *args):
        """
        release(self)
        """
        return _ida_hexrays.cfuncptr_t_release(self, *args)

    def build_c_tree(self, *args):
        """
        build_c_tree(self)
        """
        return _ida_hexrays.cfuncptr_t_build_c_tree(self, *args)

    def verify(self, *args):
        """
        verify(self, aul, even_without_debugger)
        """
        return _ida_hexrays.cfuncptr_t_verify(self, *args)

    def print_dcl(self, *args):
        """
        print_dcl(self)
        """
        return _ida_hexrays.cfuncptr_t_print_dcl(self, *args)

    def print_func(self, *args):
        """
        print_func(self, vp)
        """
        return _ida_hexrays.cfuncptr_t_print_func(self, *args)

    def get_func_type(self, *args):
        """
        get_func_type(self, type) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_func_type(self, *args)

    def get_lvars(self, *args):
        """
        get_lvars(self) -> lvars_t
        """
        return _ida_hexrays.cfuncptr_t_get_lvars(self, *args)

    def get_stkoff_delta(self, *args):
        """
        get_stkoff_delta(self) -> sval_t
        """
        return _ida_hexrays.cfuncptr_t_get_stkoff_delta(self, *args)

    def find_label(self, *args):
        """
        find_label(self, label) -> citem_t
        """
        return _ida_hexrays.cfuncptr_t_find_label(self, *args)

    def remove_unused_labels(self, *args):
        """
        remove_unused_labels(self)
        """
        return _ida_hexrays.cfuncptr_t_remove_unused_labels(self, *args)

    def get_user_cmt(self, *args):
        """
        get_user_cmt(self, loc, rt) -> char const *
        """
        return _ida_hexrays.cfuncptr_t_get_user_cmt(self, *args)

    def set_user_cmt(self, *args):
        """
        set_user_cmt(self, loc, cmt)
        """
        return _ida_hexrays.cfuncptr_t_set_user_cmt(self, *args)

    def get_user_iflags(self, *args):
        """
        get_user_iflags(self, loc) -> int32
        """
        return _ida_hexrays.cfuncptr_t_get_user_iflags(self, *args)

    def set_user_iflags(self, *args):
        """
        set_user_iflags(self, loc, iflags)
        """
        return _ida_hexrays.cfuncptr_t_set_user_iflags(self, *args)

    def has_orphan_cmts(self, *args):
        """
        has_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.cfuncptr_t_has_orphan_cmts(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> int
        """
        return _ida_hexrays.cfuncptr_t_del_orphan_cmts(self, *args)

    def get_user_union_selection(self, *args):
        """
        get_user_union_selection(self, ea, path) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_user_union_selection(self, *args)

    def set_user_union_selection(self, *args):
        """
        set_user_union_selection(self, ea, path)
        """
        return _ida_hexrays.cfuncptr_t_set_user_union_selection(self, *args)

    def save_user_labels(self, *args):
        """
        save_user_labels(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_labels(self, *args)

    def save_user_cmts(self, *args):
        """
        save_user_cmts(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_cmts(self, *args)

    def save_user_numforms(self, *args):
        """
        save_user_numforms(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_numforms(self, *args)

    def save_user_iflags(self, *args):
        """
        save_user_iflags(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_iflags(self, *args)

    def save_user_unions(self, *args):
        """
        save_user_unions(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_unions(self, *args)

    def get_line_item(self, *args):
        """
        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_line_item(self, *args)

    def get_warnings(self, *args):
        """
        get_warnings(self) -> hexwarns_t
        """
        return _ida_hexrays.cfuncptr_t_get_warnings(self, *args)

    def get_eamap(self, *args):
        """
        get_eamap(self) -> eamap_t
        """
        return _ida_hexrays.cfuncptr_t_get_eamap(self, *args)

    def get_boundaries(self, *args):
        """
        get_boundaries(self) -> boundaries_t
        """
        return _ida_hexrays.cfuncptr_t_get_boundaries(self, *args)

    def get_pseudocode(self, *args):
        """
        get_pseudocode(self) -> strvec_t
        """
        return _ida_hexrays.cfuncptr_t_get_pseudocode(self, *args)

    def refresh_func_ctext(self, *args):
        """
        refresh_func_ctext(self)
        """
        return _ida_hexrays.cfuncptr_t_refresh_func_ctext(self, *args)

    def gather_derefs(self, *args):
        """
        gather_derefs(self, ci, udm=None) -> bool
        """
        return _ida_hexrays.cfuncptr_t_gather_derefs(self, *args)

    def find_item_coords(self, *args):
        """
        find_item_coords(self, item, px, py) -> bool
        find_item_coords(self, item) -> PyObject *
        """
        return _ida_hexrays.cfuncptr_t_find_item_coords(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> qstring
        """
        return _ida_hexrays.cfuncptr_t___str__(self, *args)

cfuncptr_t_swigregister = _ida_hexrays.cfuncptr_t_swigregister
cfuncptr_t_swigregister(cfuncptr_t)

class qvector_history_t(object):
    """
    Proxy of C++ qvector<(history_item_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_history_t
        __init__(self, x) -> qvector_history_t
        """
        this = _ida_hexrays.new_qvector_history_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_history_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_history_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_history_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_history_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_history_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_history_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=history_item_t())
        """
        return _ida_hexrays.qvector_history_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_history_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_history_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_history_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_history_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_history_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_history_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> history_item_t
        begin(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> history_item_t
        end(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> history_item_t
        erase(self, first, last) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> history_item_t
        find(self, x) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_history_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_history_t_swigregister = _ida_hexrays.qvector_history_t_swigregister
qvector_history_t_swigregister(qvector_history_t)

class history_t(qvector_history_t):
    """
    Proxy of C++ qstack<(history_item_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def pop(self, *args):
        """
        pop(self) -> history_item_t
        """
        return _ida_hexrays.history_t_pop(self, *args)

    def top(self, *args):
        """
        top(self) -> history_item_t
        top(self) -> history_item_t
        """
        return _ida_hexrays.history_t_top(self, *args)

    def push(self, *args):
        """
        push(self, v)
        """
        return _ida_hexrays.history_t_push(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> history_t
        """
        this = _ida_hexrays.new_history_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_history_t
    __del__ = lambda self : None;
history_t_swigregister = _ida_hexrays.history_t_swigregister
history_t_swigregister(history_t)

class qlist_cinsn_t_iterator(object):
    """
    Proxy of C++ qlist_cinsn_t_iterator class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cur = _swig_property(_ida_hexrays.qlist_cinsn_t_iterator_cur_get)
    def next(self, *args):
        """
        next(self)
        """
        return _ida_hexrays.qlist_cinsn_t_iterator_next(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_iterator___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_iterator___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> qlist_cinsn_t_iterator
        """
        this = _ida_hexrays.new_qlist_cinsn_t_iterator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qlist_cinsn_t_iterator
    __del__ = lambda self : None;
qlist_cinsn_t_iterator_swigregister = _ida_hexrays.qlist_cinsn_t_iterator_swigregister
qlist_cinsn_t_iterator_swigregister(qlist_cinsn_t_iterator)

class qvector_lvar_t(object):
    """
    Proxy of C++ qvector<(lvar_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_lvar_t
        __init__(self, x) -> qvector_lvar_t
        """
        this = _ida_hexrays.new_qvector_lvar_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_lvar_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_lvar_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_lvar_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_lvar_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_lvar_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=lvar_t())
        """
        return _ida_hexrays.qvector_lvar_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_lvar_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_lvar_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_lvar_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_lvar_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_lvar_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_lvar_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> lvar_t
        begin(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> lvar_t
        end(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> lvar_t
        erase(self, first, last) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> lvar_t
        find(self, x) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_lvar_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_lvar_t_swigregister = _ida_hexrays.qvector_lvar_t_swigregister
qvector_lvar_t_swigregister(qvector_lvar_t)

class qlist_cinsn_t(object):
    """
    Proxy of C++ qlist<(cinsn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qlist_cinsn_t
        __init__(self, x) -> qlist_cinsn_t
        """
        this = _ida_hexrays.new_qlist_cinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qlist_cinsn_t
    __del__ = lambda self : None;
    def swap(self, *args):
        """
        swap(self, x)
        """
        return _ida_hexrays.qlist_cinsn_t_swap(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_empty(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qlist_cinsn_t_size(self, *args)

    def front(self, *args):
        """
        front(self) -> cinsn_t
        front(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_front(self, *args)

    def back(self, *args):
        """
        back(self) -> cinsn_t
        back(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_back(self, *args)

    def rbegin(self, *args):
        """
        rbegin(self) -> qlist< cinsn_t >::reverse_iterator
        rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_rbegin(self, *args)

    def rend(self, *args):
        """
        rend(self) -> qlist< cinsn_t >::reverse_iterator
        rend(self) -> qlist< cinsn_t >::const_reverse_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_rend(self, *args)

    def push_front(self, *args):
        """
        push_front(self, x)
        """
        return _ida_hexrays.qlist_cinsn_t_push_front(self, *args)

    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_push_back(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qlist_cinsn_t_clear(self, *args)

    def pop_front(self, *args):
        """
        pop_front(self)
        """
        return _ida_hexrays.qlist_cinsn_t_pop_front(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qlist_cinsn_t_pop_back(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, p, x) -> qlist< cinsn_t >::iterator
        insert(self, p) -> qlist< cinsn_t >::iterator
        insert(self, p, x) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, p) -> qlist< cinsn_t >::iterator
        erase(self, p1, p2)
        erase(self, p)
        """
        return _ida_hexrays.qlist_cinsn_t_erase(self, *args)

qlist_cinsn_t_swigregister = _ida_hexrays.qlist_cinsn_t_swigregister
qlist_cinsn_t_swigregister(qlist_cinsn_t)

class qvector_carg_t(object):
    """
    Proxy of C++ qvector<(carg_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_carg_t
        __init__(self, x) -> qvector_carg_t
        """
        this = _ida_hexrays.new_qvector_carg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_carg_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_carg_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_carg_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_carg_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_carg_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_carg_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=carg_t())
        """
        return _ida_hexrays.qvector_carg_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_carg_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_carg_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_carg_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_carg_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_carg_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_carg_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> carg_t
        begin(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> carg_t
        end(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> carg_t
        erase(self, first, last) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> carg_t
        find(self, x) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_carg_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_carg_t_swigregister = _ida_hexrays.qvector_carg_t_swigregister
qvector_carg_t_swigregister(qvector_carg_t)

class qvector_ccase_t(object):
    """
    Proxy of C++ qvector<(ccase_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_ccase_t
        __init__(self, x) -> qvector_ccase_t
        """
        this = _ida_hexrays.new_qvector_ccase_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_ccase_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_ccase_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_ccase_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_ccase_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_ccase_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=ccase_t())
        """
        return _ida_hexrays.qvector_ccase_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_ccase_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_ccase_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_ccase_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_ccase_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_ccase_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_ccase_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> ccase_t
        begin(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> ccase_t
        end(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> ccase_t
        erase(self, first, last) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> ccase_t
        find(self, x) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_ccase_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_ccase_t_swigregister = _ida_hexrays.qvector_ccase_t_swigregister
qvector_ccase_t_swigregister(qvector_ccase_t)

class lvar_saved_infos_t(object):
    """
    Proxy of C++ qvector<(lvar_saved_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> lvar_saved_infos_t
        __init__(self, x) -> lvar_saved_infos_t
        """
        this = _ida_hexrays.new_lvar_saved_infos_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_saved_infos_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.lvar_saved_infos_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=lvar_saved_info_t())
        """
        return _ida_hexrays.lvar_saved_infos_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.lvar_saved_infos_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.lvar_saved_infos_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.lvar_saved_infos_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> lvar_saved_info_t
        begin(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> lvar_saved_info_t
        end(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> lvar_saved_info_t
        erase(self, first, last) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> lvar_saved_info_t
        find(self, x) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.lvar_saved_infos_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

lvar_saved_infos_t_swigregister = _ida_hexrays.lvar_saved_infos_t_swigregister
lvar_saved_infos_t_swigregister(lvar_saved_infos_t)

class ui_stroff_ops_t(object):
    """
    Proxy of C++ qvector<(ui_stroff_op_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> ui_stroff_ops_t
        __init__(self, x) -> ui_stroff_ops_t
        """
        this = _ida_hexrays.new_ui_stroff_ops_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ui_stroff_ops_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.ui_stroff_ops_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.ui_stroff_ops_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.ui_stroff_ops_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.ui_stroff_ops_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.ui_stroff_ops_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=ui_stroff_op_t())
        """
        return _ida_hexrays.ui_stroff_ops_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.ui_stroff_ops_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.ui_stroff_ops_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.ui_stroff_ops_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.ui_stroff_ops_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.ui_stroff_ops_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> ui_stroff_op_t
        begin(self) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> ui_stroff_op_t
        end(self) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> ui_stroff_op_t
        erase(self, first, last) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> ui_stroff_op_t
        find(self, x) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.ui_stroff_ops_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.ui_stroff_ops_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> ui_stroff_op_t
        """
        return _ida_hexrays.ui_stroff_ops_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.ui_stroff_ops_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

ui_stroff_ops_t_swigregister = _ida_hexrays.ui_stroff_ops_t_swigregister
ui_stroff_ops_t_swigregister(ui_stroff_ops_t)


def qswap(*args):
  """
  qswap(a, b)
  """
  return _ida_hexrays.qswap(*args)
class fnum_array(object):
    """
    Proxy of C++ wrapped_array_t<(uint16,6)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_ida_hexrays.fnum_array_data_get)
    def __init__(self, *args):
        """
        __init__(self, data) -> fnum_array
        """
        this = _ida_hexrays.new_fnum_array(*args)
        try: self.this.append(this)
        except: self.this = this
    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.fnum_array___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> unsigned short const &
        """
        return _ida_hexrays.fnum_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.fnum_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_hexrays.delete_fnum_array
    __del__ = lambda self : None;
fnum_array_swigregister = _ida_hexrays.fnum_array_swigregister
fnum_array_swigregister(fnum_array)


def debug_hexrays_ctree(*args):
  """
  debug_hexrays_ctree(msg)
  """
  return _ida_hexrays.debug_hexrays_ctree(*args)

def init_hexrays_plugin(*args):
  """
  init_hexrays_plugin(flags=0) -> bool


  Initialize your plugin for hex-rays decompiler. This function must be
  called before calling any other decompiler function. It initializes
  the pointer to the dispatcher.
  
  @param flags: reserved, must be 0 (C++: int)
  @return: true if the decompiler exists and the dispatcher pointer is
           ready to use.
  """
  return _ida_hexrays.init_hexrays_plugin(*args)

def get_widget_vdui(*args):
  """
  get_widget_vdui(f) -> vdui_t


  Get the 'vdui_t' instance associated to the TWidget
  
  @param f: pointer to window (C++: TWidget *)
  @return: a  vdui_t  *, or NULL
  """
  return _ida_hexrays.get_widget_vdui(*args)

def boundaries_find(*args):
  """
  boundaries_find(map, key) -> boundaries_iterator_t


  Find the specified key in boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  @param key (C++: const  cinsn_t  *&)
  """
  return _ida_hexrays.boundaries_find(*args)

def boundaries_insert(*args):
  """
  boundaries_insert(map, key, val) -> boundaries_iterator_t


  Insert new ( 'cinsn_t' *, 'rangeset_t' ) pair into boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  @param key (C++: const  cinsn_t  *&)
  @param val (C++: const  rangeset_t  &)
  """
  return _ida_hexrays.boundaries_insert(*args)

def term_hexrays_plugin(*args):
  """
  term_hexrays_plugin()


  Stop working with hex-rays decompiler.
  """
  return _ida_hexrays.term_hexrays_plugin(*args)
class Hexrays_Hooks(object):
    """
    Proxy of C++ Hexrays_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _flags=0) -> Hexrays_Hooks
        """
        if self.__class__ == Hexrays_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_Hexrays_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_Hexrays_Hooks
    __del__ = lambda self : None;
    def hook(self, *args):
        """
        hook(self) -> bool
        """
        return _ida_hexrays.Hexrays_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool
        """
        return _ida_hexrays.Hexrays_Hooks_unhook(self, *args)

    def flowchart(self, *args):
        """
        flowchart(self, fc) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_flowchart(self, *args)

    def stkpnts(self, *args):
        """
        stkpnts(self, mba, _sps) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_stkpnts(self, *args)

    def prolog(self, *args):
        """
        prolog(self, mba, fc, reachable_blocks) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_prolog(self, *args)

    def microcode(self, *args):
        """
        microcode(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_microcode(self, *args)

    def preoptimized(self, *args):
        """
        preoptimized(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_preoptimized(self, *args)

    def locopt(self, *args):
        """
        locopt(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_locopt(self, *args)

    def prealloc(self, *args):
        """
        prealloc(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_prealloc(self, *args)

    def glbopt(self, *args):
        """
        glbopt(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_glbopt(self, *args)

    def structural(self, *args):
        """
        structural(self, ct) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_structural(self, *args)

    def maturity(self, *args):
        """
        maturity(self, cfunc, new_maturity) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_maturity(self, *args)

    def interr(self, *args):
        """
        interr(self, errcode) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_interr(self, *args)

    def combine(self, *args):
        """
        combine(self, blk, insn) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_combine(self, *args)

    def print_func(self, *args):
        """
        print_func(self, cfunc, vp) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_print_func(self, *args)

    def func_printed(self, *args):
        """
        func_printed(self, cfunc) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_func_printed(self, *args)

    def resolve_stkaddrs(self, *args):
        """
        resolve_stkaddrs(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_resolve_stkaddrs(self, *args)

    def open_pseudocode(self, *args):
        """
        open_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_open_pseudocode(self, *args)

    def switch_pseudocode(self, *args):
        """
        switch_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_switch_pseudocode(self, *args)

    def refresh_pseudocode(self, *args):
        """
        refresh_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_refresh_pseudocode(self, *args)

    def close_pseudocode(self, *args):
        """
        close_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_close_pseudocode(self, *args)

    def keyboard(self, *args):
        """
        keyboard(self, vu, key_code, shift_state) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_keyboard(self, *args)

    def right_click(self, *args):
        """
        right_click(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_right_click(self, *args)

    def double_click(self, *args):
        """
        double_click(self, vu, shift_state) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_double_click(self, *args)

    def curpos(self, *args):
        """
        curpos(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_curpos(self, *args)

    def create_hint(self, *args):
        """
        create_hint(self, vu) -> PyObject *
        """
        return _ida_hexrays.Hexrays_Hooks_create_hint(self, *args)

    def text_ready(self, *args):
        """
        text_ready(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_text_ready(self, *args)

    def populating_popup(self, *args):
        """
        populating_popup(self, widget, popup_handle, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_populating_popup(self, *args)

    def lvar_name_changed(self, *args):
        """
        lvar_name_changed(self, vu, v, name, is_user_name) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_name_changed(self, *args)

    def lvar_type_changed(self, *args):
        """
        lvar_type_changed(self, vu, v, tinfo) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_type_changed(self, *args)

    def lvar_cmt_changed(self, *args):
        """
        lvar_cmt_changed(self, vu, v, cmt) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_cmt_changed(self, *args)

    def lvar_mapping_changed(self, *args):
        """
        lvar_mapping_changed(self, vu, frm, to) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_mapping_changed(self, *args)

    def cmt_changed(self, *args):
        """
        cmt_changed(self, cfunc, loc, cmt) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_cmt_changed(self, *args)

    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_Hexrays_Hooks(self)
        return weakref_proxy(self)
Hexrays_Hooks_swigregister = _ida_hexrays.Hexrays_Hooks_swigregister
Hexrays_Hooks_swigregister(Hexrays_Hooks)

class uval_ivl_t(object):
    """
    Proxy of C++ ivl_tpl<(uval_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    off = _swig_property(_ida_hexrays.uval_ivl_t_off_get, _ida_hexrays.uval_ivl_t_off_set)
    size = _swig_property(_ida_hexrays.uval_ivl_t_size_get, _ida_hexrays.uval_ivl_t_size_set)
    def __init__(self, *args):
        """
        __init__(self, _off, _size) -> uval_ivl_t
        """
        this = _ida_hexrays.new_uval_ivl_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def valid(self, *args):
        """
        valid(self) -> bool
        """
        return _ida_hexrays.uval_ivl_t_valid(self, *args)

    def end(self, *args):
        """
        end(self) -> unsigned long long
        """
        return _ida_hexrays.uval_ivl_t_end(self, *args)

    def last(self, *args):
        """
        last(self) -> unsigned long long
        """
        return _ida_hexrays.uval_ivl_t_last(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_uval_ivl_t
    __del__ = lambda self : None;
uval_ivl_t_swigregister = _ida_hexrays.uval_ivl_t_swigregister
uval_ivl_t_swigregister(uval_ivl_t)

class uval_ivl_ivlset_t(object):
    """
    Proxy of C++ ivlset_tpl<(ivl_t,uval_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> uval_ivl_ivlset_t
        __init__(self, ivl) -> uval_ivl_ivlset_t
        """
        this = _ida_hexrays.new_uval_ivl_ivlset_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.uval_ivl_ivlset_t_swap(self, *args)

    def getivl(self, *args):
        """
        getivl(self, idx) -> ivl_t
        """
        return _ida_hexrays.uval_ivl_ivlset_t_getivl(self, *args)

    def lastivl(self, *args):
        """
        lastivl(self) -> ivl_t
        """
        return _ida_hexrays.uval_ivl_ivlset_t_lastivl(self, *args)

    def nivls(self, *args):
        """
        nivls(self) -> size_t
        """
        return _ida_hexrays.uval_ivl_ivlset_t_nivls(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.uval_ivl_ivlset_t_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.uval_ivl_ivlset_t_clear(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.uval_ivl_ivlset_t_qclear(self, *args)

    def all_values(self, *args):
        """
        all_values(self) -> bool
        """
        return _ida_hexrays.uval_ivl_ivlset_t_all_values(self, *args)

    def set_all_values(self, *args):
        """
        set_all_values(self)
        """
        return _ida_hexrays.uval_ivl_ivlset_t_set_all_values(self, *args)

    def single_value(self, *args):
        """
        single_value(self, v) -> bool
        """
        return _ida_hexrays.uval_ivl_ivlset_t_single_value(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, v) -> bool
        """
        return _ida_hexrays.uval_ivl_ivlset_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, v) -> bool
        """
        return _ida_hexrays.uval_ivl_ivlset_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> ivlset_tpl< ivl_t,unsigned long long >::const_iterator
        begin(self) -> ivlset_tpl< ivl_t,unsigned long long >::iterator
        """
        return _ida_hexrays.uval_ivl_ivlset_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> ivlset_tpl< ivl_t,unsigned long long >::const_iterator
        end(self) -> ivlset_tpl< ivl_t,unsigned long long >::iterator
        """
        return _ida_hexrays.uval_ivl_ivlset_t_end(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_uval_ivl_ivlset_t
    __del__ = lambda self : None;
uval_ivl_ivlset_t_swigregister = _ida_hexrays.uval_ivl_ivlset_t_swigregister
uval_ivl_ivlset_t_swigregister(uval_ivl_ivlset_t)

class array_of_ivlsets(object):
    """
    Proxy of C++ qvector<(ivlset_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> array_of_ivlsets
        __init__(self, x) -> array_of_ivlsets
        """
        this = _ida_hexrays.new_array_of_ivlsets(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_array_of_ivlsets
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.array_of_ivlsets_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.array_of_ivlsets_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.array_of_ivlsets_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.array_of_ivlsets_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.array_of_ivlsets_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.array_of_ivlsets_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=ivlset_t())
        """
        return _ida_hexrays.array_of_ivlsets_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.array_of_ivlsets_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.array_of_ivlsets_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.array_of_ivlsets_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.array_of_ivlsets_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.array_of_ivlsets_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.array_of_ivlsets___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.array_of_ivlsets___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> ivlset_t
        begin(self) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> ivlset_t
        end(self) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> ivlset_t
        erase(self, first, last) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> ivlset_t
        find(self, x) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.array_of_ivlsets_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.array_of_ivlsets_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.array_of_ivlsets__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.array_of_ivlsets___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> ivlset_t
        """
        return _ida_hexrays.array_of_ivlsets___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.array_of_ivlsets___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

array_of_ivlsets_swigregister = _ida_hexrays.array_of_ivlsets_swigregister
array_of_ivlsets_swigregister(array_of_ivlsets)

MAX_SUPPORTED_STACK_SIZE = _ida_hexrays.MAX_SUPPORTED_STACK_SIZE

def hexrays_alloc(*args):
  """
  hexrays_alloc(size) -> void *
  """
  return _ida_hexrays.hexrays_alloc(*args)

def hexrays_free(*args):
  """
  hexrays_free(ptr)
  """
  return _ida_hexrays.hexrays_free(*args)
MAX_VLR_SIZE = _ida_hexrays.MAX_VLR_SIZE
CMP_NZ = _ida_hexrays.CMP_NZ
CMP_Z = _ida_hexrays.CMP_Z
CMP_AE = _ida_hexrays.CMP_AE
CMP_B = _ida_hexrays.CMP_B
CMP_A = _ida_hexrays.CMP_A
CMP_BE = _ida_hexrays.CMP_BE
CMP_GT = _ida_hexrays.CMP_GT
CMP_GE = _ida_hexrays.CMP_GE
CMP_LT = _ida_hexrays.CMP_LT
CMP_LE = _ida_hexrays.CMP_LE
class valrng_t(object):
    """
    Proxy of C++ valrng_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, size_=MAX_VLR_SIZE) -> valrng_t
        __init__(self, r) -> valrng_t
        """
        this = _ida_hexrays.new_valrng_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_valrng_t
    __del__ = lambda self : None;
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.valrng_t_swap(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.valrng_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.valrng_t_compare(self, *args)

    def set_none(self, *args):
        """
        set_none(self)
        """
        return _ida_hexrays.valrng_t_set_none(self, *args)

    def set_all(self, *args):
        """
        set_all(self)
        """
        return _ida_hexrays.valrng_t_set_all(self, *args)

    def set_unk(self, *args):
        """
        set_unk(self)
        """
        return _ida_hexrays.valrng_t_set_unk(self, *args)

    def set_eq(self, *args):
        """
        set_eq(self, v)
        """
        return _ida_hexrays.valrng_t_set_eq(self, *args)

    def set_cmp(self, *args):
        """
        set_cmp(self, cmp, _value)
        """
        return _ida_hexrays.valrng_t_set_cmp(self, *args)

    def reduce_size(self, *args):
        """
        reduce_size(self, new_size) -> bool
        """
        return _ida_hexrays.valrng_t_reduce_size(self, *args)

    def intersect_with(self, *args):
        """
        intersect_with(self, r) -> bool
        """
        return _ida_hexrays.valrng_t_intersect_with(self, *args)

    def unite_with(self, *args):
        """
        unite_with(self, r) -> bool
        """
        return _ida_hexrays.valrng_t_unite_with(self, *args)

    def inverse(self, *args):
        """
        inverse(self)
        """
        return _ida_hexrays.valrng_t_inverse(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.valrng_t_empty(self, *args)

    def all_values(self, *args):
        """
        all_values(self) -> bool
        """
        return _ida_hexrays.valrng_t_all_values(self, *args)

    def is_unknown(self, *args):
        """
        is_unknown(self) -> bool
        """
        return _ida_hexrays.valrng_t_is_unknown(self, *args)

    def has(self, *args):
        """
        has(self, v) -> bool
        """
        return _ida_hexrays.valrng_t_has(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.valrng_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.valrng_t_dstr(self, *args)

    def cvt_to_single_value(self, *args):
        """
        cvt_to_single_value(self) -> bool
        """
        return _ida_hexrays.valrng_t_cvt_to_single_value(self, *args)

    def cvt_to_cmp(self, *args):
        """
        cvt_to_cmp(self, strict) -> bool
        """
        return _ida_hexrays.valrng_t_cvt_to_cmp(self, *args)

    def get_size(self, *args):
        """
        get_size(self) -> int
        """
        return _ida_hexrays.valrng_t_get_size(self, *args)

    def max_value(self, *args):
        """
        max_value(self, size_) -> uvlr_t
        max_value(self) -> uvlr_t
        """
        return _ida_hexrays.valrng_t_max_value(self, *args)

    def min_svalue(self, *args):
        """
        min_svalue(self, size_) -> uvlr_t
        min_svalue(self) -> uvlr_t
        """
        return _ida_hexrays.valrng_t_min_svalue(self, *args)

    def max_svalue(self, *args):
        """
        max_svalue(self, size_) -> uvlr_t
        max_svalue(self) -> uvlr_t
        """
        return _ida_hexrays.valrng_t_max_svalue(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.valrng_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.valrng_t__deregister(self, *args)

valrng_t_swigregister = _ida_hexrays.valrng_t_swigregister
valrng_t_swigregister(valrng_t)
cvar = _ida_hexrays.cvar
MAX_VALUE = cvar.MAX_VALUE
MAX_SVALUE = cvar.MAX_SVALUE
MIN_SVALUE = cvar.MIN_SVALUE

NO_ACCESS = _ida_hexrays.NO_ACCESS
WRITE_ACCESS = _ida_hexrays.WRITE_ACCESS
READ_ACCESS = _ida_hexrays.READ_ACCESS
RW_ACCESS = _ida_hexrays.RW_ACCESS

def is_may_access(*args):
  """
  is_may_access(maymust) -> bool
  """
  return _ida_hexrays.is_may_access(*args)
MERR_OK = _ida_hexrays.MERR_OK
MERR_BLOCK = _ida_hexrays.MERR_BLOCK
MERR_INTERR = _ida_hexrays.MERR_INTERR
MERR_INSN = _ida_hexrays.MERR_INSN
MERR_MEM = _ida_hexrays.MERR_MEM
MERR_BADBLK = _ida_hexrays.MERR_BADBLK
MERR_BADSP = _ida_hexrays.MERR_BADSP
MERR_PROLOG = _ida_hexrays.MERR_PROLOG
MERR_SWITCH = _ida_hexrays.MERR_SWITCH
MERR_EXCEPTION = _ida_hexrays.MERR_EXCEPTION
MERR_HUGESTACK = _ida_hexrays.MERR_HUGESTACK
MERR_LVARS = _ida_hexrays.MERR_LVARS
MERR_BITNESS = _ida_hexrays.MERR_BITNESS
MERR_BADCALL = _ida_hexrays.MERR_BADCALL
MERR_BADFRAME = _ida_hexrays.MERR_BADFRAME
MERR_UNKTYPE = _ida_hexrays.MERR_UNKTYPE
MERR_BADIDB = _ida_hexrays.MERR_BADIDB
MERR_SIZEOF = _ida_hexrays.MERR_SIZEOF
MERR_REDO = _ida_hexrays.MERR_REDO
MERR_CANCELED = _ida_hexrays.MERR_CANCELED
MERR_RECDEPTH = _ida_hexrays.MERR_RECDEPTH
MERR_OVERLAP = _ida_hexrays.MERR_OVERLAP
MERR_PARTINIT = _ida_hexrays.MERR_PARTINIT
MERR_COMPLEX = _ida_hexrays.MERR_COMPLEX
MERR_LICENSE = _ida_hexrays.MERR_LICENSE
MERR_ONLY32 = _ida_hexrays.MERR_ONLY32
MERR_ONLY64 = _ida_hexrays.MERR_ONLY64
MERR_BUSY = _ida_hexrays.MERR_BUSY
MERR_FARPTR = _ida_hexrays.MERR_FARPTR
MERR_EXTERN = _ida_hexrays.MERR_EXTERN
MERR_FUNCSIZE = _ida_hexrays.MERR_FUNCSIZE
MERR_BADRANGES = _ida_hexrays.MERR_BADRANGES
MERR_STOP = _ida_hexrays.MERR_STOP
MERR_MAX_ERR = _ida_hexrays.MERR_MAX_ERR
MERR_LOOP = _ida_hexrays.MERR_LOOP

def get_merror_desc(*args):
  """
  get_merror_desc(code, mba) -> ea_t


  Get textual description of an error code
  
  @param code: Microcode error codes (C++: merror_t)
  @param mba: the microcode array (C++: mbl_array_t  *)
  @return: the error address
  """
  return _ida_hexrays.get_merror_desc(*args)

def reg2mreg(*args):
  """
  reg2mreg(reg) -> mreg_t


  Map a processor register to microregister.
  
  @param reg: processor register number (C++: int)
  @return: microregister register id or mr_none
  """
  return _ida_hexrays.reg2mreg(*args)

def mreg2reg(*args):
  """
  mreg2reg(reg, width) -> int


  Map a microregister to processor register.
  
  @param reg: microregister number (C++: mreg_t)
  @param width: size of microregister in bytes (C++: int)
  @return: processor register id or -1
  """
  return _ida_hexrays.mreg2reg(*args)
class optinsn_t(object):
    """
    Proxy of C++ optinsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def func(self, *args):
        """
        func(self, blk, ins) -> int
        """
        return _ida_hexrays.optinsn_t_func(self, *args)

    def install(self, *args):
        """
        install(self)
        """
        return _ida_hexrays.optinsn_t_install(self, *args)

    def remove(self, *args):
        """
        remove(self) -> bool
        """
        return _ida_hexrays.optinsn_t_remove(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_optinsn_t
    __del__ = lambda self : None;
    def __init__(self, *args):
        """
        __init__(self) -> optinsn_t
        """
        if self.__class__ == optinsn_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_optinsn_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_optinsn_t(self)
        return weakref_proxy(self)
optinsn_t_swigregister = _ida_hexrays.optinsn_t_swigregister
optinsn_t_swigregister(optinsn_t)
MUST_ACCESS = cvar.MUST_ACCESS
MAY_ACCESS = cvar.MAY_ACCESS
MAYMUST_ACCESS_MASK = cvar.MAYMUST_ACCESS_MASK
ONE_ACCESS_TYPE = cvar.ONE_ACCESS_TYPE
INCLUDE_SPOILED_REGS = cvar.INCLUDE_SPOILED_REGS
EXCLUDE_PASS_REGS = cvar.EXCLUDE_PASS_REGS
FULL_XDSU = cvar.FULL_XDSU
WITH_ASSERTS = cvar.WITH_ASSERTS
EXCLUDE_VOLATILE = cvar.EXCLUDE_VOLATILE
INCLUDE_UNUSED_SRC = cvar.INCLUDE_UNUSED_SRC
INCLUDE_DEAD_RETREGS = cvar.INCLUDE_DEAD_RETREGS
INCLUDE_RESTRICTED = cvar.INCLUDE_RESTRICTED
CALL_SPOILS_ONLY_ARGS = cvar.CALL_SPOILS_ONLY_ARGS

class optblock_t(object):
    """
    Proxy of C++ optblock_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def func(self, *args):
        """
        func(self, blk) -> int
        """
        return _ida_hexrays.optblock_t_func(self, *args)

    def install(self, *args):
        """
        install(self)
        """
        return _ida_hexrays.optblock_t_install(self, *args)

    def remove(self, *args):
        """
        remove(self) -> bool
        """
        return _ida_hexrays.optblock_t_remove(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_optblock_t
    __del__ = lambda self : None;
    def __init__(self, *args):
        """
        __init__(self) -> optblock_t
        """
        if self.__class__ == optblock_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_optblock_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_optblock_t(self)
        return weakref_proxy(self)
optblock_t_swigregister = _ida_hexrays.optblock_t_swigregister
optblock_t_swigregister(optblock_t)

m_nop = _ida_hexrays.m_nop
m_stx = _ida_hexrays.m_stx
m_ldx = _ida_hexrays.m_ldx
m_ldc = _ida_hexrays.m_ldc
m_mov = _ida_hexrays.m_mov
m_neg = _ida_hexrays.m_neg
m_lnot = _ida_hexrays.m_lnot
m_bnot = _ida_hexrays.m_bnot
m_xds = _ida_hexrays.m_xds
m_xdu = _ida_hexrays.m_xdu
m_low = _ida_hexrays.m_low
m_high = _ida_hexrays.m_high
m_add = _ida_hexrays.m_add
m_sub = _ida_hexrays.m_sub
m_mul = _ida_hexrays.m_mul
m_udiv = _ida_hexrays.m_udiv
m_sdiv = _ida_hexrays.m_sdiv
m_umod = _ida_hexrays.m_umod
m_smod = _ida_hexrays.m_smod
m_or = _ida_hexrays.m_or
m_and = _ida_hexrays.m_and
m_xor = _ida_hexrays.m_xor
m_shl = _ida_hexrays.m_shl
m_shr = _ida_hexrays.m_shr
m_sar = _ida_hexrays.m_sar
m_cfadd = _ida_hexrays.m_cfadd
m_ofadd = _ida_hexrays.m_ofadd
m_cfshl = _ida_hexrays.m_cfshl
m_cfshr = _ida_hexrays.m_cfshr
m_sets = _ida_hexrays.m_sets
m_seto = _ida_hexrays.m_seto
m_setp = _ida_hexrays.m_setp
m_setnz = _ida_hexrays.m_setnz
m_setz = _ida_hexrays.m_setz
m_setae = _ida_hexrays.m_setae
m_setb = _ida_hexrays.m_setb
m_seta = _ida_hexrays.m_seta
m_setbe = _ida_hexrays.m_setbe
m_setg = _ida_hexrays.m_setg
m_setge = _ida_hexrays.m_setge
m_setl = _ida_hexrays.m_setl
m_setle = _ida_hexrays.m_setle
m_jcnd = _ida_hexrays.m_jcnd
m_jnz = _ida_hexrays.m_jnz
m_jz = _ida_hexrays.m_jz
m_jae = _ida_hexrays.m_jae
m_jb = _ida_hexrays.m_jb
m_ja = _ida_hexrays.m_ja
m_jbe = _ida_hexrays.m_jbe
m_jg = _ida_hexrays.m_jg
m_jge = _ida_hexrays.m_jge
m_jl = _ida_hexrays.m_jl
m_jle = _ida_hexrays.m_jle
m_jtbl = _ida_hexrays.m_jtbl
m_ijmp = _ida_hexrays.m_ijmp
m_goto = _ida_hexrays.m_goto
m_call = _ida_hexrays.m_call
m_icall = _ida_hexrays.m_icall
m_ret = _ida_hexrays.m_ret
m_push = _ida_hexrays.m_push
m_pop = _ida_hexrays.m_pop
m_und = _ida_hexrays.m_und
m_ext = _ida_hexrays.m_ext
m_f2i = _ida_hexrays.m_f2i
m_f2u = _ida_hexrays.m_f2u
m_i2f = _ida_hexrays.m_i2f
m_u2f = _ida_hexrays.m_u2f
m_f2f = _ida_hexrays.m_f2f
m_fneg = _ida_hexrays.m_fneg
m_fadd = _ida_hexrays.m_fadd
m_fsub = _ida_hexrays.m_fsub
m_fmul = _ida_hexrays.m_fmul
m_fdiv = _ida_hexrays.m_fdiv

def must_mcode_close_block(*args):
  """
  must_mcode_close_block(mcode, including_calls) -> bool


  Must an instruction with the given opcode be the last one in a block?
  Such opcodes are called closing opcodes.
  
  @param mcode: instruction opcode (C++: mcode_t)
  @param including_calls: should m_call/m_icall be considered as the
                          closing opcodes? If this function returns
                          true, the opcode cannot appear in the middle
                          of a block. Calls are a special case because
                          before MMAT_CALLS they are closing opcodes.
                          Afteer MMAT_CALLS that are not considered as
                          closing opcodes. (C++: bool)
  """
  return _ida_hexrays.must_mcode_close_block(*args)

def is_mcode_propagatable(*args):
  """
  is_mcode_propagatable(mcode) -> bool


  May opcode be propagated? Such opcodes can be used in sub-instructions
  (nested instructions) There is a handful of non-propagatable opcodes,
  like jumps, ret, nop, etc All other regular opcodes are propagatable
  and may appear in a nested instruction.
  
  @param mcode (C++: mcode_t)
  """
  return _ida_hexrays.is_mcode_propagatable(*args)

def is_mcode_addsub(*args):
  """
  is_mcode_addsub(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_addsub(*args)

def is_mcode_xdsu(*args):
  """
  is_mcode_xdsu(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_xdsu(*args)

def is_mcode_set(*args):
  """
  is_mcode_set(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_set(*args)

def is_mcode_set1(*args):
  """
  is_mcode_set1(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_set1(*args)

def is_mcode_j1(*args):
  """
  is_mcode_j1(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_j1(*args)

def is_mcode_jcond(*args):
  """
  is_mcode_jcond(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_jcond(*args)

def is_mcode_convertible_to_jmp(*args):
  """
  is_mcode_convertible_to_jmp(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_convertible_to_jmp(*args)

def is_mcode_convertible_to_set(*args):
  """
  is_mcode_convertible_to_set(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_convertible_to_set(*args)

def is_mcode_call(*args):
  """
  is_mcode_call(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_call(*args)

def is_mcode_fpu(*args):
  """
  is_mcode_fpu(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_fpu(*args)

def is_mcode_commutative(*args):
  """
  is_mcode_commutative(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_commutative(*args)

def is_mcode_shift(*args):
  """
  is_mcode_shift(mcode) -> bool
  """
  return _ida_hexrays.is_mcode_shift(*args)

def is_mcode_divmod(*args):
  """
  is_mcode_divmod(op) -> bool
  """
  return _ida_hexrays.is_mcode_divmod(*args)

def set2jcnd(*args):
  """
  set2jcnd(code) -> mcode_t
  """
  return _ida_hexrays.set2jcnd(*args)

def jcnd2set(*args):
  """
  jcnd2set(code) -> mcode_t
  """
  return _ida_hexrays.jcnd2set(*args)

def negate_mcode_relation(*args):
  """
  negate_mcode_relation(code) -> mcode_t
  """
  return _ida_hexrays.negate_mcode_relation(*args)

def swap_mcode_relation(*args):
  """
  swap_mcode_relation(code) -> mcode_t
  """
  return _ida_hexrays.swap_mcode_relation(*args)

def get_signed_mcode(*args):
  """
  get_signed_mcode(code) -> mcode_t
  """
  return _ida_hexrays.get_signed_mcode(*args)

def get_unsigned_mcode(*args):
  """
  get_unsigned_mcode(code) -> mcode_t
  """
  return _ida_hexrays.get_unsigned_mcode(*args)

def is_signed_mcode(*args):
  """
  is_signed_mcode(code) -> bool
  """
  return _ida_hexrays.is_signed_mcode(*args)

def is_unsigned_mcode(*args):
  """
  is_unsigned_mcode(code) -> bool
  """
  return _ida_hexrays.is_unsigned_mcode(*args)

def mcode_modifies_d(*args):
  """
  mcode_modifies_d(mcode) -> bool
  """
  return _ida_hexrays.mcode_modifies_d(*args)
class operand_locator_t(object):
    """
    Proxy of C++ operand_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.operand_locator_t_ea_get, _ida_hexrays.operand_locator_t_ea_set)
    opnum = _swig_property(_ida_hexrays.operand_locator_t_opnum_get, _ida_hexrays.operand_locator_t_opnum_set)
    def __init__(self, *args):
        """
        __init__(self, _ea, _opnum) -> operand_locator_t
        """
        this = _ida_hexrays.new_operand_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.operand_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_operand_locator_t
    __del__ = lambda self : None;
operand_locator_t_swigregister = _ida_hexrays.operand_locator_t_swigregister
operand_locator_t_swigregister(operand_locator_t)
mr_none = cvar.mr_none
mr_cf = cvar.mr_cf
mr_zf = cvar.mr_zf
mr_sf = cvar.mr_sf
mr_of = cvar.mr_of
mr_pf = cvar.mr_pf
cc_count = cvar.cc_count
mr_cc = cvar.mr_cc
mr_first = cvar.mr_first

class number_format_t(object):
    """
    Proxy of C++ number_format_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flags = _swig_property(_ida_hexrays.number_format_t_flags_get, _ida_hexrays.number_format_t_flags_set)
    opnum = _swig_property(_ida_hexrays.number_format_t_opnum_get, _ida_hexrays.number_format_t_opnum_set)
    props = _swig_property(_ida_hexrays.number_format_t_props_get, _ida_hexrays.number_format_t_props_set)
    serial = _swig_property(_ida_hexrays.number_format_t_serial_get, _ida_hexrays.number_format_t_serial_set)
    org_nbytes = _swig_property(_ida_hexrays.number_format_t_org_nbytes_get, _ida_hexrays.number_format_t_org_nbytes_set)
    type_name = _swig_property(_ida_hexrays.number_format_t_type_name_get, _ida_hexrays.number_format_t_type_name_set)
    def __init__(self, *args):
        """
        __init__(self, _opnum=0) -> number_format_t
        """
        this = _ida_hexrays.new_number_format_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_radix(self, *args):
        """
        get_radix(self) -> int
        """
        return _ida_hexrays.number_format_t_get_radix(self, *args)

    def is_fixed(self, *args):
        """
        is_fixed(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_fixed(self, *args)

    def is_hex(self, *args):
        """
        is_hex(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_hex(self, *args)

    def is_dec(self, *args):
        """
        is_dec(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_dec(self, *args)

    def is_oct(self, *args):
        """
        is_oct(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_oct(self, *args)

    def is_enum(self, *args):
        """
        is_enum(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_enum(self, *args)

    def is_char(self, *args):
        """
        is_char(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_char(self, *args)

    def is_stroff(self, *args):
        """
        is_stroff(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_stroff(self, *args)

    def is_numop(self, *args):
        """
        is_numop(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_numop(self, *args)

    def needs_to_be_inverted(self, *args):
        """
        needs_to_be_inverted(self) -> bool
        """
        return _ida_hexrays.number_format_t_needs_to_be_inverted(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_number_format_t
    __del__ = lambda self : None;
number_format_t_swigregister = _ida_hexrays.number_format_t_swigregister
number_format_t_swigregister(number_format_t)
NF_FIXED = _ida_hexrays.NF_FIXED
"""
number format has been defined by the user
"""
NF_NEGDONE = _ida_hexrays.NF_NEGDONE
"""
temporary internal bit: negation has been performed
"""
NF_BINVDONE = _ida_hexrays.NF_BINVDONE
"""
temporary internal bit: inverting bits is done
"""
NF_NEGATE = _ida_hexrays.NF_NEGATE
"""
The user asked to negate the constant.
"""
NF_BITNOT = _ida_hexrays.NF_BITNOT
"""
The user asked to invert bits of the constant.
"""
NF_STROFF = _ida_hexrays.NF_STROFF
"""
internal bit: used as stroff, valid iff 'is_stroff()'
"""

class vd_printer_t(object):
    """
    Proxy of C++ vd_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    tmpbuf = _swig_property(_ida_hexrays.vd_printer_t_tmpbuf_get, _ida_hexrays.vd_printer_t_tmpbuf_set)
    hdrlines = _swig_property(_ida_hexrays.vd_printer_t_hdrlines_get, _ida_hexrays.vd_printer_t_hdrlines_set)
    def _print(self, *args):
        """
        _print(self, indent, format) -> int
        """
        return _ida_hexrays.vd_printer_t__print(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> vd_printer_t
        """
        if self.__class__ == vd_printer_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_vd_printer_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vd_printer_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_vd_printer_t(self)
        return weakref_proxy(self)
vd_printer_t_swigregister = _ida_hexrays.vd_printer_t_swigregister
vd_printer_t_swigregister(vd_printer_t)

class vc_printer_t(vd_printer_t):
    """
    Proxy of C++ vc_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    func = _swig_property(_ida_hexrays.vc_printer_t_func_get, _ida_hexrays.vc_printer_t_func_set)
    lastchar = _swig_property(_ida_hexrays.vc_printer_t_lastchar_get, _ida_hexrays.vc_printer_t_lastchar_set)
    def __init__(self, *args):
        """
        __init__(self, f) -> vc_printer_t
        """
        if self.__class__ == vc_printer_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_vc_printer_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def oneliner(self, *args):
        """
        oneliner(self) -> bool
        """
        return _ida_hexrays.vc_printer_t_oneliner(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vc_printer_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_vc_printer_t(self)
        return weakref_proxy(self)
vc_printer_t_swigregister = _ida_hexrays.vc_printer_t_swigregister
vc_printer_t_swigregister(vc_printer_t)

class qstring_printer_t(vc_printer_t):
    """
    Proxy of C++ qstring_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    with_tags = _swig_property(_ida_hexrays.qstring_printer_t_with_tags_get, _ida_hexrays.qstring_printer_t_with_tags_set)
    s = _swig_property(_ida_hexrays.qstring_printer_t_s_get, _ida_hexrays.qstring_printer_t_s_set)
    def _print(self, *args):
        """
        _print(self, indent, format) -> int
        """
        return _ida_hexrays.qstring_printer_t__print(self, *args)

    def __init__(self, *args):
        """
        __init__(self, f, tags) -> qstring_printer_t
        """
        this = _ida_hexrays.new_qstring_printer_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_s(self, *args):
        """
        get_s(self) -> qstring
        """
        return _ida_hexrays.qstring_printer_t_get_s(self, *args)

    s = property(lambda self: self.get_s())

qstring_printer_t_swigregister = _ida_hexrays.qstring_printer_t_swigregister
qstring_printer_t_swigregister(qstring_printer_t)


def dstr(*args):
  """
  dstr(tif) -> char const *


  Print the specified type info. This function can be used from a
  debugger by typing "tif->dstr()"
  
  @param tif (C++: const  tinfo_t  *)
  """
  return _ida_hexrays.dstr(*args)

def is_type_correct(*args):
  """
  is_type_correct(ptr) -> bool


  Verify a type string.
  
  @param ptr (C++: const  type_t  *)
  @return: true if type string is correct
  """
  return _ida_hexrays.is_type_correct(*args)

def is_small_udt(*args):
  """
  is_small_udt(tif) -> bool


  Is a small structure or union?
  
  @param tif (C++: const  tinfo_t  &)
  @return: true if the type is a small UDT (user defined type). Small
           UDTs fit into a register (or pair or registers) as a rule.
  """
  return _ida_hexrays.is_small_udt(*args)

def is_nonbool_type(*args):
  """
  is_nonbool_type(type) -> bool


  Is definitely a non-boolean type?
  
  @param type (C++: const  tinfo_t  &)
  @return: true if the type is a non-boolean type (non bool and well
           defined)
  """
  return _ida_hexrays.is_nonbool_type(*args)

def is_bool_type(*args):
  """
  is_bool_type(type) -> bool


  Is a boolean type?
  
  @param type (C++: const  tinfo_t  &)
  @return: true if the type is a boolean type
  """
  return _ida_hexrays.is_bool_type(*args)

def is_ptr_or_array(*args):
  """
  is_ptr_or_array(t) -> bool


  Is a pointer or array type?
  
  
  @param t (C++: type_t)
  """
  return _ida_hexrays.is_ptr_or_array(*args)

def is_paf(*args):
  """
  is_paf(t) -> bool


  Is a pointer, array, or function type?
  
  
  @param t (C++: type_t)
  """
  return _ida_hexrays.is_paf(*args)

def is_inplace_def(*args):
  """
  is_inplace_def(type) -> bool


  Is struct/union/enum definition (not declaration)?
  
  
  @param type (C++: const  tinfo_t  &)
  """
  return _ida_hexrays.is_inplace_def(*args)

def partial_type_num(*args):
  """
  partial_type_num(type) -> int


  Calculate number of partial subtypes.
  
  @param type (C++: const  tinfo_t  &)
  @return: number of partial subtypes. The bigger is this number, the
           uglier is the type.
  """
  return _ida_hexrays.partial_type_num(*args)

def get_float_type(*args):
  """
  get_float_type(width) -> tinfo_t


  Get a type of a floating point value with the specified width
  
  @param width: width of the desired type (C++: int)
  @return: type info object
  """
  return _ida_hexrays.get_float_type(*args)

def get_int_type_by_width_and_sign(*args):
  """
  get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t


  Create a type info by width and sign. Returns a simple type (examples:
  int, short) with the given width and sign.
  
  @param srcwidth: size of the type in bytes (C++: int)
  @param sign: sign of the type (C++: type_sign_t)
  """
  return _ida_hexrays.get_int_type_by_width_and_sign(*args)

def get_unk_type(*args):
  """
  get_unk_type(size) -> tinfo_t


  Create a partial type info by width. Returns a partially defined type
  (examples: _DWORD, _BYTE) with the given width.
  
  @param size: size of the type in bytes (C++: int)
  """
  return _ida_hexrays.get_unk_type(*args)

def dummy_ptrtype(*args):
  """
  dummy_ptrtype(ptrsize, isfp) -> tinfo_t


  Generate a dummy pointer type
  
  @param ptrsize: size of pointed object (C++: int)
  @param isfp: is floating point object? (C++: bool)
  """
  return _ida_hexrays.dummy_ptrtype(*args)

def get_member_type(*args):
  """
  get_member_type(mptr, type) -> bool


  Get type of a structure field. This function performs validity checks
  of the field type. Wrong types are rejected.
  
  @param mptr: structure field (C++: const  member_t  *)
  @param type: pointer to the variable where the type is returned. This
               parameter can be NULL. (C++: tinfo_t  *)
  @return: false if failed
  """
  return _ida_hexrays.get_member_type(*args)

def make_pointer(*args):
  """
  make_pointer(type) -> tinfo_t


  Create a pointer type. This function performs the following
  conversion: "type" -> "type*"
  
  @param type: object type. (C++: const  tinfo_t  &)
  @return: "type*". for example, if 'char' is passed as the argument,
  """
  return _ida_hexrays.make_pointer(*args)

def create_typedef(*args):
  """
    create_typedef(name) -> tinfo_t
    create_typedef(n) -> tinfo_t


  Create a reference to a named type.
  
  @param name: type name (C++: const char *)
  @return: type which refers to the specified name. For example, if name
           is "DWORD", the type info which refers to "DWORD" is created.
    """
  return _ida_hexrays.create_typedef(*args)
GUESSED_NONE = _ida_hexrays.GUESSED_NONE
GUESSED_WEAK = _ida_hexrays.GUESSED_WEAK
GUESSED_FUNC = _ida_hexrays.GUESSED_FUNC
GUESSED_DATA = _ida_hexrays.GUESSED_DATA
TS_NOELL = _ida_hexrays.TS_NOELL
TS_SHRINK = _ida_hexrays.TS_SHRINK
TS_DONTREF = _ida_hexrays.TS_DONTREF
TS_MASK = _ida_hexrays.TS_MASK

def get_type(*args):
  """
  get_type(id, tif, guess) -> bool


  Get a global type. Global types are types of addressable objects and
  struct/union/enum types
  
  @param id: address or id of the object (C++: uval_t)
  @param tif: buffer for the answer (C++: tinfo_t  *)
  @param guess: what kind of types to consider (C++: type_source_t)
  @return: success
  """
  return _ida_hexrays.get_type(*args)

def set_type(*args):
  """
  set_type(id, tif, source, force=False) -> bool


  Set a global type.
  
  @param id: address or id of the object (C++: uval_t)
  @param tif: new type info (C++: const  tinfo_t  &)
  @param source: where the type comes from (C++: type_source_t)
  @param force: true means to set the type as is, false means to merge
                the new type with the possibly existing old type info.
                (C++: bool)
  @return: success
  """
  return _ida_hexrays.set_type(*args)
class vdloc_t(ida_typeinf.argloc_t):
    """
    Proxy of C++ vdloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def reg1(self, *args):
        """
        reg1(self) -> int
        """
        return _ida_hexrays.vdloc_t_reg1(self, *args)

    def _set_reg1(self, *args):
        """
        _set_reg1(self, r1)
        """
        return _ida_hexrays.vdloc_t__set_reg1(self, *args)

    def set_reg1(self, *args):
        """
        set_reg1(self, r1)
        """
        return _ida_hexrays.vdloc_t_set_reg1(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.vdloc_t_compare(self, *args)

    def is_aliasable(self, *args):
        """
        is_aliasable(self, mb, size) -> bool
        """
        return _ida_hexrays.vdloc_t_is_aliasable(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> vdloc_t
        """
        this = _ida_hexrays.new_vdloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vdloc_t
    __del__ = lambda self : None;
vdloc_t_swigregister = _ida_hexrays.vdloc_t_swigregister
vdloc_t_swigregister(vdloc_t)


def print_vdloc(*args):
  """
  print_vdloc(loc, nbytes)


  Print vdloc. Since vdloc does not always carry the size info, we pass
  it as NBYTES..
  
  @param loc (C++: const  vdloc_t  &)
  @param nbytes (C++: int)
  """
  return _ida_hexrays.print_vdloc(*args)

def arglocs_overlap(*args):
  """
  arglocs_overlap(loc1, w1, loc2, w2) -> bool


  Do two arglocs overlap?
  
  
  @param loc1 (C++: const  vdloc_t  &)
  @param w1 (C++: size_t)
  @param loc2 (C++: const  vdloc_t  &)
  @param w2 (C++: size_t)
  """
  return _ida_hexrays.arglocs_overlap(*args)
class lvar_locator_t(object):
    """
    Proxy of C++ lvar_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    location = _swig_property(_ida_hexrays.lvar_locator_t_location_get, _ida_hexrays.lvar_locator_t_location_set)
    defea = _swig_property(_ida_hexrays.lvar_locator_t_defea_get, _ida_hexrays.lvar_locator_t_defea_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_locator_t
        __init__(self, loc, ea) -> lvar_locator_t
        """
        this = _ida_hexrays.new_lvar_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_stkoff(self, *args):
        """
        get_stkoff(self) -> sval_t
        """
        return _ida_hexrays.lvar_locator_t_get_stkoff(self, *args)

    def is_reg1(self, *args):
        """
        is_reg1(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg1(self, *args)

    def is_reg2(self, *args):
        """
        is_reg2(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg2(self, *args)

    def is_reg_var(self, *args):
        """
        is_reg_var(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg_var(self, *args)

    def is_stk_var(self, *args):
        """
        is_stk_var(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_stk_var(self, *args)

    def is_scattered(self, *args):
        """
        is_scattered(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_scattered(self, *args)

    def get_reg1(self, *args):
        """
        get_reg1(self) -> mreg_t
        """
        return _ida_hexrays.lvar_locator_t_get_reg1(self, *args)

    def get_reg2(self, *args):
        """
        get_reg2(self) -> mreg_t
        """
        return _ida_hexrays.lvar_locator_t_get_reg2(self, *args)

    def get_scattered(self, *args):
        """
        get_scattered(self) -> scattered_aloc_t
        get_scattered(self) -> scattered_aloc_t
        """
        return _ida_hexrays.lvar_locator_t_get_scattered(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.lvar_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_locator_t
    __del__ = lambda self : None;
lvar_locator_t_swigregister = _ida_hexrays.lvar_locator_t_swigregister
lvar_locator_t_swigregister(lvar_locator_t)

class lvar_t(lvar_locator_t):
    """
    Proxy of C++ lvar_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    name = _swig_property(_ida_hexrays.lvar_t_name_get, _ida_hexrays.lvar_t_name_set)
    cmt = _swig_property(_ida_hexrays.lvar_t_cmt_get, _ida_hexrays.lvar_t_cmt_set)
    tif = _swig_property(_ida_hexrays.lvar_t_tif_get, _ida_hexrays.lvar_t_tif_set)
    width = _swig_property(_ida_hexrays.lvar_t_width_get, _ida_hexrays.lvar_t_width_set)
    defblk = _swig_property(_ida_hexrays.lvar_t_defblk_get, _ida_hexrays.lvar_t_defblk_set)
    divisor = _swig_property(_ida_hexrays.lvar_t_divisor_get, _ida_hexrays.lvar_t_divisor_set)
    def used(self, *args):
        """
        used(self) -> bool
        """
        return _ida_hexrays.lvar_t_used(self, *args)

    def typed(self, *args):
        """
        typed(self) -> bool
        """
        return _ida_hexrays.lvar_t_typed(self, *args)

    def mreg_done(self, *args):
        """
        mreg_done(self) -> bool
        """
        return _ida_hexrays.lvar_t_mreg_done(self, *args)

    def has_nice_name(self, *args):
        """
        has_nice_name(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_nice_name(self, *args)

    def is_unknown_width(self, *args):
        """
        is_unknown_width(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_unknown_width(self, *args)

    def has_user_info(self, *args):
        """
        has_user_info(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_info(self, *args)

    def has_user_name(self, *args):
        """
        has_user_name(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_name(self, *args)

    def has_user_type(self, *args):
        """
        has_user_type(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_type(self, *args)

    def is_result_var(self, *args):
        """
        is_result_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_result_var(self, *args)

    def is_arg_var(self, *args):
        """
        is_arg_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_arg_var(self, *args)

    def is_fake_var(self, *args):
        """
        is_fake_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_fake_var(self, *args)

    def is_overlapped_var(self, *args):
        """
        is_overlapped_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_overlapped_var(self, *args)

    def is_floating_var(self, *args):
        """
        is_floating_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_floating_var(self, *args)

    def is_spoiled_var(self, *args):
        """
        is_spoiled_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_spoiled_var(self, *args)

    def is_noptr_var(self, *args):
        """
        is_noptr_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_noptr_var(self, *args)

    def is_mapdst_var(self, *args):
        """
        is_mapdst_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_mapdst_var(self, *args)

    def is_thisarg(self, *args):
        """
        is_thisarg(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_thisarg(self, *args)

    def is_forced_var(self, *args):
        """
        is_forced_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_forced_var(self, *args)

    def has_regname(self, *args):
        """
        has_regname(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_regname(self, *args)

    def is_dummy_arg(self, *args):
        """
        is_dummy_arg(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_dummy_arg(self, *args)

    def is_notarg(self, *args):
        """
        is_notarg(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_notarg(self, *args)

    def set_used(self, *args):
        """
        set_used(self)
        """
        return _ida_hexrays.lvar_t_set_used(self, *args)

    def clear_used(self, *args):
        """
        clear_used(self)
        """
        return _ida_hexrays.lvar_t_clear_used(self, *args)

    def set_typed(self, *args):
        """
        set_typed(self)
        """
        return _ida_hexrays.lvar_t_set_typed(self, *args)

    def set_non_typed(self, *args):
        """
        set_non_typed(self)
        """
        return _ida_hexrays.lvar_t_set_non_typed(self, *args)

    def clr_user_info(self, *args):
        """
        clr_user_info(self)
        """
        return _ida_hexrays.lvar_t_clr_user_info(self, *args)

    def set_user_name(self, *args):
        """
        set_user_name(self)
        """
        return _ida_hexrays.lvar_t_set_user_name(self, *args)

    def set_user_type(self, *args):
        """
        set_user_type(self)
        """
        return _ida_hexrays.lvar_t_set_user_type(self, *args)

    def clr_user_type(self, *args):
        """
        clr_user_type(self)
        """
        return _ida_hexrays.lvar_t_clr_user_type(self, *args)

    def clr_user_name(self, *args):
        """
        clr_user_name(self)
        """
        return _ida_hexrays.lvar_t_clr_user_name(self, *args)

    def set_mreg_done(self, *args):
        """
        set_mreg_done(self)
        """
        return _ida_hexrays.lvar_t_set_mreg_done(self, *args)

    def clr_mreg_done(self, *args):
        """
        clr_mreg_done(self)
        """
        return _ida_hexrays.lvar_t_clr_mreg_done(self, *args)

    def set_unknown_width(self, *args):
        """
        set_unknown_width(self)
        """
        return _ida_hexrays.lvar_t_set_unknown_width(self, *args)

    def clr_unknown_width(self, *args):
        """
        clr_unknown_width(self)
        """
        return _ida_hexrays.lvar_t_clr_unknown_width(self, *args)

    def set_arg_var(self, *args):
        """
        set_arg_var(self)
        """
        return _ida_hexrays.lvar_t_set_arg_var(self, *args)

    def clr_arg_var(self, *args):
        """
        clr_arg_var(self)
        """
        return _ida_hexrays.lvar_t_clr_arg_var(self, *args)

    def set_fake_var(self, *args):
        """
        set_fake_var(self)
        """
        return _ida_hexrays.lvar_t_set_fake_var(self, *args)

    def clr_fake_var(self, *args):
        """
        clr_fake_var(self)
        """
        return _ida_hexrays.lvar_t_clr_fake_var(self, *args)

    def set_overlapped_var(self, *args):
        """
        set_overlapped_var(self)
        """
        return _ida_hexrays.lvar_t_set_overlapped_var(self, *args)

    def clr_overlapped_var(self, *args):
        """
        clr_overlapped_var(self)
        """
        return _ida_hexrays.lvar_t_clr_overlapped_var(self, *args)

    def set_floating_var(self, *args):
        """
        set_floating_var(self)
        """
        return _ida_hexrays.lvar_t_set_floating_var(self, *args)

    def clr_floating_var(self, *args):
        """
        clr_floating_var(self)
        """
        return _ida_hexrays.lvar_t_clr_floating_var(self, *args)

    def set_spoiled_var(self, *args):
        """
        set_spoiled_var(self)
        """
        return _ida_hexrays.lvar_t_set_spoiled_var(self, *args)

    def clr_spoiled_var(self, *args):
        """
        clr_spoiled_var(self)
        """
        return _ida_hexrays.lvar_t_clr_spoiled_var(self, *args)

    def set_mapdst_var(self, *args):
        """
        set_mapdst_var(self)
        """
        return _ida_hexrays.lvar_t_set_mapdst_var(self, *args)

    def clr_mapdst_var(self, *args):
        """
        clr_mapdst_var(self)
        """
        return _ida_hexrays.lvar_t_clr_mapdst_var(self, *args)

    def set_noptr_var(self, *args):
        """
        set_noptr_var(self)
        """
        return _ida_hexrays.lvar_t_set_noptr_var(self, *args)

    def clr_noptr_var(self, *args):
        """
        clr_noptr_var(self)
        """
        return _ida_hexrays.lvar_t_clr_noptr_var(self, *args)

    def set_thisarg(self, *args):
        """
        set_thisarg(self)
        """
        return _ida_hexrays.lvar_t_set_thisarg(self, *args)

    def clr_thisarg(self, *args):
        """
        clr_thisarg(self)
        """
        return _ida_hexrays.lvar_t_clr_thisarg(self, *args)

    def set_forced_var(self, *args):
        """
        set_forced_var(self)
        """
        return _ida_hexrays.lvar_t_set_forced_var(self, *args)

    def clr_forced_var(self, *args):
        """
        clr_forced_var(self)
        """
        return _ida_hexrays.lvar_t_clr_forced_var(self, *args)

    def set_dummy_arg(self, *args):
        """
        set_dummy_arg(self)
        """
        return _ida_hexrays.lvar_t_set_dummy_arg(self, *args)

    def clr_dummy_arg(self, *args):
        """
        clr_dummy_arg(self)
        """
        return _ida_hexrays.lvar_t_clr_dummy_arg(self, *args)

    def set_notarg(self, *args):
        """
        set_notarg(self)
        """
        return _ida_hexrays.lvar_t_set_notarg(self, *args)

    def clr_notarg(self, *args):
        """
        clr_notarg(self)
        """
        return _ida_hexrays.lvar_t_clr_notarg(self, *args)

    def has_common(self, *args):
        """
        has_common(self, v) -> bool
        """
        return _ida_hexrays.lvar_t_has_common(self, *args)

    def has_common_bit(self, *args):
        """
        has_common_bit(self, loc, width2) -> bool
        """
        return _ida_hexrays.lvar_t_has_common_bit(self, *args)

    def type(self, *args):
        """
        type(self) -> tinfo_t
        type(self) -> tinfo_t
        """
        return _ida_hexrays.lvar_t_type(self, *args)

    def accepts_type(self, *args):
        """
        accepts_type(self, t, may_change_thisarg=False) -> bool
        """
        return _ida_hexrays.lvar_t_accepts_type(self, *args)

    def set_lvar_type(self, *args):
        """
        set_lvar_type(self, t, may_fail=False) -> bool
        """
        return _ida_hexrays.lvar_t_set_lvar_type(self, *args)

    def set_final_lvar_type(self, *args):
        """
        set_final_lvar_type(self, t)
        """
        return _ida_hexrays.lvar_t_set_final_lvar_type(self, *args)

    def set_width(self, *args):
        """
        set_width(self, w, svw_flags=0) -> bool
        """
        return _ida_hexrays.lvar_t_set_width(self, *args)

    def append_list(self, *args):
        """
        append_list(self, lst, pad_if_scattered=False)
        """
        return _ida_hexrays.lvar_t_append_list(self, *args)

    def is_aliasable(self, *args):
        """
        is_aliasable(self, mba) -> bool
        """
        return _ida_hexrays.lvar_t_is_aliasable(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_t
    __del__ = lambda self : None;
lvar_t_swigregister = _ida_hexrays.lvar_t_swigregister
lvar_t_swigregister(lvar_t)
SVW_INT = _ida_hexrays.SVW_INT
SVW_FLOAT = _ida_hexrays.SVW_FLOAT
SVW_SOFT = _ida_hexrays.SVW_SOFT

class lvars_t(qvector_lvar_t):
    """
    Proxy of C++ lvars_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def find_input_lvar(self, *args):
        """
        find_input_lvar(self, argloc, _size) -> int
        """
        return _ida_hexrays.lvars_t_find_input_lvar(self, *args)

    def find_stkvar(self, *args):
        """
        find_stkvar(self, spoff, width) -> int
        """
        return _ida_hexrays.lvars_t_find_stkvar(self, *args)

    def find(self, *args):
        """
        find(self, ll) -> lvar_t
        """
        return _ida_hexrays.lvars_t_find(self, *args)

    def find_lvar(self, *args):
        """
        find_lvar(self, location, width, defblk=-1) -> int
        """
        return _ida_hexrays.lvars_t_find_lvar(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvars_t
        """
        this = _ida_hexrays.new_lvars_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvars_t
    __del__ = lambda self : None;
lvars_t_swigregister = _ida_hexrays.lvars_t_swigregister
lvars_t_swigregister(lvars_t)

class lvar_saved_info_t(object):
    """
    Proxy of C++ lvar_saved_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ll = _swig_property(_ida_hexrays.lvar_saved_info_t_ll_get, _ida_hexrays.lvar_saved_info_t_ll_set)
    name = _swig_property(_ida_hexrays.lvar_saved_info_t_name_get, _ida_hexrays.lvar_saved_info_t_name_set)
    type = _swig_property(_ida_hexrays.lvar_saved_info_t_type_get, _ida_hexrays.lvar_saved_info_t_type_set)
    cmt = _swig_property(_ida_hexrays.lvar_saved_info_t_cmt_get, _ida_hexrays.lvar_saved_info_t_cmt_set)
    size = _swig_property(_ida_hexrays.lvar_saved_info_t_size_get, _ida_hexrays.lvar_saved_info_t_size_set)
    flags = _swig_property(_ida_hexrays.lvar_saved_info_t_flags_get, _ida_hexrays.lvar_saved_info_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_saved_info_t
        """
        this = _ida_hexrays.new_lvar_saved_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def has_info(self, *args):
        """
        has_info(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_has_info(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t___ne__(self, *args)

    def is_kept(self, *args):
        """
        is_kept(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_kept(self, *args)

    def clear_keep(self, *args):
        """
        clear_keep(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clear_keep(self, *args)

    def set_keep(self, *args):
        """
        set_keep(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_keep(self, *args)

    def is_forced_lvar(self, *args):
        """
        is_forced_lvar(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_forced_lvar(self, *args)

    def set_forced_lvar(self, *args):
        """
        set_forced_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_forced_lvar(self, *args)

    def clr_forced_lvar(self, *args):
        """
        clr_forced_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clr_forced_lvar(self, *args)

    def is_noptr_lvar(self, *args):
        """
        is_noptr_lvar(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_noptr_lvar(self, *args)

    def set_noptr_lvar(self, *args):
        """
        set_noptr_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_noptr_lvar(self, *args)

    def clr_noptr_lvar(self, *args):
        """
        clr_noptr_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clr_noptr_lvar(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_saved_info_t
    __del__ = lambda self : None;
lvar_saved_info_t_swigregister = _ida_hexrays.lvar_saved_info_t_swigregister
lvar_saved_info_t_swigregister(lvar_saved_info_t)
LVINF_KEEP = _ida_hexrays.LVINF_KEEP
"""
preserve saved user settings regardless of vars for example, if a var
loses all its user-defined attributes or even gets destroyed, keep its
'lvar_saved_info_t' . this is used for ephemeral variables that get
destroyed by macro recognition.
"""
LVINF_FORCE = _ida_hexrays.LVINF_FORCE
"""
force allocation of a new variable. forces the decompiler to create a
new variable at ll.defea
"""
LVINF_NOPTR = _ida_hexrays.LVINF_NOPTR
"""
variable type should not be a pointer
"""

class lvar_uservec_t(object):
    """
    Proxy of C++ lvar_uservec_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lvvec = _swig_property(_ida_hexrays.lvar_uservec_t_lvvec_get, _ida_hexrays.lvar_uservec_t_lvvec_set)
    lmaps = _swig_property(_ida_hexrays.lvar_uservec_t_lmaps_get, _ida_hexrays.lvar_uservec_t_lmaps_set)
    stkoff_delta = _swig_property(_ida_hexrays.lvar_uservec_t_stkoff_delta_get, _ida_hexrays.lvar_uservec_t_stkoff_delta_set)
    ulv_flags = _swig_property(_ida_hexrays.lvar_uservec_t_ulv_flags_get, _ida_hexrays.lvar_uservec_t_ulv_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_uservec_t
        """
        this = _ida_hexrays.new_lvar_uservec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.lvar_uservec_t_swap(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.lvar_uservec_t_clear(self, *args)

    def find_info(self, *args):
        """
        find_info(self, vloc) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_uservec_t_find_info(self, *args)

    def keep_info(self, *args):
        """
        keep_info(self, v)
        """
        return _ida_hexrays.lvar_uservec_t_keep_info(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_uservec_t
    __del__ = lambda self : None;
lvar_uservec_t_swigregister = _ida_hexrays.lvar_uservec_t_swigregister
lvar_uservec_t_swigregister(lvar_uservec_t)
ULV_PRECISE_DEFEA = _ida_hexrays.ULV_PRECISE_DEFEA
"""
Use precise defea's for lvar locations.
"""


def restore_user_lvar_settings(*args):
  """
  restore_user_lvar_settings(lvinf, func_ea) -> bool


  Restore user defined local variable settings in the database.
  
  @param lvinf: ptr to output buffer (C++: lvar_uservec_t  *)
  @param func_ea: entry address of the function (C++: ea_t)
  @return: success
  """
  return _ida_hexrays.restore_user_lvar_settings(*args)

def save_user_lvar_settings(*args):
  """
  save_user_lvar_settings(func_ea, lvinf)


  Save user defined local variable settings into the database.
  
  @param func_ea: entry address of the function (C++: ea_t)
  @param lvinf: user-specified info about local variables (C++: const
                lvar_uservec_t  &)
  """
  return _ida_hexrays.save_user_lvar_settings(*args)
class user_lvar_modifier_t(object):
    """
    Proxy of C++ user_lvar_modifier_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def modify_lvars(self, *args):
        """
        modify_lvars(self, lvinf) -> bool
        """
        return _ida_hexrays.user_lvar_modifier_t_modify_lvars(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_lvar_modifier_t
        """
        if self.__class__ == user_lvar_modifier_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_user_lvar_modifier_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_lvar_modifier_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_user_lvar_modifier_t(self)
        return weakref_proxy(self)
user_lvar_modifier_t_swigregister = _ida_hexrays.user_lvar_modifier_t_swigregister
user_lvar_modifier_t_swigregister(user_lvar_modifier_t)


def modify_user_lvars(*args):
  """
  modify_user_lvars(entry_ea, mlv) -> bool


  Modify saved local variable settings.
  
  @param entry_ea: function start address (C++: ea_t)
  @param mlv: local variable modifier (C++: user_lvar_modifier_t  &)
  @return: true if modified variables
  """
  return _ida_hexrays.modify_user_lvars(*args)
class udcall_t(object):
    """
    Proxy of C++ udcall_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_hexrays.udcall_t_name_get, _ida_hexrays.udcall_t_name_set)
    tif = _swig_property(_ida_hexrays.udcall_t_tif_get, _ida_hexrays.udcall_t_tif_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.udcall_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.udcall_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> udcall_t
        """
        this = _ida_hexrays.new_udcall_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udcall_t
    __del__ = lambda self : None;
udcall_t_swigregister = _ida_hexrays.udcall_t_swigregister
udcall_t_swigregister(udcall_t)


def restore_user_defined_calls(*args):
  """
  restore_user_defined_calls(udcalls, func_ea) -> bool


  Restore user defined function calls from the database.
  
  @param udcalls: ptr to output buffer (C++: udcall_map_t *)
  @param func_ea: entry address of the function (C++: ea_t)
  @return: success
  """
  return _ida_hexrays.restore_user_defined_calls(*args)

def save_user_defined_calls(*args):
  """
  save_user_defined_calls(func_ea, udcalls)


  Save user defined local function calls into the database.
  
  @param func_ea: entry address of the function (C++: ea_t)
  @param udcalls: user-specified info about user defined function calls
                  (C++: const udcall_map_t &)
  """
  return _ida_hexrays.save_user_defined_calls(*args)

def parse_user_call(*args):
  """
  parse_user_call(udc, decl, silent) -> bool


  Convert function type declaration into internal structure
  
  @param udc: - pointer to output structure (C++: udcall_t  *)
  @param decl: - function type declaration (C++: const char *)
  @param silent: - if TRUE: do not show warning in case of incorrect
                 type (C++: bool)
  @return: success
  """
  return _ida_hexrays.parse_user_call(*args)

def convert_to_user_call(*args):
  """
  convert_to_user_call(udc, cdg) -> merror_t


  try to generate user-defined call for an instruction
  
  @param udc (C++: const  udcall_t  &)
  @param cdg (C++: codegen_t  &)
  @return: Microcode error codes  code: MERR_OK - user-defined call
           generated else - error (MERR_INSN == inacceptable udc.tif)
  """
  return _ida_hexrays.convert_to_user_call(*args)
class microcode_filter_t(object):
    """
    Proxy of C++ microcode_filter_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def match(self, *args):
        """
        match(self, cdg) -> bool
        """
        return _ida_hexrays.microcode_filter_t_match(self, *args)

    def apply(self, *args):
        """
        apply(self, cdg) -> merror_t
        """
        return _ida_hexrays.microcode_filter_t_apply(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> microcode_filter_t
        """
        if self.__class__ == microcode_filter_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_microcode_filter_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_microcode_filter_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_microcode_filter_t(self)
        return weakref_proxy(self)
microcode_filter_t_swigregister = _ida_hexrays.microcode_filter_t_swigregister
microcode_filter_t_swigregister(microcode_filter_t)


def install_microcode_filter(*args):
  """
  install_microcode_filter(filter, install=True)


  register/unregister non-standard microcode generator
  
  @param filter: - microcode generator object (C++: microcode_filter_t
                 *)
  @param install: - TRUE - register the object, FALSE - unregister (C++:
                  bool)
  """
  return _ida_hexrays.install_microcode_filter(*args)
class udc_filter_t(microcode_filter_t):
    """
    Proxy of C++ udc_filter_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def match(self, *args):
        """
        match(self, cdg) -> bool
        """
        return _ida_hexrays.udc_filter_t_match(self, *args)

    def init(self, *args):
        """
        init(self, decl) -> bool
        """
        return _ida_hexrays.udc_filter_t_init(self, *args)

    def apply(self, *args):
        """
        apply(self, cdg) -> merror_t
        """
        return _ida_hexrays.udc_filter_t_apply(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> udc_filter_t
        """
        if self.__class__ == udc_filter_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_udc_filter_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udc_filter_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_udc_filter_t(self)
        return weakref_proxy(self)
udc_filter_t_swigregister = _ida_hexrays.udc_filter_t_swigregister
udc_filter_t_swigregister(udc_filter_t)

class bitset_t(object):
    """
    Proxy of C++ bitset_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> bitset_t
        __init__(self, m) -> bitset_t
        """
        this = _ida_hexrays.new_bitset_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_bitset_t
    __del__ = lambda self : None;
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.bitset_t_swap(self, *args)

    def copy(self, *args):
        """
        copy(self, m) -> bitset_t
        """
        return _ida_hexrays.bitset_t_copy(self, *args)

    def add(self, *args):
        """
        add(self, bit) -> bool
        add(self, bit, width) -> bool
        add(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_add(self, *args)

    def sub(self, *args):
        """
        sub(self, bit) -> bool
        sub(self, bit, width) -> bool
        sub(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_sub(self, *args)

    def cut_at(self, *args):
        """
        cut_at(self, maxbit) -> bool
        """
        return _ida_hexrays.bitset_t_cut_at(self, *args)

    def shift_down(self, *args):
        """
        shift_down(self, shift)
        """
        return _ida_hexrays.bitset_t_shift_down(self, *args)

    def has(self, *args):
        """
        has(self, bit) -> bool
        """
        return _ida_hexrays.bitset_t_has(self, *args)

    def has_all(self, *args):
        """
        has_all(self, bit, width) -> bool
        """
        return _ida_hexrays.bitset_t_has_all(self, *args)

    def has_any(self, *args):
        """
        has_any(self, bit, width) -> bool
        """
        return _ida_hexrays.bitset_t_has_any(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.bitset_t_dstr(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.bitset_t_empty(self, *args)

    def count(self, *args):
        """
        count(self) -> int
        count(self, bit) -> int
        """
        return _ida_hexrays.bitset_t_count(self, *args)

    def last(self, *args):
        """
        last(self) -> int
        """
        return _ida_hexrays.bitset_t_last(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.bitset_t_clear(self, *args)

    def fill_with_ones(self, *args):
        """
        fill_with_ones(self, maxbit)
        """
        return _ida_hexrays.bitset_t_fill_with_ones(self, *args)

    def has_common(self, *args):
        """
        has_common(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_has_common(self, *args)

    def intersect(self, *args):
        """
        intersect(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_intersect(self, *args)

    def is_subset_of(self, *args):
        """
        is_subset_of(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_is_subset_of(self, *args)

    def includes(self, *args):
        """
        includes(self, ml) -> bool
        """
        return _ida_hexrays.bitset_t_includes(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.bitset_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.bitset_t_compare(self, *args)

    def itat(self, *args):
        """
        itat(self, n) -> bitset_t::iterator
        """
        return _ida_hexrays.bitset_t_itat(self, *args)

    def begin(self, *args):
        """
        begin(self) -> bitset_t::iterator
        """
        return _ida_hexrays.bitset_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> bitset_t::iterator
        """
        return _ida_hexrays.bitset_t_end(self, *args)

    def front(self, *args):
        """
        front(self) -> int
        """
        return _ida_hexrays.bitset_t_front(self, *args)

    def back(self, *args):
        """
        back(self) -> int
        """
        return _ida_hexrays.bitset_t_back(self, *args)

    def inc(self, *args):
        """
        inc(self, p, n=1)
        """
        return _ida_hexrays.bitset_t_inc(self, *args)

    def itv(self, *args):
        """
        itv(self, it) -> int
        """
        return _ida_hexrays.bitset_t_itv(self, *args)

    __len__ = count
    def __iter__(self):
        it = self.begin()
        for i in xrange(self.count()):
            yield self.itv(it)
            self.inc(it)

bitset_t_swigregister = _ida_hexrays.bitset_t_swigregister
bitset_t_swigregister(bitset_t)
bitset_width = cvar.bitset_width
bitset_align = cvar.bitset_align
bitset_shift = cvar.bitset_shift

class ivl_t(uval_ivl_t):
    """
    Proxy of C++ ivl_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _off, _size) -> ivl_t
        """
        this = _ida_hexrays.new_ivl_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.ivl_t_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.ivl_t_clear(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.ivl_t_dstr(self, *args)

    def extend_to_cover(self, *args):
        """
        extend_to_cover(self, r) -> bool
        """
        return _ida_hexrays.ivl_t_extend_to_cover(self, *args)

    def intersect(self, *args):
        """
        intersect(self, r)
        """
        return _ida_hexrays.ivl_t_intersect(self, *args)

    def overlap(self, *args):
        """
        overlap(self, ivl) -> bool
        """
        return _ida_hexrays.ivl_t_overlap(self, *args)

    def includes(self, *args):
        """
        includes(self, ivl) -> bool
        """
        return _ida_hexrays.ivl_t_includes(self, *args)

    def contains(self, *args):
        """
        contains(self, off2) -> bool
        """
        return _ida_hexrays.ivl_t_contains(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ivl_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ivl_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ivl_t
    __del__ = lambda self : None;
ivl_t_swigregister = _ida_hexrays.ivl_t_swigregister
ivl_t_swigregister(ivl_t)

class ivl_with_name_t(object):
    """
    Proxy of C++ ivl_with_name_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ivl = _swig_property(_ida_hexrays.ivl_with_name_t_ivl_get, _ida_hexrays.ivl_with_name_t_ivl_set)
    whole = _swig_property(_ida_hexrays.ivl_with_name_t_whole_get, _ida_hexrays.ivl_with_name_t_whole_set)
    part = _swig_property(_ida_hexrays.ivl_with_name_t_part_get, _ida_hexrays.ivl_with_name_t_part_set)
    def __init__(self, *args):
        """
        __init__(self) -> ivl_with_name_t
        """
        this = _ida_hexrays.new_ivl_with_name_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ivl_with_name_t
    __del__ = lambda self : None;
ivl_with_name_t_swigregister = _ida_hexrays.ivl_with_name_t_swigregister
ivl_with_name_t_swigregister(ivl_with_name_t)

class ivlset_t(uval_ivl_ivlset_t):
    """
    Proxy of C++ ivlset_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> ivlset_t
        __init__(self, ivl) -> ivlset_t
        """
        this = _ida_hexrays.new_ivlset_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args):
        """
        add(self, ivl) -> bool
        add(self, ea, size) -> bool
        add(self, ivs) -> bool
        """
        return _ida_hexrays.ivlset_t_add(self, *args)

    def addmasked(self, *args):
        """
        addmasked(self, ivs, mask) -> bool
        """
        return _ida_hexrays.ivlset_t_addmasked(self, *args)

    def sub(self, *args):
        """
        sub(self, ivl) -> bool
        sub(self, ea, size) -> bool
        sub(self, ivs) -> bool
        """
        return _ida_hexrays.ivlset_t_sub(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.ivlset_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.ivlset_t_dstr(self, *args)

    def count(self, *args):
        """
        count(self) -> asize_t
        """
        return _ida_hexrays.ivlset_t_count(self, *args)

    def has_common(self, *args):
        """
        has_common(self, ivl, strict=False) -> bool
        has_common(self, ivs) -> bool
        """
        return _ida_hexrays.ivlset_t_has_common(self, *args)

    def contains(self, *args):
        """
        contains(self, off) -> bool
        """
        return _ida_hexrays.ivlset_t_contains(self, *args)

    def includes(self, *args):
        """
        includes(self, ivs) -> bool
        """
        return _ida_hexrays.ivlset_t_includes(self, *args)

    def intersect(self, *args):
        """
        intersect(self, ivs) -> bool
        """
        return _ida_hexrays.ivlset_t_intersect(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ivlset_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ivlset_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ivlset_t
    __del__ = lambda self : None;
ivlset_t_swigregister = _ida_hexrays.ivlset_t_swigregister
ivlset_t_swigregister(ivlset_t)


def get_mreg_name(*args):
  """
  get_mreg_name(bit, width, ud=None) -> int
  """
  return _ida_hexrays.get_mreg_name(*args)
class rlist_t(bitset_t):
    """
    Proxy of C++ rlist_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> rlist_t
        __init__(self, m) -> rlist_t
        __init__(self, reg, width) -> rlist_t
        """
        this = _ida_hexrays.new_rlist_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_rlist_t
    __del__ = lambda self : None;
    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.rlist_t_dstr(self, *args)

rlist_t_swigregister = _ida_hexrays.rlist_t_swigregister
rlist_t_swigregister(rlist_t)

class mlist_t(object):
    """
    Proxy of C++ mlist_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    reg = _swig_property(_ida_hexrays.mlist_t_reg_get, _ida_hexrays.mlist_t_reg_set)
    mem = _swig_property(_ida_hexrays.mlist_t_mem_get, _ida_hexrays.mlist_t_mem_set)
    def __init__(self, *args):
        """
        __init__(self) -> mlist_t
        __init__(self, ivl) -> mlist_t
        __init__(self, r, size) -> mlist_t
        """
        this = _ida_hexrays.new_mlist_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.mlist_t_swap(self, *args)

    def addmem(self, *args):
        """
        addmem(self, ea, size) -> bool
        """
        return _ida_hexrays.mlist_t_addmem(self, *args)

    def add(self, *args):
        """
        add(self, r, size) -> bool
        add(self, r) -> bool
        add(self, ivl) -> bool
        add(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_add(self, *args)

    def sub(self, *args):
        """
        sub(self, r, size) -> bool
        sub(self, ivl) -> bool
        sub(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_sub(self, *args)

    def count(self, *args):
        """
        count(self) -> asize_t
        """
        return _ida_hexrays.mlist_t_count(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.mlist_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.mlist_t_dstr(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mlist_t_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.mlist_t_clear(self, *args)

    def has(self, *args):
        """
        has(self, r) -> bool
        """
        return _ida_hexrays.mlist_t_has(self, *args)

    def has_all(self, *args):
        """
        has_all(self, r, size) -> bool
        """
        return _ida_hexrays.mlist_t_has_all(self, *args)

    def has_any(self, *args):
        """
        has_any(self, r, size) -> bool
        """
        return _ida_hexrays.mlist_t_has_any(self, *args)

    def has_memory(self, *args):
        """
        has_memory(self) -> bool
        """
        return _ida_hexrays.mlist_t_has_memory(self, *args)

    def has_common(self, *args):
        """
        has_common(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_has_common(self, *args)

    def includes(self, *args):
        """
        includes(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_includes(self, *args)

    def intersect(self, *args):
        """
        intersect(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_intersect(self, *args)

    def is_subset_of(self, *args):
        """
        is_subset_of(self, lst) -> bool
        """
        return _ida_hexrays.mlist_t_is_subset_of(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.mlist_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.mlist_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mlist_t
    __del__ = lambda self : None;
mlist_t_swigregister = _ida_hexrays.mlist_t_swigregister
mlist_t_swigregister(mlist_t)

class simple_graph_t(object):
    """
    Proxy of C++ simple_graph_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    title = _swig_property(_ida_hexrays.simple_graph_t_title_get, _ida_hexrays.simple_graph_t_title_set)
    colored_gdl_edges = _swig_property(_ida_hexrays.simple_graph_t_colored_gdl_edges_get, _ida_hexrays.simple_graph_t_colored_gdl_edges_set)
simple_graph_t_swigregister = _ida_hexrays.simple_graph_t_swigregister
simple_graph_t_swigregister(simple_graph_t)

class op_parent_info_t(object):
    """
    Proxy of C++ op_parent_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.op_parent_info_t_mba_get, _ida_hexrays.op_parent_info_t_mba_set)
    blk = _swig_property(_ida_hexrays.op_parent_info_t_blk_get, _ida_hexrays.op_parent_info_t_blk_set)
    topins = _swig_property(_ida_hexrays.op_parent_info_t_topins_get, _ida_hexrays.op_parent_info_t_topins_set)
    curins = _swig_property(_ida_hexrays.op_parent_info_t_curins_get, _ida_hexrays.op_parent_info_t_curins_set)
    def __init__(self, *args):
        """
        __init__(self, _mba=None, _blk=None, _topins=None) -> op_parent_info_t
        """
        this = _ida_hexrays.new_op_parent_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_op_parent_info_t
    __del__ = lambda self : None;
op_parent_info_t_swigregister = _ida_hexrays.op_parent_info_t_swigregister
op_parent_info_t_swigregister(op_parent_info_t)

class minsn_visitor_t(op_parent_info_t):
    """
    Proxy of C++ minsn_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _mba=None, _blk=None, _topins=None) -> minsn_visitor_t
        """
        if self.__class__ == minsn_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_minsn_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def visit_minsn(self, *args):
        """
        visit_minsn(self) -> int
        """
        return _ida_hexrays.minsn_visitor_t_visit_minsn(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_minsn_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_minsn_visitor_t(self)
        return weakref_proxy(self)
minsn_visitor_t_swigregister = _ida_hexrays.minsn_visitor_t_swigregister
minsn_visitor_t_swigregister(minsn_visitor_t)

class mop_visitor_t(op_parent_info_t):
    """
    Proxy of C++ mop_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _mba=None, _blk=None, _topins=None) -> mop_visitor_t
        """
        if self.__class__ == mop_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_mop_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    prune = _swig_property(_ida_hexrays.mop_visitor_t_prune_get, _ida_hexrays.mop_visitor_t_prune_set)
    def visit_mop(self, *args):
        """
        visit_mop(self, op, type, is_target) -> int
        """
        return _ida_hexrays.mop_visitor_t_visit_mop(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mop_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_mop_visitor_t(self)
        return weakref_proxy(self)
mop_visitor_t_swigregister = _ida_hexrays.mop_visitor_t_swigregister
mop_visitor_t_swigregister(mop_visitor_t)

class scif_visitor_t(object):
    """
    Proxy of C++ scif_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def visit_scif_mop(self, *args):
        """
        visit_scif_mop(self, r, off) -> int
        """
        return _ida_hexrays.scif_visitor_t_visit_scif_mop(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> scif_visitor_t
        """
        if self.__class__ == scif_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_scif_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_scif_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_scif_visitor_t(self)
        return weakref_proxy(self)
scif_visitor_t_swigregister = _ida_hexrays.scif_visitor_t_swigregister
scif_visitor_t_swigregister(scif_visitor_t)

class mlist_mop_visitor_t(object):
    """
    Proxy of C++ mlist_mop_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    topins = _swig_property(_ida_hexrays.mlist_mop_visitor_t_topins_get, _ida_hexrays.mlist_mop_visitor_t_topins_set)
    curins = _swig_property(_ida_hexrays.mlist_mop_visitor_t_curins_get, _ida_hexrays.mlist_mop_visitor_t_curins_set)
    changed = _swig_property(_ida_hexrays.mlist_mop_visitor_t_changed_get, _ida_hexrays.mlist_mop_visitor_t_changed_set)
    list = _swig_property(_ida_hexrays.mlist_mop_visitor_t_list_get, _ida_hexrays.mlist_mop_visitor_t_list_set)
    def __init__(self, *args):
        """
        __init__(self) -> mlist_mop_visitor_t
        """
        if self.__class__ == mlist_mop_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_mlist_mop_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def visit_mop(self, *args):
        """
        visit_mop(self, op) -> int
        """
        return _ida_hexrays.mlist_mop_visitor_t_visit_mop(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mlist_mop_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_mlist_mop_visitor_t(self)
        return weakref_proxy(self)
mlist_mop_visitor_t_swigregister = _ida_hexrays.mlist_mop_visitor_t_swigregister
mlist_mop_visitor_t_swigregister(mlist_mop_visitor_t)

class lvar_ref_t(object):
    """
    Proxy of C++ lvar_ref_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.lvar_ref_t_mba_get)
    off = _swig_property(_ida_hexrays.lvar_ref_t_off_get, _ida_hexrays.lvar_ref_t_off_set)
    idx = _swig_property(_ida_hexrays.lvar_ref_t_idx_get, _ida_hexrays.lvar_ref_t_idx_set)
    def __init__(self, *args):
        """
        __init__(self, m, i, o=0) -> lvar_ref_t
        __init__(self, r) -> lvar_ref_t
        """
        this = _ida_hexrays.new_lvar_ref_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.lvar_ref_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.lvar_ref_t_compare(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.lvar_ref_t_swap(self, *args)

    def var(self, *args):
        """
        var(self) -> lvar_t
        """
        return _ida_hexrays.lvar_ref_t_var(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_ref_t
    __del__ = lambda self : None;
lvar_ref_t_swigregister = _ida_hexrays.lvar_ref_t_swigregister
lvar_ref_t_swigregister(lvar_ref_t)
mop_z = cvar.mop_z
mop_r = cvar.mop_r
mop_n = cvar.mop_n
mop_str = cvar.mop_str
mop_d = cvar.mop_d
mop_S = cvar.mop_S
mop_v = cvar.mop_v
mop_b = cvar.mop_b
mop_f = cvar.mop_f
mop_l = cvar.mop_l
mop_a = cvar.mop_a
mop_h = cvar.mop_h
mop_c = cvar.mop_c
mop_fn = cvar.mop_fn
mop_p = cvar.mop_p
mop_sc = cvar.mop_sc
NOSIZE = cvar.NOSIZE

class stkvar_ref_t(object):
    """
    Proxy of C++ stkvar_ref_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.stkvar_ref_t_mba_get)
    off = _swig_property(_ida_hexrays.stkvar_ref_t_off_get, _ida_hexrays.stkvar_ref_t_off_set)
    def __init__(self, *args):
        """
        __init__(self, m, o) -> stkvar_ref_t
        """
        this = _ida_hexrays.new_stkvar_ref_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.stkvar_ref_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.stkvar_ref_t_compare(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.stkvar_ref_t_swap(self, *args)

    def get_stkvar(self, *args):
        """
        get_stkvar(self, p_off=None) -> member_t *
        """
        return _ida_hexrays.stkvar_ref_t_get_stkvar(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_stkvar_ref_t
    __del__ = lambda self : None;
stkvar_ref_t_swigregister = _ida_hexrays.stkvar_ref_t_swigregister
stkvar_ref_t_swigregister(stkvar_ref_t)

class scif_t(vdloc_t):
    """
    Proxy of C++ scif_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.scif_t_mba_get, _ida_hexrays.scif_t_mba_set)
    name = _swig_property(_ida_hexrays.scif_t_name_get, _ida_hexrays.scif_t_name_set)
    type = _swig_property(_ida_hexrays.scif_t_type_get, _ida_hexrays.scif_t_type_set)
    def __init__(self, *args):
        """
        __init__(self, _mba, n, tif) -> scif_t
        """
        this = _ida_hexrays.new_scif_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_scif_t
    __del__ = lambda self : None;
scif_t_swigregister = _ida_hexrays.scif_t_swigregister
scif_t_swigregister(scif_t)

class mnumber_t(operand_locator_t):
    """
    Proxy of C++ mnumber_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    value = _swig_property(_ida_hexrays.mnumber_t_value_get, _ida_hexrays.mnumber_t_value_set)
    org_value = _swig_property(_ida_hexrays.mnumber_t_org_value_get, _ida_hexrays.mnumber_t_org_value_set)
    def __init__(self, *args):
        """
        __init__(self, v, _ea=BADADDR, n=0) -> mnumber_t
        """
        this = _ida_hexrays.new_mnumber_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.mnumber_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.mnumber_t_compare(self, *args)

    def update_value(self, *args):
        """
        update_value(self, val64)
        """
        return _ida_hexrays.mnumber_t_update_value(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mnumber_t
    __del__ = lambda self : None;
mnumber_t_swigregister = _ida_hexrays.mnumber_t_swigregister
mnumber_t_swigregister(mnumber_t)

class fnumber_t(object):
    """
    Proxy of C++ fnumber_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    fnum = _swig_property(_ida_hexrays.fnumber_t_fnum_get, _ida_hexrays.fnumber_t_fnum_set)
    nbytes = _swig_property(_ida_hexrays.fnumber_t_nbytes_get, _ida_hexrays.fnumber_t_nbytes_set)
    def dereference_uint16(self, *args):
        """
        dereference_uint16(self) -> uint16 *
        """
        return _ida_hexrays.fnumber_t_dereference_uint16(self, *args)

    def dereference_const_uint16(self, *args):
        """
        dereference_const_uint16(self) -> uint16 const *
        """
        return _ida_hexrays.fnumber_t_dereference_const_uint16(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.fnumber_t__print(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.fnumber_t_compare(self, *args)

    def __get_fnum(self, *args):
        """
        __get_fnum(self) -> fnum_array
        """
        return _ida_hexrays.fnumber_t___get_fnum(self, *args)

    fnum = property(__get_fnum)

    def __init__(self, *args):
        """
        __init__(self) -> fnumber_t
        """
        this = _ida_hexrays.new_fnumber_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_fnumber_t
    __del__ = lambda self : None;
fnumber_t_swigregister = _ida_hexrays.fnumber_t_swigregister
fnumber_t_swigregister(fnumber_t)

SHINS_NUMADDR = _ida_hexrays.SHINS_NUMADDR
"""
display definition addresses for numbers
"""
SHINS_VALNUM = _ida_hexrays.SHINS_VALNUM
"""
display value numbers
"""
SHINS_SHORT = _ida_hexrays.SHINS_SHORT
"""
do not display use-def chains and other attrs
"""
SHINS_LDXEA = _ida_hexrays.SHINS_LDXEA
"""
display address of ldx expressions (not used)
"""
NO_SIDEFF = _ida_hexrays.NO_SIDEFF
WITH_SIDEFF = _ida_hexrays.WITH_SIDEFF
ONLY_SIDEFF = _ida_hexrays.ONLY_SIDEFF
ANY_REGSIZE = _ida_hexrays.ANY_REGSIZE
class mop_t(object):
    """
    Proxy of C++ mop_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    t = _swig_property(_ida_hexrays.mop_t_t_get, _ida_hexrays.mop_t_t_set)
    oprops = _swig_property(_ida_hexrays.mop_t_oprops_get, _ida_hexrays.mop_t_oprops_set)
    valnum = _swig_property(_ida_hexrays.mop_t_valnum_get, _ida_hexrays.mop_t_valnum_set)
    size = _swig_property(_ida_hexrays.mop_t_size_get, _ida_hexrays.mop_t_size_set)
    def set_impptr_done(self, *args):
        """
        set_impptr_done(self)
        """
        return _ida_hexrays.mop_t_set_impptr_done(self, *args)

    def set_udt(self, *args):
        """
        set_udt(self)
        """
        return _ida_hexrays.mop_t_set_udt(self, *args)

    def set_undef_val(self, *args):
        """
        set_undef_val(self)
        """
        return _ida_hexrays.mop_t_set_undef_val(self, *args)

    def is_impptr_done(self, *args):
        """
        is_impptr_done(self) -> bool
        """
        return _ida_hexrays.mop_t_is_impptr_done(self, *args)

    def is_udt(self, *args):
        """
        is_udt(self) -> bool
        """
        return _ida_hexrays.mop_t_is_udt(self, *args)

    def probably_floating(self, *args):
        """
        probably_floating(self) -> bool
        """
        return _ida_hexrays.mop_t_probably_floating(self, *args)

    def is_ccflags(self, *args):
        """
        is_ccflags(self) -> bool
        """
        return _ida_hexrays.mop_t_is_ccflags(self, *args)

    def is_undef_val(self, *args):
        """
        is_undef_val(self) -> bool
        """
        return _ida_hexrays.mop_t_is_undef_val(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> mop_t
        __init__(self, rop) -> mop_t
        __init__(self, _r, _s) -> mop_t
        """
        this = _ida_hexrays.new_mop_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, rop) -> mop_t
        """
        return _ida_hexrays.mop_t_assign(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mop_t
    __del__ = lambda self : None;
    def zero(self, *args):
        """
        zero(self)
        """
        return _ida_hexrays.mop_t_zero(self, *args)

    def swap(self, *args):
        """
        swap(self, rop)
        """
        return _ida_hexrays.mop_t_swap(self, *args)

    def erase(self, *args):
        """
        erase(self)
        """
        return _ida_hexrays.mop_t_erase(self, *args)

    def erase_but_keep_size(self, *args):
        """
        erase_but_keep_size(self)
        """
        return _ida_hexrays.mop_t_erase_but_keep_size(self, *args)

    def _print(self, *args):
        """
        _print(self, shins_flags=0x04|0x02)
        """
        return _ida_hexrays.mop_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.mop_t_dstr(self, *args)

    def create_from_mlist(self, *args):
        """
        create_from_mlist(self, mba, lst, fullsize) -> bool
        """
        return _ida_hexrays.mop_t_create_from_mlist(self, *args)

    def create_from_ivlset(self, *args):
        """
        create_from_ivlset(self, mba, ivs, fullsize) -> bool
        """
        return _ida_hexrays.mop_t_create_from_ivlset(self, *args)

    def create_from_vdloc(self, *args):
        """
        create_from_vdloc(self, mba, loc, _size)
        """
        return _ida_hexrays.mop_t_create_from_vdloc(self, *args)

    def create_from_scattered_vdloc(self, *args):
        """
        create_from_scattered_vdloc(self, mba, name, type, loc)
        """
        return _ida_hexrays.mop_t_create_from_scattered_vdloc(self, *args)

    def create_from_insn(self, *args):
        """
        create_from_insn(self, m)
        """
        return _ida_hexrays.mop_t_create_from_insn(self, *args)

    def make_number(self, *args):
        """
        make_number(self, _value, _size, _ea=BADADDR, opnum=0)
        """
        return _ida_hexrays.mop_t_make_number(self, *args)

    def make_fpnum(self, *args):
        """
        make_fpnum(self, bytes, _size) -> bool
        """
        return _ida_hexrays.mop_t_make_fpnum(self, *args)

    def _make_reg(self, *args):
        """
        _make_reg(self, reg)
        _make_reg(self, reg, _size)
        """
        return _ida_hexrays.mop_t__make_reg(self, *args)

    def make_reg(self, *args):
        """
        make_reg(self, reg)
        make_reg(self, reg, _size)
        """
        return _ida_hexrays.mop_t_make_reg(self, *args)

    def _make_lvar(self, *args):
        """
        _make_lvar(self, mba, idx, off=0)
        """
        return _ida_hexrays.mop_t__make_lvar(self, *args)

    def _make_gvar(self, *args):
        """
        _make_gvar(self, ea)
        """
        return _ida_hexrays.mop_t__make_gvar(self, *args)

    def make_gvar(self, *args):
        """
        make_gvar(self, ea)
        """
        return _ida_hexrays.mop_t_make_gvar(self, *args)

    def _make_stkvar(self, *args):
        """
        _make_stkvar(self, mba, off)
        """
        return _ida_hexrays.mop_t__make_stkvar(self, *args)

    def make_reg_pair(self, *args):
        """
        make_reg_pair(self, loreg, hireg, halfsize)
        """
        return _ida_hexrays.mop_t_make_reg_pair(self, *args)

    def _make_insn(self, *args):
        """
        _make_insn(self, ins)
        """
        return _ida_hexrays.mop_t__make_insn(self, *args)

    def make_insn(self, *args):
        """
        make_insn(self, ins)
        """
        return _ida_hexrays.mop_t_make_insn(self, *args)

    def _make_blkref(self, *args):
        """
        _make_blkref(self, blknum)
        """
        return _ida_hexrays.mop_t__make_blkref(self, *args)

    def make_blkref(self, *args):
        """
        make_blkref(self, blknum)
        """
        return _ida_hexrays.mop_t_make_blkref(self, *args)

    def make_helper(self, *args):
        """
        make_helper(self, name)
        """
        return _ida_hexrays.mop_t_make_helper(self, *args)

    def _make_strlit(self, *args):
        """
        _make_strlit(self, str)
        """
        return _ida_hexrays.mop_t__make_strlit(self, *args)

    def _make_callinfo(self, *args):
        """
        _make_callinfo(self, fi)
        """
        return _ida_hexrays.mop_t__make_callinfo(self, *args)

    def _make_cases(self, *args):
        """
        _make_cases(self, _cases)
        """
        return _ida_hexrays.mop_t__make_cases(self, *args)

    def _make_pair(self, *args):
        """
        _make_pair(self, _pair)
        """
        return _ida_hexrays.mop_t__make_pair(self, *args)

    def is_reg(self, *args):
        """
        is_reg(self) -> bool
        is_reg(self, _r) -> bool
        is_reg(self, _r, _size) -> bool
        """
        return _ida_hexrays.mop_t_is_reg(self, *args)

    def is_cc(self, *args):
        """
        is_cc(self) -> bool
        """
        return _ida_hexrays.mop_t_is_cc(self, *args)

    def is_bit_reg(self, *args):
        """
        is_bit_reg(self, reg) -> bool
        is_bit_reg(self) -> bool
        """
        return _ida_hexrays.mop_t_is_bit_reg(self, *args)

    def is_kreg(self, *args):
        """
        is_kreg(self) -> bool
        """
        return _ida_hexrays.mop_t_is_kreg(self, *args)

    def is_mob(self, *args):
        """
        is_mob(self, serial) -> bool
        """
        return _ida_hexrays.mop_t_is_mob(self, *args)

    def is_scattered(self, *args):
        """
        is_scattered(self) -> bool
        """
        return _ida_hexrays.mop_t_is_scattered(self, *args)

    def is_glbaddr(self, *args):
        """
        is_glbaddr(self) -> bool
        is_glbaddr(self, ea) -> bool
        """
        return _ida_hexrays.mop_t_is_glbaddr(self, *args)

    def is_stkaddr(self, *args):
        """
        is_stkaddr(self) -> bool
        """
        return _ida_hexrays.mop_t_is_stkaddr(self, *args)

    def is_insn(self, *args):
        """
        is_insn(self) -> bool
        is_insn(self, code) -> bool
        """
        return _ida_hexrays.mop_t_is_insn(self, *args)

    def has_side_effects(self, *args):
        """
        has_side_effects(self, include_ldx_and_divs=False) -> bool
        """
        return _ida_hexrays.mop_t_has_side_effects(self, *args)

    def may_use_aliased_memory(self, *args):
        """
        may_use_aliased_memory(self) -> bool
        """
        return _ida_hexrays.mop_t_may_use_aliased_memory(self, *args)

    def is01(self, *args):
        """
        is01(self) -> bool
        """
        return _ida_hexrays.mop_t_is01(self, *args)

    def is_sign_extended_from(self, *args):
        """
        is_sign_extended_from(self, nbytes) -> bool
        """
        return _ida_hexrays.mop_t_is_sign_extended_from(self, *args)

    def is_zero_extended_from(self, *args):
        """
        is_zero_extended_from(self, nbytes) -> bool
        """
        return _ida_hexrays.mop_t_is_zero_extended_from(self, *args)

    def is_extended_from(self, *args):
        """
        is_extended_from(self, nbytes, is_signed) -> bool
        """
        return _ida_hexrays.mop_t_is_extended_from(self, *args)

    def equal_mops(self, *args):
        """
        equal_mops(self, rop, eqflags) -> bool
        """
        return _ida_hexrays.mop_t_equal_mops(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, rop) -> bool
        """
        return _ida_hexrays.mop_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, rop) -> bool
        """
        return _ida_hexrays.mop_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, rop) -> bool
        """
        return _ida_hexrays.mop_t___lt__(self, *args)

    def lexcompare(self, *args):
        """
        lexcompare(self, rop) -> int
        """
        return _ida_hexrays.mop_t_lexcompare(self, *args)

    def for_all_ops(self, *args):
        """
        for_all_ops(self, mv, type=None, is_target=False) -> int
        """
        return _ida_hexrays.mop_t_for_all_ops(self, *args)

    def for_all_scattered_submops(self, *args):
        """
        for_all_scattered_submops(self, sv) -> int
        """
        return _ida_hexrays.mop_t_for_all_scattered_submops(self, *args)

    def value(self, *args):
        """
        value(self, is_signed) -> uint64
        """
        return _ida_hexrays.mop_t_value(self, *args)

    def signed_value(self, *args):
        """
        signed_value(self) -> int64
        """
        return _ida_hexrays.mop_t_signed_value(self, *args)

    def unsigned_value(self, *args):
        """
        unsigned_value(self) -> uint64
        """
        return _ida_hexrays.mop_t_unsigned_value(self, *args)

    def is_constant(self, *args):
        """
        is_constant(self, is_signed=True) -> bool
        """
        return _ida_hexrays.mop_t_is_constant(self, *args)

    def is_equal_to(self, *args):
        """
        is_equal_to(self, n, is_signed=True) -> bool
        """
        return _ida_hexrays.mop_t_is_equal_to(self, *args)

    def is_zero(self, *args):
        """
        is_zero(self) -> bool
        """
        return _ida_hexrays.mop_t_is_zero(self, *args)

    def is_one(self, *args):
        """
        is_one(self) -> bool
        """
        return _ida_hexrays.mop_t_is_one(self, *args)

    def is_positive_constant(self, *args):
        """
        is_positive_constant(self) -> bool
        """
        return _ida_hexrays.mop_t_is_positive_constant(self, *args)

    def is_negative_constant(self, *args):
        """
        is_negative_constant(self) -> bool
        """
        return _ida_hexrays.mop_t_is_negative_constant(self, *args)

    def get_stkvar(self, *args):
        """
        get_stkvar(self, p_off) -> member_t *
        """
        return _ida_hexrays.mop_t_get_stkvar(self, *args)

    def get_stkoff(self, *args):
        """
        get_stkoff(self, p_off) -> bool
        """
        return _ida_hexrays.mop_t_get_stkoff(self, *args)

    def get_insn(self, *args):
        """
        get_insn(self, code) -> minsn_t
        get_insn(self, code) -> minsn_t
        """
        return _ida_hexrays.mop_t_get_insn(self, *args)

    def make_low_half(self, *args):
        """
        make_low_half(self, width) -> bool
        """
        return _ida_hexrays.mop_t_make_low_half(self, *args)

    def make_high_half(self, *args):
        """
        make_high_half(self, width) -> bool
        """
        return _ida_hexrays.mop_t_make_high_half(self, *args)

    def make_first_half(self, *args):
        """
        make_first_half(self, width) -> bool
        """
        return _ida_hexrays.mop_t_make_first_half(self, *args)

    def make_second_half(self, *args):
        """
        make_second_half(self, width) -> bool
        """
        return _ida_hexrays.mop_t_make_second_half(self, *args)

    def shift_mop(self, *args):
        """
        shift_mop(self, offset) -> bool
        """
        return _ida_hexrays.mop_t_shift_mop(self, *args)

    def change_size(self, *args):
        """
        change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
        """
        return _ida_hexrays.mop_t_change_size(self, *args)

    def double_size(self, *args):
        """
        double_size(self, sideff=WITH_SIDEFF) -> bool
        """
        return _ida_hexrays.mop_t_double_size(self, *args)

    def preserve_side_effects(self, *args):
        """
        preserve_side_effects(self, blk, top, moved_calls=None) -> bool
        """
        return _ida_hexrays.mop_t_preserve_side_effects(self, *args)

    def apply_ld_mcode(self, *args):
        """
        apply_ld_mcode(self, mcode, ea, newsize)
        """
        return _ida_hexrays.mop_t_apply_ld_mcode(self, *args)

    def apply_xdu(self, *args):
        """
        apply_xdu(self, ea, newsize)
        """
        return _ida_hexrays.mop_t_apply_xdu(self, *args)

    def apply_xds(self, *args):
        """
        apply_xds(self, ea, newsize)
        """
        return _ida_hexrays.mop_t_apply_xds(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.mop_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.mop_t__deregister(self, *args)

    def _get_r(self, *args):
        """
        _get_r(self) -> mreg_t
        """
        return _ida_hexrays.mop_t__get_r(self, *args)

    def _set_r(self, *args):
        """
        _set_r(self, _v)
        """
        return _ida_hexrays.mop_t__set_r(self, *args)

    r = property(                                                                lambda self: self._get_r() if self.t == mop_r else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_r,"self.t == mop_r")                                           and self._set_r(v))
    def _get_nnn(self, *args):
        """
        _get_nnn(self) -> mnumber_t
        """
        return _ida_hexrays.mop_t__get_nnn(self, *args)

    def _set_nnn(self, *args):
        """
        _set_nnn(self, _v)
        """
        return _ida_hexrays.mop_t__set_nnn(self, *args)

    nnn = property(                                                                lambda self: self._get_nnn() if self.t == mop_n else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_n,"self.t == mop_n")                                           and self._ensure_no_obj(self._get_nnn(),"nnn", True)                  and self._acquire_ownership(v, True)                                  and self._set_nnn(v))
    def _get_cstr(self, *args):
        """
        _get_cstr(self) -> char const *
        """
        return _ida_hexrays.mop_t__get_cstr(self, *args)

    def _set_cstr(self, *args):
        """
        _set_cstr(self, _v)
        """
        return _ida_hexrays.mop_t__set_cstr(self, *args)

    cstr = property(                                                                lambda self: self._get_cstr() if self.t == mop_str else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_str,"self.t == mop_str")                                           and self._ensure_no_obj(self._get_cstr(),"cstr", False)                  and self._acquire_ownership(v, False)                                  and self._set_cstr(v))
    def _get_d(self, *args):
        """
        _get_d(self) -> minsn_t
        """
        return _ida_hexrays.mop_t__get_d(self, *args)

    def _set_d(self, *args):
        """
        _set_d(self, _v)
        """
        return _ida_hexrays.mop_t__set_d(self, *args)

    d = property(                                                                lambda self: self._get_d() if self.t == mop_d else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_d,"self.t == mop_d")                                           and self._ensure_no_obj(self._get_d(),"d", True)                  and self._acquire_ownership(v, True)                                  and self._set_d(v))
    def _get_s(self, *args):
        """
        _get_s(self) -> stkvar_ref_t
        """
        return _ida_hexrays.mop_t__get_s(self, *args)

    def _set_s(self, *args):
        """
        _set_s(self, _v)
        """
        return _ida_hexrays.mop_t__set_s(self, *args)

    s = property(                                                                lambda self: self._get_s() if self.t == mop_S else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_S,"self.t == mop_S")                                           and self._ensure_no_obj(self._get_s(),"s", True)                  and self._acquire_ownership(v, True)                                  and self._set_s(v))
    def _get_g(self, *args):
        """
        _get_g(self) -> ea_t
        """
        return _ida_hexrays.mop_t__get_g(self, *args)

    def _set_g(self, *args):
        """
        _set_g(self, _v)
        """
        return _ida_hexrays.mop_t__set_g(self, *args)

    g = property(                                                                lambda self: self._get_g() if self.t == mop_v else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_v,"self.t == mop_v")                                           and self._set_g(v))
    def _get_b(self, *args):
        """
        _get_b(self) -> int
        """
        return _ida_hexrays.mop_t__get_b(self, *args)

    def _set_b(self, *args):
        """
        _set_b(self, _v)
        """
        return _ida_hexrays.mop_t__set_b(self, *args)

    b = property(                                                                lambda self: self._get_b() if self.t == mop_b else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_b,"self.t == mop_b")                                           and self._set_b(v))
    def _get_f(self, *args):
        """
        _get_f(self) -> mcallinfo_t
        """
        return _ida_hexrays.mop_t__get_f(self, *args)

    def _set_f(self, *args):
        """
        _set_f(self, _v)
        """
        return _ida_hexrays.mop_t__set_f(self, *args)

    f = property(                                                                lambda self: self._get_f() if self.t == mop_f else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_f,"self.t == mop_f")                                           and self._ensure_no_obj(self._get_f(),"f", True)                  and self._acquire_ownership(v, True)                                  and self._set_f(v))
    def _get_l(self, *args):
        """
        _get_l(self) -> lvar_ref_t
        """
        return _ida_hexrays.mop_t__get_l(self, *args)

    def _set_l(self, *args):
        """
        _set_l(self, _v)
        """
        return _ida_hexrays.mop_t__set_l(self, *args)

    l = property(                                                                lambda self: self._get_l() if self.t == mop_l else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_l,"self.t == mop_l")                                           and self._ensure_no_obj(self._get_l(),"l", True)                  and self._acquire_ownership(v, True)                                  and self._set_l(v))
    def _get_a(self, *args):
        """
        _get_a(self) -> mop_addr_t
        """
        return _ida_hexrays.mop_t__get_a(self, *args)

    def _set_a(self, *args):
        """
        _set_a(self, _v)
        """
        return _ida_hexrays.mop_t__set_a(self, *args)

    a = property(                                                                lambda self: self._get_a() if self.t == mop_a else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_a,"self.t == mop_a")                                           and self._ensure_no_obj(self._get_a(),"a", True)                  and self._acquire_ownership(v, True)                                  and self._set_a(v))
    def _get_helper(self, *args):
        """
        _get_helper(self) -> char const *
        """
        return _ida_hexrays.mop_t__get_helper(self, *args)

    def _set_helper(self, *args):
        """
        _set_helper(self, _v)
        """
        return _ida_hexrays.mop_t__set_helper(self, *args)

    helper = property(                                                                lambda self: self._get_helper() if self.t == mop_h else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_h,"self.t == mop_h")                                           and self._ensure_no_obj(self._get_helper(),"helper", False)                  and self._acquire_ownership(v, False)                                  and self._set_helper(v))
    def _get_c(self, *args):
        """
        _get_c(self) -> mcases_t
        """
        return _ida_hexrays.mop_t__get_c(self, *args)

    def _set_c(self, *args):
        """
        _set_c(self, _v)
        """
        return _ida_hexrays.mop_t__set_c(self, *args)

    c = property(                                                                lambda self: self._get_c() if self.t == mop_c else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_c,"self.t == mop_c")                                           and self._ensure_no_obj(self._get_c(),"c", True)                  and self._acquire_ownership(v, True)                                  and self._set_c(v))
    def _get_fpc(self, *args):
        """
        _get_fpc(self) -> fnumber_t
        """
        return _ida_hexrays.mop_t__get_fpc(self, *args)

    def _set_fpc(self, *args):
        """
        _set_fpc(self, _v)
        """
        return _ida_hexrays.mop_t__set_fpc(self, *args)

    fpc = property(                                                                lambda self: self._get_fpc() if self.t == mop_fn else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_fn,"self.t == mop_fn")                                           and self._ensure_no_obj(self._get_fpc(),"fpc", True)                  and self._acquire_ownership(v, True)                                  and self._set_fpc(v))
    def _get_pair(self, *args):
        """
        _get_pair(self) -> mop_pair_t
        """
        return _ida_hexrays.mop_t__get_pair(self, *args)

    def _set_pair(self, *args):
        """
        _set_pair(self, _v)
        """
        return _ida_hexrays.mop_t__set_pair(self, *args)

    pair = property(                                                                lambda self: self._get_pair() if self.t == mop_p else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_p,"self.t == mop_p")                                           and self._ensure_no_obj(self._get_pair(),"pair", True)                  and self._acquire_ownership(v, True)                                  and self._set_pair(v))
    def _get_scif(self, *args):
        """
        _get_scif(self) -> scif_t
        """
        return _ida_hexrays.mop_t__get_scif(self, *args)

    def _set_scif(self, *args):
        """
        _set_scif(self, _v)
        """
        return _ida_hexrays.mop_t__set_scif(self, *args)

    scif = property(                                                                lambda self: self._get_scif() if self.t == mop_sc else None,                    lambda self, v:                                                              self._ensure_cond(self.t == mop_sc,"self.t == mop_sc")                                           and self._ensure_no_obj(self._get_scif(),"scif", True)                  and self._acquire_ownership(v, True)                                  and self._set_scif(v))
    def _get_t(self, *args):
        """
        _get_t(self) -> mopt_t
        """
        return _ida_hexrays.mop_t__get_t(self, *args)

    def _set_t(self, *args):
        """
        _set_t(self, v)
        """
        return _ida_hexrays.mop_t__set_t(self, *args)

    def _ensure_no_t(self):
        if self.t not in [mop_z]:
            raise Exception("%s has type %s; cannot be modified" % (self, self.t))
        return True
    t = property(
            _get_t,
            lambda self, v: self._ensure_no_t() and self._set_t(v))

    def __dbg_get_meminfo(self, *args):
        """
        __dbg_get_meminfo(self) -> qstring
        """
        return _ida_hexrays.mop_t___dbg_get_meminfo(self, *args)

    def __dbg_get_registered_kind(self, *args):
        """
        __dbg_get_registered_kind(self) -> int
        """
        return _ida_hexrays.mop_t___dbg_get_registered_kind(self, *args)

    def _obj_id(self, *args):
        """
        _obj_id(self) -> PyObject *
        """
        return _ida_hexrays.mop_t__obj_id(self, *args)

    obj_id = property(_obj_id)

    def _ensure_cond(self, ok, cond_str):
        if not ok:
            raise Exception("Condition \"%s\" not verified" % cond_str)
        return True

    def _ensure_no_obj(self, o, attr, attr_is_acquired):
        if attr_is_acquired and o is not None:
            raise Exception("%s already owns attribute \"%s\" (%s); cannot be modified" % (self, attr, o))
        return True

    def _acquire_ownership(self, v, acquire):
        if acquire and (v is not None) and not isinstance(v, (int, long)):
            if not v.thisown:
                raise Exception("%s is already owned, and cannot be reused" % v)
            v.thisown = False
            dereg = getattr(v, "_deregister", None)
            if dereg:
                dereg()
        return True

    def _maybe_disown_and_deregister(self):
        if self.thisown:
            self.thisown = False
            self._deregister()

    def _own_and_register(self):
        assert(not self.thisown)
        self.thisown = True
        self._register()

    def replace_by(self, o):
        assert(isinstance(o, (cexpr_t, cinsn_t)))
        o._maybe_disown_and_deregister()
        self._replace_by(o)

    def _meminfo(self):
        cpp = self.__dbg_get_meminfo()
        rkind = self.__dbg_get_registered_kind()
        rkind_str = [
                "(not owned)",
                "cfuncptr_t",
                "cinsn_t",
                "cexpr_t",
                "cblock_t",
                "mbl_array_t",
                "mop_t",
                "minsn_t",
                "optinsn_t",
                "optblock_t",
                "valrng_t"][rkind]
        return "%s [thisown=%s, owned by IDAPython as=%s]" % (
                cpp,
                self.thisown,
                rkind_str)
    meminfo = property(_meminfo)

mop_t_swigregister = _ida_hexrays.mop_t_swigregister
mop_t_swigregister(mop_t)
MAX_OPSIZE = cvar.MAX_OPSIZE
DOUBLE_OPSIZE = cvar.DOUBLE_OPSIZE
OPROP_IMPDONE = _ida_hexrays.OPROP_IMPDONE
"""
imported operand (a pointer) has been dereferenced
"""
OPROP_UDT = _ida_hexrays.OPROP_UDT
"""
a struct or union
"""
OPROP_FLOAT = _ida_hexrays.OPROP_FLOAT
"""
possibly floating value
"""
OPROP_CCFLAGS = _ida_hexrays.OPROP_CCFLAGS
"""
condition codes register value
"""
OPROP_UDEFVAL = _ida_hexrays.OPROP_UDEFVAL
"""
uses undefined value
"""

def lexcompare(*args):
  """
  lexcompare(a, b) -> int
  """
  return _ida_hexrays.lexcompare(*args)

class mop_pair_t(object):
    """
    Proxy of C++ mop_pair_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lop = _swig_property(_ida_hexrays.mop_pair_t_lop_get, _ida_hexrays.mop_pair_t_lop_set)
    hop = _swig_property(_ida_hexrays.mop_pair_t_hop_get, _ida_hexrays.mop_pair_t_hop_set)
    def __init__(self, *args):
        """
        __init__(self) -> mop_pair_t
        """
        this = _ida_hexrays.new_mop_pair_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_mop_pair_t
    __del__ = lambda self : None;
mop_pair_t_swigregister = _ida_hexrays.mop_pair_t_swigregister
mop_pair_t_swigregister(mop_pair_t)

class mop_addr_t(mop_t):
    """
    Proxy of C++ mop_addr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    insize = _swig_property(_ida_hexrays.mop_addr_t_insize_get, _ida_hexrays.mop_addr_t_insize_set)
    outsize = _swig_property(_ida_hexrays.mop_addr_t_outsize_get, _ida_hexrays.mop_addr_t_outsize_set)
    def __init__(self, *args):
        """
        __init__(self) -> mop_addr_t
        __init__(self, ra) -> mop_addr_t
        __init__(self, ra, isz, osz) -> mop_addr_t
        """
        this = _ida_hexrays.new_mop_addr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def lexcompare(self, *args):
        """
        lexcompare(self, ra) -> int
        """
        return _ida_hexrays.mop_addr_t_lexcompare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mop_addr_t
    __del__ = lambda self : None;
mop_addr_t_swigregister = _ida_hexrays.mop_addr_t_swigregister
mop_addr_t_swigregister(mop_addr_t)

class mcallarg_t(mop_t):
    """
    Proxy of C++ mcallarg_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.mcallarg_t_ea_get, _ida_hexrays.mcallarg_t_ea_set)
    type = _swig_property(_ida_hexrays.mcallarg_t_type_get, _ida_hexrays.mcallarg_t_type_set)
    name = _swig_property(_ida_hexrays.mcallarg_t_name_get, _ida_hexrays.mcallarg_t_name_set)
    argloc = _swig_property(_ida_hexrays.mcallarg_t_argloc_get, _ida_hexrays.mcallarg_t_argloc_set)
    def __init__(self, *args):
        """
        __init__(self) -> mcallarg_t
        __init__(self, rarg) -> mcallarg_t
        """
        this = _ida_hexrays.new_mcallarg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def copy_mop(self, *args):
        """
        copy_mop(self, op)
        """
        return _ida_hexrays.mcallarg_t_copy_mop(self, *args)

    def _print(self, *args):
        """
        _print(self, shins_flags=0x04|0x02)
        """
        return _ida_hexrays.mcallarg_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.mcallarg_t_dstr(self, *args)

    def set_regarg(self, *args):
        """
        set_regarg(self, mr, sz, tif)
        set_regarg(self, mr, tif)
        set_regarg(self, mr, dt, sign=type_unsigned)
        """
        return _ida_hexrays.mcallarg_t_set_regarg(self, *args)

    def make_int(self, *args):
        """
        make_int(self, val, val_ea, opno=0)
        """
        return _ida_hexrays.mcallarg_t_make_int(self, *args)

    def make_uint(self, *args):
        """
        make_uint(self, val, val_ea, opno=0)
        """
        return _ida_hexrays.mcallarg_t_make_uint(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mcallarg_t
    __del__ = lambda self : None;
mcallarg_t_swigregister = _ida_hexrays.mcallarg_t_swigregister
mcallarg_t_swigregister(mcallarg_t)

ROLE_UNK = _ida_hexrays.ROLE_UNK
ROLE_EMPTY = _ida_hexrays.ROLE_EMPTY
ROLE_MEMSET = _ida_hexrays.ROLE_MEMSET
ROLE_MEMSET32 = _ida_hexrays.ROLE_MEMSET32
ROLE_MEMSET64 = _ida_hexrays.ROLE_MEMSET64
ROLE_MEMCPY = _ida_hexrays.ROLE_MEMCPY
ROLE_STRCPY = _ida_hexrays.ROLE_STRCPY
ROLE_STRLEN = _ida_hexrays.ROLE_STRLEN
ROLE_STRCAT = _ida_hexrays.ROLE_STRCAT
ROLE_TAIL = _ida_hexrays.ROLE_TAIL
ROLE_BUG = _ida_hexrays.ROLE_BUG
ROLE_ALLOCA = _ida_hexrays.ROLE_ALLOCA
ROLE_BSWAP = _ida_hexrays.ROLE_BSWAP
ROLE_PRESENT = _ida_hexrays.ROLE_PRESENT
ROLE_CONTAINING_RECORD = _ida_hexrays.ROLE_CONTAINING_RECORD
ROLE_FASTFAIL = _ida_hexrays.ROLE_FASTFAIL
ROLE_READFLAGS = _ida_hexrays.ROLE_READFLAGS
ROLE_IS_MUL_OK = _ida_hexrays.ROLE_IS_MUL_OK
ROLE_SATURATED_MUL = _ida_hexrays.ROLE_SATURATED_MUL
ROLE_BITTEST = _ida_hexrays.ROLE_BITTEST
ROLE_BITTESTANDSET = _ida_hexrays.ROLE_BITTESTANDSET
ROLE_BITTESTANDRESET = _ida_hexrays.ROLE_BITTESTANDRESET
ROLE_BITTESTANDCOMPLEMENT = _ida_hexrays.ROLE_BITTESTANDCOMPLEMENT
ROLE_VA_ARG = _ida_hexrays.ROLE_VA_ARG
ROLE_VA_COPY = _ida_hexrays.ROLE_VA_COPY
ROLE_VA_START = _ida_hexrays.ROLE_VA_START
ROLE_VA_END = _ida_hexrays.ROLE_VA_END
ROLE_ROL = _ida_hexrays.ROLE_ROL
ROLE_ROR = _ida_hexrays.ROLE_ROR
ROLE_CFSUB3 = _ida_hexrays.ROLE_CFSUB3
ROLE_OFSUB3 = _ida_hexrays.ROLE_OFSUB3
ROLE_ABS = _ida_hexrays.ROLE_ABS
FUNC_NAME_MEMCPY = _ida_hexrays.FUNC_NAME_MEMCPY
FUNC_NAME_MEMSET = _ida_hexrays.FUNC_NAME_MEMSET
FUNC_NAME_MEMSET32 = _ida_hexrays.FUNC_NAME_MEMSET32
FUNC_NAME_MEMSET64 = _ida_hexrays.FUNC_NAME_MEMSET64
FUNC_NAME_STRCPY = _ida_hexrays.FUNC_NAME_STRCPY
FUNC_NAME_STRLEN = _ida_hexrays.FUNC_NAME_STRLEN
FUNC_NAME_STRCAT = _ida_hexrays.FUNC_NAME_STRCAT
FUNC_NAME_TAIL = _ida_hexrays.FUNC_NAME_TAIL
FUNC_NAME_VA_ARG = _ida_hexrays.FUNC_NAME_VA_ARG
FUNC_NAME_EMPTY = _ida_hexrays.FUNC_NAME_EMPTY
FUNC_NAME_PRESENT = _ida_hexrays.FUNC_NAME_PRESENT
FUNC_NAME_CONTAINING_RECORD = _ida_hexrays.FUNC_NAME_CONTAINING_RECORD
class mcallinfo_t(object):
    """
    Proxy of C++ mcallinfo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    callee = _swig_property(_ida_hexrays.mcallinfo_t_callee_get, _ida_hexrays.mcallinfo_t_callee_set)
    solid_args = _swig_property(_ida_hexrays.mcallinfo_t_solid_args_get, _ida_hexrays.mcallinfo_t_solid_args_set)
    call_spd = _swig_property(_ida_hexrays.mcallinfo_t_call_spd_get, _ida_hexrays.mcallinfo_t_call_spd_set)
    stkargs_top = _swig_property(_ida_hexrays.mcallinfo_t_stkargs_top_get, _ida_hexrays.mcallinfo_t_stkargs_top_set)
    cc = _swig_property(_ida_hexrays.mcallinfo_t_cc_get, _ida_hexrays.mcallinfo_t_cc_set)
    args = _swig_property(_ida_hexrays.mcallinfo_t_args_get, _ida_hexrays.mcallinfo_t_args_set)
    retregs = _swig_property(_ida_hexrays.mcallinfo_t_retregs_get, _ida_hexrays.mcallinfo_t_retregs_set)
    return_type = _swig_property(_ida_hexrays.mcallinfo_t_return_type_get, _ida_hexrays.mcallinfo_t_return_type_set)
    return_argloc = _swig_property(_ida_hexrays.mcallinfo_t_return_argloc_get, _ida_hexrays.mcallinfo_t_return_argloc_set)
    return_regs = _swig_property(_ida_hexrays.mcallinfo_t_return_regs_get, _ida_hexrays.mcallinfo_t_return_regs_set)
    spoiled = _swig_property(_ida_hexrays.mcallinfo_t_spoiled_get, _ida_hexrays.mcallinfo_t_spoiled_set)
    pass_regs = _swig_property(_ida_hexrays.mcallinfo_t_pass_regs_get, _ida_hexrays.mcallinfo_t_pass_regs_set)
    visible_memory = _swig_property(_ida_hexrays.mcallinfo_t_visible_memory_get, _ida_hexrays.mcallinfo_t_visible_memory_set)
    dead_regs = _swig_property(_ida_hexrays.mcallinfo_t_dead_regs_get, _ida_hexrays.mcallinfo_t_dead_regs_set)
    flags = _swig_property(_ida_hexrays.mcallinfo_t_flags_get, _ida_hexrays.mcallinfo_t_flags_set)
    role = _swig_property(_ida_hexrays.mcallinfo_t_role_get, _ida_hexrays.mcallinfo_t_role_set)
    def __init__(self, *args):
        """
        __init__(self, _callee=BADADDR, _sargs=0) -> mcallinfo_t
        """
        this = _ida_hexrays.new_mcallinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def lexcompare(self, *args):
        """
        lexcompare(self, f) -> int
        """
        return _ida_hexrays.mcallinfo_t_lexcompare(self, *args)

    def set_type(self, *args):
        """
        set_type(self, type) -> bool
        """
        return _ida_hexrays.mcallinfo_t_set_type(self, *args)

    def get_type(self, *args):
        """
        get_type(self) -> tinfo_t
        """
        return _ida_hexrays.mcallinfo_t_get_type(self, *args)

    def is_vararg(self, *args):
        """
        is_vararg(self) -> bool
        """
        return _ida_hexrays.mcallinfo_t_is_vararg(self, *args)

    def _print(self, *args):
        """
        _print(self, size=-1, shins_flags=0x04|0x02)
        """
        return _ida_hexrays.mcallinfo_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.mcallinfo_t_dstr(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mcallinfo_t
    __del__ = lambda self : None;
mcallinfo_t_swigregister = _ida_hexrays.mcallinfo_t_swigregister
mcallinfo_t_swigregister(mcallinfo_t)
FCI_PROP = _ida_hexrays.FCI_PROP
"""
call has been propagated
"""
FCI_DEAD = _ida_hexrays.FCI_DEAD
"""
some return registers were determined dead
"""
FCI_FINAL = _ida_hexrays.FCI_FINAL
"""
call type is final, should not be changed
"""
FCI_NORET = _ida_hexrays.FCI_NORET
"""
call does not return
"""
FCI_PURE = _ida_hexrays.FCI_PURE
"""
pure function
"""
FCI_NOSIDE = _ida_hexrays.FCI_NOSIDE
"""
call does not have side effects
"""
FCI_SPLOK = _ida_hexrays.FCI_SPLOK
"""
spoiled/visible_memory lists have been optimized. for some functions
we can reduce them as soon as information about the arguments becomes
available. in order not to try optimize them again we use this bit.
"""
FCI_HASCALL = _ida_hexrays.FCI_HASCALL
"""
A function is an synthetic helper combined from several instructions
and at least one of them was a call to a real functions
"""
FCI_HASFMT = _ida_hexrays.FCI_HASFMT
"""
printf- or scanf-style format string

A variadic function with recognized
"""

class mcases_t(object):
    """
    Proxy of C++ mcases_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    values = _swig_property(_ida_hexrays.mcases_t_values_get, _ida_hexrays.mcases_t_values_set)
    targets = _swig_property(_ida_hexrays.mcases_t_targets_get, _ida_hexrays.mcases_t_targets_set)
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.mcases_t_swap(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.mcases_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.mcases_t_compare(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mcases_t_empty(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.mcases_t_size(self, *args)

    def resize(self, *args):
        """
        resize(self, s)
        """
        return _ida_hexrays.mcases_t_resize(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.mcases_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.mcases_t_dstr(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> mcases_t
        """
        this = _ida_hexrays.new_mcases_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_mcases_t
    __del__ = lambda self : None;
mcases_t_swigregister = _ida_hexrays.mcases_t_swigregister
mcases_t_swigregister(mcases_t)

class voff_t(object):
    """
    Proxy of C++ voff_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    off = _swig_property(_ida_hexrays.voff_t_off_get, _ida_hexrays.voff_t_off_set)
    type = _swig_property(_ida_hexrays.voff_t_type_get, _ida_hexrays.voff_t_type_set)
    def __init__(self, *args):
        """
        __init__(self) -> voff_t
        __init__(self, _type, _off) -> voff_t
        __init__(self, op) -> voff_t
        """
        this = _ida_hexrays.new_voff_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """
        set(self, _type, _off)
        """
        return _ida_hexrays.voff_t_set(self, *args)

    def set_stkoff(self, *args):
        """
        set_stkoff(self, stkoff)
        """
        return _ida_hexrays.voff_t_set_stkoff(self, *args)

    def set_reg(self, *args):
        """
        set_reg(self, mreg)
        """
        return _ida_hexrays.voff_t_set_reg(self, *args)

    def undef(self, *args):
        """
        undef(self)
        """
        return _ida_hexrays.voff_t_undef(self, *args)

    def defined(self, *args):
        """
        defined(self) -> bool
        """
        return _ida_hexrays.voff_t_defined(self, *args)

    def is_reg(self, *args):
        """
        is_reg(self) -> bool
        """
        return _ida_hexrays.voff_t_is_reg(self, *args)

    def is_stkoff(self, *args):
        """
        is_stkoff(self) -> bool
        """
        return _ida_hexrays.voff_t_is_stkoff(self, *args)

    def get_reg(self, *args):
        """
        get_reg(self) -> mreg_t
        """
        return _ida_hexrays.voff_t_get_reg(self, *args)

    def get_stkoff(self, *args):
        """
        get_stkoff(self) -> sval_t
        """
        return _ida_hexrays.voff_t_get_stkoff(self, *args)

    def inc(self, *args):
        """
        inc(self, delta)
        """
        return _ida_hexrays.voff_t_inc(self, *args)

    def add(self, *args):
        """
        add(self, width) -> voff_t
        """
        return _ida_hexrays.voff_t_add(self, *args)

    def diff(self, *args):
        """
        diff(self, r) -> sval_t
        """
        return _ida_hexrays.voff_t_diff(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.voff_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.voff_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_voff_t
    __del__ = lambda self : None;
voff_t_swigregister = _ida_hexrays.voff_t_swigregister
voff_t_swigregister(voff_t)

class vivl_t(voff_t):
    """
    Proxy of C++ vivl_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    size = _swig_property(_ida_hexrays.vivl_t_size_get, _ida_hexrays.vivl_t_size_set)
    def __init__(self, *args):
        """
        __init__(self, _type=mop_z, _off=-1, _size=0) -> vivl_t
        __init__(self, ch) -> vivl_t
        __init__(self, op) -> vivl_t
        """
        this = _ida_hexrays.new_vivl_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """
        set(self, _type, _off, _size=0)
        set(self, voff, _size)
        """
        return _ida_hexrays.vivl_t_set(self, *args)

    def set_stkoff(self, *args):
        """
        set_stkoff(self, stkoff, sz=0)
        """
        return _ida_hexrays.vivl_t_set_stkoff(self, *args)

    def set_reg(self, *args):
        """
        set_reg(self, mreg, sz=0)
        """
        return _ida_hexrays.vivl_t_set_reg(self, *args)

    def extend_to_cover(self, *args):
        """
        extend_to_cover(self, r) -> bool
        """
        return _ida_hexrays.vivl_t_extend_to_cover(self, *args)

    def intersect(self, *args):
        """
        intersect(self, r) -> uval_t
        """
        return _ida_hexrays.vivl_t_intersect(self, *args)

    def overlap(self, *args):
        """
        overlap(self, r) -> bool
        """
        return _ida_hexrays.vivl_t_overlap(self, *args)

    def includes(self, *args):
        """
        includes(self, r) -> bool
        """
        return _ida_hexrays.vivl_t_includes(self, *args)

    def contains(self, *args):
        """
        contains(self, voff2) -> bool
        """
        return _ida_hexrays.vivl_t_contains(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.vivl_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.vivl_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.vivl_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.vivl_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.vivl_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.vivl_t_compare(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        __eq__(self, mop) -> bool
        """
        return _ida_hexrays.vivl_t___eq__(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.vivl_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.vivl_t_dstr(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vivl_t
    __del__ = lambda self : None;
vivl_t_swigregister = _ida_hexrays.vivl_t_swigregister
vivl_t_swigregister(vivl_t)

class chain_t(ida_pro.intvec_t):
    """
    Proxy of C++ chain_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    width = _swig_property(_ida_hexrays.chain_t_width_get, _ida_hexrays.chain_t_width_set)
    varnum = _swig_property(_ida_hexrays.chain_t_varnum_get, _ida_hexrays.chain_t_varnum_set)
    flags = _swig_property(_ida_hexrays.chain_t_flags_get, _ida_hexrays.chain_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> chain_t
        __init__(self, t, off, w=1, v=-1) -> chain_t
        __init__(self, _k, w=1) -> chain_t
        """
        this = _ida_hexrays.new_chain_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_value(self, *args):
        """
        set_value(self, r)
        """
        return _ida_hexrays.chain_t_set_value(self, *args)

    def key(self, *args):
        """
        key(self) -> voff_t
        """
        return _ida_hexrays.chain_t_key(self, *args)

    def is_inited(self, *args):
        """
        is_inited(self) -> bool
        """
        return _ida_hexrays.chain_t_is_inited(self, *args)

    def is_reg(self, *args):
        """
        is_reg(self) -> bool
        """
        return _ida_hexrays.chain_t_is_reg(self, *args)

    def is_stkoff(self, *args):
        """
        is_stkoff(self) -> bool
        """
        return _ida_hexrays.chain_t_is_stkoff(self, *args)

    def is_replaced(self, *args):
        """
        is_replaced(self) -> bool
        """
        return _ida_hexrays.chain_t_is_replaced(self, *args)

    def is_overlapped(self, *args):
        """
        is_overlapped(self) -> bool
        """
        return _ida_hexrays.chain_t_is_overlapped(self, *args)

    def is_fake(self, *args):
        """
        is_fake(self) -> bool
        """
        return _ida_hexrays.chain_t_is_fake(self, *args)

    def is_passreg(self, *args):
        """
        is_passreg(self) -> bool
        """
        return _ida_hexrays.chain_t_is_passreg(self, *args)

    def is_term(self, *args):
        """
        is_term(self) -> bool
        """
        return _ida_hexrays.chain_t_is_term(self, *args)

    def set_inited(self, *args):
        """
        set_inited(self, b)
        """
        return _ida_hexrays.chain_t_set_inited(self, *args)

    def set_replaced(self, *args):
        """
        set_replaced(self, b)
        """
        return _ida_hexrays.chain_t_set_replaced(self, *args)

    def set_overlapped(self, *args):
        """
        set_overlapped(self, b)
        """
        return _ida_hexrays.chain_t_set_overlapped(self, *args)

    def set_term(self, *args):
        """
        set_term(self, b)
        """
        return _ida_hexrays.chain_t_set_term(self, *args)

    def get_reg(self, *args):
        """
        get_reg(self) -> mreg_t
        """
        return _ida_hexrays.chain_t_get_reg(self, *args)

    def get_stkoff(self, *args):
        """
        get_stkoff(self) -> sval_t
        """
        return _ida_hexrays.chain_t_get_stkoff(self, *args)

    def overlap(self, *args):
        """
        overlap(self, r) -> bool
        """
        return _ida_hexrays.chain_t_overlap(self, *args)

    def includes(self, *args):
        """
        includes(self, r) -> bool
        """
        return _ida_hexrays.chain_t_includes(self, *args)

    def endoff(self, *args):
        """
        endoff(self) -> voff_t
        """
        return _ida_hexrays.chain_t_endoff(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.chain_t___lt__(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.chain_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.chain_t_dstr(self, *args)

    def append_list(self, *args):
        """
        append_list(self, list)
        """
        return _ida_hexrays.chain_t_append_list(self, *args)

    def clear_varnum(self, *args):
        """
        clear_varnum(self)
        """
        return _ida_hexrays.chain_t_clear_varnum(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_chain_t
    __del__ = lambda self : None;
chain_t_swigregister = _ida_hexrays.chain_t_swigregister
chain_t_swigregister(chain_t)
CHF_INITED = _ida_hexrays.CHF_INITED
"""
is chain initialized? (valid only after lvar allocation)
"""
CHF_REPLACED = _ida_hexrays.CHF_REPLACED
"""
chain operands have been replaced?
"""
CHF_OVER = _ida_hexrays.CHF_OVER
"""
overlapped chain
"""
CHF_FAKE = _ida_hexrays.CHF_FAKE
"""
fake chain created by widen_chains()
"""
CHF_PASSTHRU = _ida_hexrays.CHF_PASSTHRU
"""
pass-thru chain, must use the input variable to the block
"""
CHF_TERM = _ida_hexrays.CHF_TERM
"""
terminating chain; the variable does not survive across the block
"""

SIZEOF_BLOCK_CHAINS = _ida_hexrays.SIZEOF_BLOCK_CHAINS
class block_chains_t(object):
    """
    Proxy of C++ block_chains_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def get_reg_chain(self, *args):
        """
        get_reg_chain(self, reg, width=1) -> chain_t
        get_reg_chain(self, reg, width=1) -> chain_t
        """
        return _ida_hexrays.block_chains_t_get_reg_chain(self, *args)

    def get_stk_chain(self, *args):
        """
        get_stk_chain(self, off, width=1) -> chain_t
        get_stk_chain(self, off, width=1) -> chain_t
        """
        return _ida_hexrays.block_chains_t_get_stk_chain(self, *args)

    def get_chain(self, *args):
        """
        get_chain(self, k, width=1) -> chain_t
        get_chain(self, k, width=1) -> chain_t
        get_chain(self, ch) -> chain_t
        get_chain(self, ch) -> chain_t
        """
        return _ida_hexrays.block_chains_t_get_chain(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.block_chains_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.block_chains_t_dstr(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> block_chains_t
        """
        this = _ida_hexrays.new_block_chains_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_block_chains_t
    __del__ = lambda self : None;
block_chains_t_swigregister = _ida_hexrays.block_chains_t_swigregister
block_chains_t_swigregister(block_chains_t)

class chain_visitor_t(object):
    """
    Proxy of C++ chain_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    parent = _swig_property(_ida_hexrays.chain_visitor_t_parent_get, _ida_hexrays.chain_visitor_t_parent_set)
    def __init__(self, *args):
        """
        __init__(self) -> chain_visitor_t
        """
        if self.__class__ == chain_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_chain_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def visit_chain(self, *args):
        """
        visit_chain(self, nblock, ch) -> int
        """
        return _ida_hexrays.chain_visitor_t_visit_chain(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_chain_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_chain_visitor_t(self)
        return weakref_proxy(self)
chain_visitor_t_swigregister = _ida_hexrays.chain_visitor_t_swigregister
chain_visitor_t_swigregister(chain_visitor_t)

class graph_chains_t(block_chains_vec_t):
    """
    Proxy of C++ graph_chains_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> graph_chains_t
        """
        this = _ida_hexrays.new_graph_chains_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_graph_chains_t
    __del__ = lambda self : None;
    def for_all_chains(self, *args):
        """
        for_all_chains(self, cv, gca_flags) -> int
        """
        return _ida_hexrays.graph_chains_t_for_all_chains(self, *args)

    def is_locked(self, *args):
        """
        is_locked(self) -> bool
        """
        return _ida_hexrays.graph_chains_t_is_locked(self, *args)

    def acquire(self, *args):
        """
        acquire(self)
        """
        return _ida_hexrays.graph_chains_t_acquire(self, *args)

    def release(self, *args):
        """
        release(self)
        """
        return _ida_hexrays.graph_chains_t_release(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.graph_chains_t_swap(self, *args)

graph_chains_t_swigregister = _ida_hexrays.graph_chains_t_swigregister
graph_chains_t_swigregister(graph_chains_t)
GCA_EMPTY = _ida_hexrays.GCA_EMPTY
"""
include empty chains
"""
GCA_SPEC = _ida_hexrays.GCA_SPEC
"""
include chains for special registers
"""
GCA_ALLOC = _ida_hexrays.GCA_ALLOC
"""
enumerate only allocated chains
"""
GCA_NALLOC = _ida_hexrays.GCA_NALLOC
"""
enumerate only non-allocated chains
"""
GCA_OFIRST = _ida_hexrays.GCA_OFIRST
"""
consider only chains of the first block
"""
GCA_OLAST = _ida_hexrays.GCA_OLAST
"""
consider only chains of the last block
"""

class minsn_t(object):
    """
    Proxy of C++ minsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    opcode = _swig_property(_ida_hexrays.minsn_t_opcode_get, _ida_hexrays.minsn_t_opcode_set)
    iprops = _swig_property(_ida_hexrays.minsn_t_iprops_get, _ida_hexrays.minsn_t_iprops_set)
    next = _swig_property(_ida_hexrays.minsn_t_next_get, _ida_hexrays.minsn_t_next_set)
    prev = _swig_property(_ida_hexrays.minsn_t_prev_get, _ida_hexrays.minsn_t_prev_set)
    ea = _swig_property(_ida_hexrays.minsn_t_ea_get, _ida_hexrays.minsn_t_ea_set)
    l = _swig_property(_ida_hexrays.minsn_t_l_get, _ida_hexrays.minsn_t_l_set)
    r = _swig_property(_ida_hexrays.minsn_t_r_get, _ida_hexrays.minsn_t_r_set)
    d = _swig_property(_ida_hexrays.minsn_t_d_get, _ida_hexrays.minsn_t_d_set)
    def is_optional(self, *args):
        """
        is_optional(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_optional(self, *args)

    def is_combined(self, *args):
        """
        is_combined(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_combined(self, *args)

    def is_farcall(self, *args):
        """
        is_farcall(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_farcall(self, *args)

    def is_cleaning_pop(self, *args):
        """
        is_cleaning_pop(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_cleaning_pop(self, *args)

    def is_extstx(self, *args):
        """
        is_extstx(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_extstx(self, *args)

    def is_tailcall(self, *args):
        """
        is_tailcall(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_tailcall(self, *args)

    def is_fpinsn(self, *args):
        """
        is_fpinsn(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_fpinsn(self, *args)

    def is_assert(self, *args):
        """
        is_assert(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_assert(self, *args)

    def is_persistent(self, *args):
        """
        is_persistent(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_persistent(self, *args)

    def is_wild_match(self, *args):
        """
        is_wild_match(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_wild_match(self, *args)

    def is_propagatable(self, *args):
        """
        is_propagatable(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_propagatable(self, *args)

    def is_ignlowsrc(self, *args):
        """
        is_ignlowsrc(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_ignlowsrc(self, *args)

    def is_inverted_jx(self, *args):
        """
        is_inverted_jx(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_inverted_jx(self, *args)

    def was_noret_icall(self, *args):
        """
        was_noret_icall(self) -> bool
        """
        return _ida_hexrays.minsn_t_was_noret_icall(self, *args)

    def is_multimov(self, *args):
        """
        is_multimov(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_multimov(self, *args)

    def is_combinable(self, *args):
        """
        is_combinable(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_combinable(self, *args)

    def was_split(self, *args):
        """
        was_split(self) -> bool
        """
        return _ida_hexrays.minsn_t_was_split(self, *args)

    def set_optional(self, *args):
        """
        set_optional(self)
        """
        return _ida_hexrays.minsn_t_set_optional(self, *args)

    def clr_combined(self, *args):
        """
        clr_combined(self)
        """
        return _ida_hexrays.minsn_t_clr_combined(self, *args)

    def set_farcall(self, *args):
        """
        set_farcall(self)
        """
        return _ida_hexrays.minsn_t_set_farcall(self, *args)

    def set_cleaning_pop(self, *args):
        """
        set_cleaning_pop(self)
        """
        return _ida_hexrays.minsn_t_set_cleaning_pop(self, *args)

    def set_extstx(self, *args):
        """
        set_extstx(self)
        """
        return _ida_hexrays.minsn_t_set_extstx(self, *args)

    def set_tailcall(self, *args):
        """
        set_tailcall(self)
        """
        return _ida_hexrays.minsn_t_set_tailcall(self, *args)

    def clr_tailcall(self, *args):
        """
        clr_tailcall(self)
        """
        return _ida_hexrays.minsn_t_clr_tailcall(self, *args)

    def set_fpinsn(self, *args):
        """
        set_fpinsn(self)
        """
        return _ida_hexrays.minsn_t_set_fpinsn(self, *args)

    def clr_fpinsn(self, *args):
        """
        clr_fpinsn(self)
        """
        return _ida_hexrays.minsn_t_clr_fpinsn(self, *args)

    def set_assert(self, *args):
        """
        set_assert(self)
        """
        return _ida_hexrays.minsn_t_set_assert(self, *args)

    def clr_assert(self, *args):
        """
        clr_assert(self)
        """
        return _ida_hexrays.minsn_t_clr_assert(self, *args)

    def set_persistent(self, *args):
        """
        set_persistent(self)
        """
        return _ida_hexrays.minsn_t_set_persistent(self, *args)

    def set_wild_match(self, *args):
        """
        set_wild_match(self)
        """
        return _ida_hexrays.minsn_t_set_wild_match(self, *args)

    def clr_propagatable(self, *args):
        """
        clr_propagatable(self)
        """
        return _ida_hexrays.minsn_t_clr_propagatable(self, *args)

    def set_ignlowsrc(self, *args):
        """
        set_ignlowsrc(self)
        """
        return _ida_hexrays.minsn_t_set_ignlowsrc(self, *args)

    def clr_ignlowsrc(self, *args):
        """
        clr_ignlowsrc(self)
        """
        return _ida_hexrays.minsn_t_clr_ignlowsrc(self, *args)

    def set_inverted_jx(self, *args):
        """
        set_inverted_jx(self)
        """
        return _ida_hexrays.minsn_t_set_inverted_jx(self, *args)

    def set_noret_icall(self, *args):
        """
        set_noret_icall(self)
        """
        return _ida_hexrays.minsn_t_set_noret_icall(self, *args)

    def clr_noret_icall(self, *args):
        """
        clr_noret_icall(self)
        """
        return _ida_hexrays.minsn_t_clr_noret_icall(self, *args)

    def set_multimov(self, *args):
        """
        set_multimov(self)
        """
        return _ida_hexrays.minsn_t_set_multimov(self, *args)

    def clr_multimov(self, *args):
        """
        clr_multimov(self)
        """
        return _ida_hexrays.minsn_t_clr_multimov(self, *args)

    def set_combinable(self, *args):
        """
        set_combinable(self)
        """
        return _ida_hexrays.minsn_t_set_combinable(self, *args)

    def clr_combinable(self, *args):
        """
        clr_combinable(self)
        """
        return _ida_hexrays.minsn_t_clr_combinable(self, *args)

    def set_split_size(self, *args):
        """
        set_split_size(self, s)
        """
        return _ida_hexrays.minsn_t_set_split_size(self, *args)

    def get_split_size(self, *args):
        """
        get_split_size(self) -> int
        """
        return _ida_hexrays.minsn_t_get_split_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self, _ea) -> minsn_t
        __init__(self, m) -> minsn_t
        """
        this = _ida_hexrays.new_minsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, m)
        """
        return _ida_hexrays.minsn_t_swap(self, *args)

    def _print(self, *args):
        """
        _print(self, shins_flags=0x04|0x02)
        """
        return _ida_hexrays.minsn_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_hexrays.minsn_t_dstr(self, *args)

    def setaddr(self, *args):
        """
        setaddr(self, new_ea)
        """
        return _ida_hexrays.minsn_t_setaddr(self, *args)

    def optimize_solo(self, *args):
        """
        optimize_solo(self, optflags=0) -> int
        """
        return _ida_hexrays.minsn_t_optimize_solo(self, *args)

    def optimize_subtree(self, *args):
        """
        optimize_subtree(self, blk, top, parent, converted_call, optflags=0x0002) -> int
        """
        return _ida_hexrays.minsn_t_optimize_subtree(self, *args)

    def for_all_ops(self, *args):
        """
        for_all_ops(self, mv) -> int
        """
        return _ida_hexrays.minsn_t_for_all_ops(self, *args)

    def for_all_insns(self, *args):
        """
        for_all_insns(self, mv) -> int
        """
        return _ida_hexrays.minsn_t_for_all_insns(self, *args)

    def _make_nop(self, *args):
        """
        _make_nop(self)
        """
        return _ida_hexrays.minsn_t__make_nop(self, *args)

    def equal_insns(self, *args):
        """
        equal_insns(self, m, eqflags) -> bool
        """
        return _ida_hexrays.minsn_t_equal_insns(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, ri) -> bool
        """
        return _ida_hexrays.minsn_t___lt__(self, *args)

    def lexcompare(self, *args):
        """
        lexcompare(self, ri) -> int
        """
        return _ida_hexrays.minsn_t_lexcompare(self, *args)

    def is_noret_call(self, *args):
        """
        is_noret_call(self, ignore_noret_icall=False) -> bool
        """
        return _ida_hexrays.minsn_t_is_noret_call(self, *args)

    def is_unknown_call(self, *args):
        """
        is_unknown_call(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_unknown_call(self, *args)

    def is_helper(self, *args):
        """
        is_helper(self, name) -> bool
        """
        return _ida_hexrays.minsn_t_is_helper(self, *args)

    def find_call(self, *args):
        """
        find_call(self, with_helpers=False) -> minsn_t
        """
        return _ida_hexrays.minsn_t_find_call(self, *args)

    def contains_call(self, *args):
        """
        contains_call(self, with_helpers=False) -> bool
        """
        return _ida_hexrays.minsn_t_contains_call(self, *args)

    def has_side_effects(self, *args):
        """
        has_side_effects(self, include_ldx_and_divs=False) -> bool
        """
        return _ida_hexrays.minsn_t_has_side_effects(self, *args)

    def get_role(self, *args):
        """
        get_role(self) -> funcrole_t
        """
        return _ida_hexrays.minsn_t_get_role(self, *args)

    def is_memcpy(self, *args):
        """
        is_memcpy(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_memcpy(self, *args)

    def is_memset(self, *args):
        """
        is_memset(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_memset(self, *args)

    def is_alloca(self, *args):
        """
        is_alloca(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_alloca(self, *args)

    def is_bswap(self, *args):
        """
        is_bswap(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_bswap(self, *args)

    def is_readflags(self, *args):
        """
        is_readflags(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_readflags(self, *args)

    def contains_opcode(self, *args):
        """
        contains_opcode(self, mcode) -> bool
        """
        return _ida_hexrays.minsn_t_contains_opcode(self, *args)

    def find_opcode(self, *args):
        """
        find_opcode(self, mcode) -> minsn_t
        find_opcode(self, mcode) -> minsn_t
        """
        return _ida_hexrays.minsn_t_find_opcode(self, *args)

    def find_ins_op(self, *args):
        """
        find_ins_op(self, other, op=m_nop) -> minsn_t
        """
        return _ida_hexrays.minsn_t_find_ins_op(self, *args)

    def find_num_op(self, *args):
        """
        find_num_op(self, other) -> mop_t
        """
        return _ida_hexrays.minsn_t_find_num_op(self, *args)

    def is_mov(self, *args):
        """
        is_mov(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_mov(self, *args)

    def is_like_move(self, *args):
        """
        is_like_move(self) -> bool
        """
        return _ida_hexrays.minsn_t_is_like_move(self, *args)

    def modifes_d(self, *args):
        """
        modifes_d(self) -> bool
        """
        return _ida_hexrays.minsn_t_modifes_d(self, *args)

    def modifies_pair_mop(self, *args):
        """
        modifies_pair_mop(self) -> bool
        """
        return _ida_hexrays.minsn_t_modifies_pair_mop(self, *args)

    def is_between(self, *args):
        """
        is_between(self, m1, m2) -> bool
        """
        return _ida_hexrays.minsn_t_is_between(self, *args)

    def is_after(self, *args):
        """
        is_after(self, m) -> bool
        """
        return _ida_hexrays.minsn_t_is_after(self, *args)

    def may_use_aliased_memory(self, *args):
        """
        may_use_aliased_memory(self) -> bool
        """
        return _ida_hexrays.minsn_t_may_use_aliased_memory(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.minsn_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.minsn_t__deregister(self, *args)

    def __dbg_get_meminfo(self, *args):
        """
        __dbg_get_meminfo(self) -> qstring
        """
        return _ida_hexrays.minsn_t___dbg_get_meminfo(self, *args)

    def __dbg_get_registered_kind(self, *args):
        """
        __dbg_get_registered_kind(self) -> int
        """
        return _ida_hexrays.minsn_t___dbg_get_registered_kind(self, *args)

    def _obj_id(self, *args):
        """
        _obj_id(self) -> PyObject *
        """
        return _ida_hexrays.minsn_t__obj_id(self, *args)

    obj_id = property(_obj_id)

    def _ensure_cond(self, ok, cond_str):
        if not ok:
            raise Exception("Condition \"%s\" not verified" % cond_str)
        return True

    def _ensure_no_obj(self, o, attr, attr_is_acquired):
        if attr_is_acquired and o is not None:
            raise Exception("%s already owns attribute \"%s\" (%s); cannot be modified" % (self, attr, o))
        return True

    def _acquire_ownership(self, v, acquire):
        if acquire and (v is not None) and not isinstance(v, (int, long)):
            if not v.thisown:
                raise Exception("%s is already owned, and cannot be reused" % v)
            v.thisown = False
            dereg = getattr(v, "_deregister", None)
            if dereg:
                dereg()
        return True

    def _maybe_disown_and_deregister(self):
        if self.thisown:
            self.thisown = False
            self._deregister()

    def _own_and_register(self):
        assert(not self.thisown)
        self.thisown = True
        self._register()

    def replace_by(self, o):
        assert(isinstance(o, (cexpr_t, cinsn_t)))
        o._maybe_disown_and_deregister()
        self._replace_by(o)

    def _meminfo(self):
        cpp = self.__dbg_get_meminfo()
        rkind = self.__dbg_get_registered_kind()
        rkind_str = [
                "(not owned)",
                "cfuncptr_t",
                "cinsn_t",
                "cexpr_t",
                "cblock_t",
                "mbl_array_t",
                "mop_t",
                "minsn_t",
                "optinsn_t",
                "optblock_t",
                "valrng_t"][rkind]
        return "%s [thisown=%s, owned by IDAPython as=%s]" % (
                cpp,
                self.thisown,
                rkind_str)
    meminfo = property(_meminfo)

    __swig_destroy__ = _ida_hexrays.delete_minsn_t
    __del__ = lambda self : None;
minsn_t_swigregister = _ida_hexrays.minsn_t_swigregister
minsn_t_swigregister(minsn_t)
IPROP_OPTIONAL = _ida_hexrays.IPROP_OPTIONAL
"""
optional instruction
"""
IPROP_PERSIST = _ida_hexrays.IPROP_PERSIST
"""
persistent insn; they are not destroyed
"""
IPROP_WILDMATCH = _ida_hexrays.IPROP_WILDMATCH
"""
match multiple insns
"""
IPROP_CLNPOP = _ida_hexrays.IPROP_CLNPOP
"""
(e.g. "pop ecx" is often used for that)

the purpose of the instruction is to clean stack
"""
IPROP_FPINSN = _ida_hexrays.IPROP_FPINSN
"""
floating point insn
"""
IPROP_FARCALL = _ida_hexrays.IPROP_FARCALL
"""
call of a far function using push cs/call sequence
"""
IPROP_TAILCALL = _ida_hexrays.IPROP_TAILCALL
"""
tail call
"""
IPROP_ASSERT = _ida_hexrays.IPROP_ASSERT
"""
assertion: usually mov #val, op. assertions are used to help the
optimizer. assertions are ignored when generating ctree
"""
IPROP_SPLIT = _ida_hexrays.IPROP_SPLIT
"""
the instruction has been split:
"""
IPROP_SPLIT1 = _ida_hexrays.IPROP_SPLIT1
"""
into 1 byte
"""
IPROP_SPLIT2 = _ida_hexrays.IPROP_SPLIT2
"""
into 2 bytes
"""
IPROP_SPLIT4 = _ida_hexrays.IPROP_SPLIT4
"""
into 4 bytes
"""
IPROP_SPLIT8 = _ida_hexrays.IPROP_SPLIT8
"""
into 8 bytes
"""
IPROP_COMBINED = _ida_hexrays.IPROP_COMBINED
"""
insn has been modified because of a partial reference
"""
IPROP_EXTSTX = _ida_hexrays.IPROP_EXTSTX
"""
this is m_ext propagated into m_stx
"""
IPROP_IGNLOWSRC = _ida_hexrays.IPROP_IGNLOWSRC
"""
low part of the instruction source operand has been created
artificially (this bit is used only for 'and x, 80...')
"""
IPROP_INV_JX = _ida_hexrays.IPROP_INV_JX
"""
inverted conditional jump
"""
IPROP_WAS_NORET = _ida_hexrays.IPROP_WAS_NORET
"""
was noret icall
"""
IPROP_MULTI_MOV = _ida_hexrays.IPROP_MULTI_MOV
"""
(example: STM on ARM may transfer multiple registers)

the minsn was generated as part of insn that moves multiple
registersbits that can be set by plugins:
"""
IPROP_DONT_PROP = _ida_hexrays.IPROP_DONT_PROP
"""
may not propagate
"""
IPROP_DONT_COMB = _ida_hexrays.IPROP_DONT_COMB
"""
may not combine this instruction with others
"""
OPTI_ADDREXPRS = _ida_hexrays.OPTI_ADDREXPRS
"""
optimize all address expressions (&x+N; &x-&y)
"""
OPTI_MINSTKREF = _ida_hexrays.OPTI_MINSTKREF
"""
may update minstkref
"""
OPTI_COMBINSNS = _ida_hexrays.OPTI_COMBINSNS
"""
may combine insns (only for optimize_insn)
"""
OPTI_NO_LDXOPT = _ida_hexrays.OPTI_NO_LDXOPT
"""
do not optimize low/high(ldx)
"""
EQ_IGNSIZE = _ida_hexrays.EQ_IGNSIZE
"""
ignore operand sizes
"""
EQ_IGNCODE = _ida_hexrays.EQ_IGNCODE
"""
ignore instruction opcodes
"""
EQ_CMPDEST = _ida_hexrays.EQ_CMPDEST
"""
compare instruction destinations
"""
EQ_OPTINSN = _ida_hexrays.EQ_OPTINSN
"""
optimize mop_d operands
"""


def getf_reginsn(*args):
  """
  getf_reginsn(ins) -> minsn_t


  Skip assertions forward.
  
  
  @param ins (C++: const  minsn_t  *)
  """
  return _ida_hexrays.getf_reginsn(*args)

def getb_reginsn(*args):
  """
  getb_reginsn(ins) -> minsn_t


  Skip assertions backward.
  
  
  @param ins (C++: const  minsn_t  *)
  """
  return _ida_hexrays.getb_reginsn(*args)
BLT_NONE = _ida_hexrays.BLT_NONE
BLT_STOP = _ida_hexrays.BLT_STOP
BLT_0WAY = _ida_hexrays.BLT_0WAY
BLT_1WAY = _ida_hexrays.BLT_1WAY
BLT_2WAY = _ida_hexrays.BLT_2WAY
BLT_NWAY = _ida_hexrays.BLT_NWAY
BLT_XTRN = _ida_hexrays.BLT_XTRN
class mblock_t(object):
    """
    Proxy of C++ mblock_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    nextb = _swig_property(_ida_hexrays.mblock_t_nextb_get, _ida_hexrays.mblock_t_nextb_set)
    prevb = _swig_property(_ida_hexrays.mblock_t_prevb_get, _ida_hexrays.mblock_t_prevb_set)
    flags = _swig_property(_ida_hexrays.mblock_t_flags_get, _ida_hexrays.mblock_t_flags_set)
    start = _swig_property(_ida_hexrays.mblock_t_start_get, _ida_hexrays.mblock_t_start_set)
    end = _swig_property(_ida_hexrays.mblock_t_end_get, _ida_hexrays.mblock_t_end_set)
    head = _swig_property(_ida_hexrays.mblock_t_head_get, _ida_hexrays.mblock_t_head_set)
    tail = _swig_property(_ida_hexrays.mblock_t_tail_get, _ida_hexrays.mblock_t_tail_set)
    mba = _swig_property(_ida_hexrays.mblock_t_mba_get, _ida_hexrays.mblock_t_mba_set)
    serial = _swig_property(_ida_hexrays.mblock_t_serial_get, _ida_hexrays.mblock_t_serial_set)
    type = _swig_property(_ida_hexrays.mblock_t_type_get, _ida_hexrays.mblock_t_type_set)
    dead_at_start = _swig_property(_ida_hexrays.mblock_t_dead_at_start_get, _ida_hexrays.mblock_t_dead_at_start_set)
    mustbuse = _swig_property(_ida_hexrays.mblock_t_mustbuse_get, _ida_hexrays.mblock_t_mustbuse_set)
    maybuse = _swig_property(_ida_hexrays.mblock_t_maybuse_get, _ida_hexrays.mblock_t_maybuse_set)
    mustbdef = _swig_property(_ida_hexrays.mblock_t_mustbdef_get, _ida_hexrays.mblock_t_mustbdef_set)
    maybdef = _swig_property(_ida_hexrays.mblock_t_maybdef_get, _ida_hexrays.mblock_t_maybdef_set)
    dnu = _swig_property(_ida_hexrays.mblock_t_dnu_get, _ida_hexrays.mblock_t_dnu_set)
    maxbsp = _swig_property(_ida_hexrays.mblock_t_maxbsp_get, _ida_hexrays.mblock_t_maxbsp_set)
    minbstkref = _swig_property(_ida_hexrays.mblock_t_minbstkref_get, _ida_hexrays.mblock_t_minbstkref_set)
    minbargref = _swig_property(_ida_hexrays.mblock_t_minbargref_get, _ida_hexrays.mblock_t_minbargref_set)
    predset = _swig_property(_ida_hexrays.mblock_t_predset_get, _ida_hexrays.mblock_t_predset_set)
    succset = _swig_property(_ida_hexrays.mblock_t_succset_get, _ida_hexrays.mblock_t_succset_set)
    def mark_lists_dirty(self, *args):
        """
        mark_lists_dirty(self)
        """
        return _ida_hexrays.mblock_t_mark_lists_dirty(self, *args)

    def request_propagation(self, *args):
        """
        request_propagation(self)
        """
        return _ida_hexrays.mblock_t_request_propagation(self, *args)

    def needs_propagation(self, *args):
        """
        needs_propagation(self) -> bool
        """
        return _ida_hexrays.mblock_t_needs_propagation(self, *args)

    def request_demote64(self, *args):
        """
        request_demote64(self)
        """
        return _ida_hexrays.mblock_t_request_demote64(self, *args)

    def lists_dirty(self, *args):
        """
        lists_dirty(self) -> bool
        """
        return _ida_hexrays.mblock_t_lists_dirty(self, *args)

    def lists_ready(self, *args):
        """
        lists_ready(self) -> bool
        """
        return _ida_hexrays.mblock_t_lists_ready(self, *args)

    def make_lists_ready(self, *args):
        """
        make_lists_ready(self) -> int
        """
        return _ida_hexrays.mblock_t_make_lists_ready(self, *args)

    def npred(self, *args):
        """
        npred(self) -> int
        """
        return _ida_hexrays.mblock_t_npred(self, *args)

    def nsucc(self, *args):
        """
        nsucc(self) -> int
        """
        return _ida_hexrays.mblock_t_nsucc(self, *args)

    def pred(self, *args):
        """
        pred(self, n) -> int
        """
        return _ida_hexrays.mblock_t_pred(self, *args)

    def succ(self, *args):
        """
        succ(self, n) -> int
        """
        return _ida_hexrays.mblock_t_succ(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mblock_t
    __del__ = lambda self : None;
    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mblock_t_empty(self, *args)

    def _print(self, *args):
        """
        _print(self, vp)
        """
        return _ida_hexrays.mblock_t__print(self, *args)

    def dump(self, *args):
        """
        dump(self)
        """
        return _ida_hexrays.mblock_t_dump(self, *args)

    def dump_block(self, *args):
        """
        dump_block(self, title)
        """
        return _ida_hexrays.mblock_t_dump_block(self, *args)

    def insert_into_block(self, *args):
        """
        insert_into_block(self, nm, om) -> minsn_t
        """
        val = _ida_hexrays.mblock_t_insert_into_block(self, *args)
        mn = args[0]
        mn._maybe_disown_and_deregister()


        return val

    def remove_from_block(self, *args):
        """
        remove_from_block(self, m) -> minsn_t
        """
        mn = args[0]


        val = _ida_hexrays.mblock_t_remove_from_block(self, *args)
        if mn:
          mn._own_and_register()


        return val

    def for_all_insns(self, *args):
        """
        for_all_insns(self, mv) -> int
        """
        return _ida_hexrays.mblock_t_for_all_insns(self, *args)

    def for_all_ops(self, *args):
        """
        for_all_ops(self, mv) -> int
        """
        return _ida_hexrays.mblock_t_for_all_ops(self, *args)

    def for_all_uses(self, *args):
        """
        for_all_uses(self, list, i1, i2, mmv) -> int
        """
        return _ida_hexrays.mblock_t_for_all_uses(self, *args)

    def optimize_insn(self, *args):
        """
        optimize_insn(self, m, optflags=0x0002|0x0004) -> int
        """
        return _ida_hexrays.mblock_t_optimize_insn(self, *args)

    def optimize_block(self, *args):
        """
        optimize_block(self) -> int
        """
        return _ida_hexrays.mblock_t_optimize_block(self, *args)

    def build_lists(self, *args):
        """
        build_lists(self, kill_deads) -> int
        """
        return _ida_hexrays.mblock_t_build_lists(self, *args)

    def optimize_useless_jump(self, *args):
        """
        optimize_useless_jump(self) -> int
        """
        return _ida_hexrays.mblock_t_optimize_useless_jump(self, *args)

    def append_use_list(self, *args):
        """
        append_use_list(self, list, op, maymust, mask=bitrange_t(0, USHRT_MAX))
        """
        return _ida_hexrays.mblock_t_append_use_list(self, *args)

    def append_def_list(self, *args):
        """
        append_def_list(self, list, op, maymust)
        """
        return _ida_hexrays.mblock_t_append_def_list(self, *args)

    def build_use_list(self, *args):
        """
        build_use_list(self, ins, maymust) -> mlist_t
        """
        return _ida_hexrays.mblock_t_build_use_list(self, *args)

    def build_def_list(self, *args):
        """
        build_def_list(self, ins, maymust) -> mlist_t
        """
        return _ida_hexrays.mblock_t_build_def_list(self, *args)

    def is_used(self, *args):
        """
        is_used(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
        """
        return _ida_hexrays.mblock_t_is_used(self, *args)

    def find_first_use(self, *args):
        """
        find_first_use(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
        """
        return _ida_hexrays.mblock_t_find_first_use(self, *args)

    def is_redefined(self, *args):
        """
        is_redefined(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
        """
        return _ida_hexrays.mblock_t_is_redefined(self, *args)

    def find_redefinition(self, *args):
        """
        find_redefinition(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
        """
        return _ida_hexrays.mblock_t_find_redefinition(self, *args)

    def is_rhs_redefined(self, *args):
        """
        is_rhs_redefined(self, ins, i1, i2) -> bool
        """
        return _ida_hexrays.mblock_t_is_rhs_redefined(self, *args)

    def find_access(self, *args):
        """
        find_access(self, op, parent, mend, fdflags) -> minsn_t
        """
        return _ida_hexrays.mblock_t_find_access(self, *args)

    def find_def(self, *args):
        """
        find_def(self, op, p_i1, i2, fdflags) -> minsn_t
        """
        return _ida_hexrays.mblock_t_find_def(self, *args)

    def find_use(self, *args):
        """
        find_use(self, op, p_i1, i2, fdflags) -> minsn_t
        """
        return _ida_hexrays.mblock_t_find_use(self, *args)

    def get_valranges(self, *args):
        """
        get_valranges(self, res, vivl, vrflags) -> bool
        get_valranges(self, res, vivl, m, vrflags) -> bool
        """
        return _ida_hexrays.mblock_t_get_valranges(self, *args)

    def make_nop(self, *args):
        """
        make_nop(self, m)
        """
        return _ida_hexrays.mblock_t_make_nop(self, *args)

    def get_reginsn_qty(self, *args):
        """
        get_reginsn_qty(self) -> size_t
        """
        return _ida_hexrays.mblock_t_get_reginsn_qty(self, *args)

    def is_call_block(self, *args):
        """
        is_call_block(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_call_block(self, *args)

    def is_unknown_call(self, *args):
        """
        is_unknown_call(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_unknown_call(self, *args)

    def is_nway(self, *args):
        """
        is_nway(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_nway(self, *args)

    def is_branch(self, *args):
        """
        is_branch(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_branch(self, *args)

    def is_simple_goto_block(self, *args):
        """
        is_simple_goto_block(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_simple_goto_block(self, *args)

    def is_simple_jcnd_block(self, *args):
        """
        is_simple_jcnd_block(self) -> bool
        """
        return _ida_hexrays.mblock_t_is_simple_jcnd_block(self, *args)

    def preds(self):
        """
        Iterates the list of predecessor blocks
        """
        for ser in self.predset:
            yield self.mba.get_mblock(ser)

    def succs(self):
        """
        Iterates the list of successor blocks
        """
        for ser in self.succset:
            yield self.mba.get_mblock(ser)

mblock_t_swigregister = _ida_hexrays.mblock_t_swigregister
mblock_t_swigregister(mblock_t)
MBL_PRIV = _ida_hexrays.MBL_PRIV
"""
the specified are accepted (used in patterns)

private block - no instructions except
"""
MBL_NONFAKE = _ida_hexrays.MBL_NONFAKE
"""
regular block
"""
MBL_FAKE = _ida_hexrays.MBL_FAKE
"""
fake block (after a tail call)
"""
MBL_GOTO = _ida_hexrays.MBL_GOTO
"""
this block is a goto target
"""
MBL_TCAL = _ida_hexrays.MBL_TCAL
"""
aritifical call block for tail calls
"""
MBL_PUSH = _ida_hexrays.MBL_PUSH
"""
needs "convert push/pop instructions"
"""
MBL_DMT64 = _ida_hexrays.MBL_DMT64
"""
needs "demote 64bits"
"""
MBL_COMB = _ida_hexrays.MBL_COMB
"""
needs "combine" pass
"""
MBL_PROP = _ida_hexrays.MBL_PROP
"""
needs 'propagation' pass
"""
MBL_DEAD = _ida_hexrays.MBL_DEAD
"""
needs "eliminate deads" pass
"""
MBL_LIST = _ida_hexrays.MBL_LIST
"""
use/def lists are ready (not dirty)
"""
MBL_INCONST = _ida_hexrays.MBL_INCONST
"""
inconsistent lists: we are building them
"""
MBL_CALL = _ida_hexrays.MBL_CALL
"""
call information has been built
"""
MBL_BACKPROP = _ida_hexrays.MBL_BACKPROP
"""
performed backprop_cc
"""
MBL_NORET = _ida_hexrays.MBL_NORET
"""
dead end block: doesn't return execution control
"""
MBL_DSLOT = _ida_hexrays.MBL_DSLOT
"""
block for delay slot
"""
MBL_VALRANGES = _ida_hexrays.MBL_VALRANGES
"""
should optimize using value ranges
"""
FD_BACKWARD = _ida_hexrays.FD_BACKWARD
"""
search direction
"""
FD_FORWARD = _ida_hexrays.FD_FORWARD
"""
search direction
"""
FD_USE = _ida_hexrays.FD_USE
"""
look for use
"""
FD_DEF = _ida_hexrays.FD_DEF
"""
look for definition
"""
FD_DIRTY = _ida_hexrays.FD_DIRTY
"""
by function calls and indirect memory access

ignore possible implicit definitions
"""
VR_AT_START = _ida_hexrays.VR_AT_START
"""
at the block start (if M is NULL)

get value ranges before the instruction or
"""
VR_AT_END = _ida_hexrays.VR_AT_END
"""
get value ranges after the instruction or at the block end, just after
the last instruction (if M is NULL)
"""
VR_EXACT = _ida_hexrays.VR_EXACT
"""
valrng size will be >= vivl.size

find exact match. if not set, the returned
"""

WARN_VARARG_REGS = _ida_hexrays.WARN_VARARG_REGS
WARN_ILL_PURGED = _ida_hexrays.WARN_ILL_PURGED
WARN_ILL_FUNCTYPE = _ida_hexrays.WARN_ILL_FUNCTYPE
WARN_VARARG_TCAL = _ida_hexrays.WARN_VARARG_TCAL
WARN_VARARG_NOSTK = _ida_hexrays.WARN_VARARG_NOSTK
WARN_VARARG_MANY = _ida_hexrays.WARN_VARARG_MANY
WARN_ADDR_OUTARGS = _ida_hexrays.WARN_ADDR_OUTARGS
WARN_DEP_UNK_CALLS = _ida_hexrays.WARN_DEP_UNK_CALLS
WARN_ILL_ELLIPSIS = _ida_hexrays.WARN_ILL_ELLIPSIS
WARN_GUESSED_TYPE = _ida_hexrays.WARN_GUESSED_TYPE
WARN_EXP_LINVAR = _ida_hexrays.WARN_EXP_LINVAR
WARN_WIDEN_CHAINS = _ida_hexrays.WARN_WIDEN_CHAINS
WARN_BAD_PURGED = _ida_hexrays.WARN_BAD_PURGED
WARN_CBUILD_LOOPS = _ida_hexrays.WARN_CBUILD_LOOPS
WARN_NO_SAVE_REST = _ida_hexrays.WARN_NO_SAVE_REST
WARN_ODD_INPUT_REG = _ida_hexrays.WARN_ODD_INPUT_REG
WARN_ODD_ADDR_USE = _ida_hexrays.WARN_ODD_ADDR_USE
WARN_MUST_RET_FP = _ida_hexrays.WARN_MUST_RET_FP
WARN_ILL_FPU_STACK = _ida_hexrays.WARN_ILL_FPU_STACK
WARN_SELFREF_PROP = _ida_hexrays.WARN_SELFREF_PROP
WARN_WOULD_OVERLAP = _ida_hexrays.WARN_WOULD_OVERLAP
WARN_ARRAY_INARG = _ida_hexrays.WARN_ARRAY_INARG
WARN_MAX_ARGS = _ida_hexrays.WARN_MAX_ARGS
WARN_BAD_FIELD_TYPE = _ida_hexrays.WARN_BAD_FIELD_TYPE
WARN_WRITE_CONST = _ida_hexrays.WARN_WRITE_CONST
WARN_BAD_RETVAR = _ida_hexrays.WARN_BAD_RETVAR
WARN_FRAG_LVAR = _ida_hexrays.WARN_FRAG_LVAR
WARN_HUGE_STKOFF = _ida_hexrays.WARN_HUGE_STKOFF
WARN_UNINITED_REG = _ida_hexrays.WARN_UNINITED_REG
WARN_FIXED_MACRO = _ida_hexrays.WARN_FIXED_MACRO
WARN_WRONG_VA_OFF = _ida_hexrays.WARN_WRONG_VA_OFF
WARN_CR_NOFIELD = _ida_hexrays.WARN_CR_NOFIELD
WARN_CR_BADOFF = _ida_hexrays.WARN_CR_BADOFF
WARN_BAD_STROFF = _ida_hexrays.WARN_BAD_STROFF
WARN_BAD_VARSIZE = _ida_hexrays.WARN_BAD_VARSIZE
WARN_UNSUPP_REG = _ida_hexrays.WARN_UNSUPP_REG
WARN_UNALIGNED_ARG = _ida_hexrays.WARN_UNALIGNED_ARG
WARN_BAD_STD_TYPE = _ida_hexrays.WARN_BAD_STD_TYPE
WARN_BAD_CALL_SP = _ida_hexrays.WARN_BAD_CALL_SP
WARN_MISSED_SWITCH = _ida_hexrays.WARN_MISSED_SWITCH
WARN_BAD_SP = _ida_hexrays.WARN_BAD_SP
WARN_BAD_STKPNT = _ida_hexrays.WARN_BAD_STKPNT
WARN_UNDEF_LVAR = _ida_hexrays.WARN_UNDEF_LVAR
WARN_JUMPOUT = _ida_hexrays.WARN_JUMPOUT
WARN_BAD_VALRNG = _ida_hexrays.WARN_BAD_VALRNG
WARN_BAD_SHADOW = _ida_hexrays.WARN_BAD_SHADOW
WARN_MAX = _ida_hexrays.WARN_MAX
class hexwarn_t(object):
    """
    Proxy of C++ hexwarn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.hexwarn_t_ea_get, _ida_hexrays.hexwarn_t_ea_set)
    id = _swig_property(_ida_hexrays.hexwarn_t_id_get, _ida_hexrays.hexwarn_t_id_set)
    text = _swig_property(_ida_hexrays.hexwarn_t_text_get, _ida_hexrays.hexwarn_t_text_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.hexwarn_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> hexwarn_t
        """
        this = _ida_hexrays.new_hexwarn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_hexwarn_t
    __del__ = lambda self : None;
hexwarn_t_swigregister = _ida_hexrays.hexwarn_t_swigregister
hexwarn_t_swigregister(hexwarn_t)

MMAT_ZERO = _ida_hexrays.MMAT_ZERO
MMAT_GENERATED = _ida_hexrays.MMAT_GENERATED
MMAT_PREOPTIMIZED = _ida_hexrays.MMAT_PREOPTIMIZED
MMAT_LOCOPT = _ida_hexrays.MMAT_LOCOPT
MMAT_CALLS = _ida_hexrays.MMAT_CALLS
MMAT_GLBOPT1 = _ida_hexrays.MMAT_GLBOPT1
MMAT_GLBOPT2 = _ida_hexrays.MMAT_GLBOPT2
MMAT_GLBOPT3 = _ida_hexrays.MMAT_GLBOPT3
MMAT_LVARS = _ida_hexrays.MMAT_LVARS
MMIDX_GLBLOW = _ida_hexrays.MMIDX_GLBLOW
MMIDX_LVARS = _ida_hexrays.MMIDX_LVARS
MMIDX_RETADDR = _ida_hexrays.MMIDX_RETADDR
MMIDX_SHADOW = _ida_hexrays.MMIDX_SHADOW
MMIDX_ARGS = _ida_hexrays.MMIDX_ARGS
MMIDX_GLBHIGH = _ida_hexrays.MMIDX_GLBHIGH
class mba_ranges_t(object):
    """
    Proxy of C++ mba_ranges_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pfn = _swig_property(_ida_hexrays.mba_ranges_t_pfn_get, _ida_hexrays.mba_ranges_t_pfn_set)
    ranges = _swig_property(_ida_hexrays.mba_ranges_t_ranges_get, _ida_hexrays.mba_ranges_t_ranges_set)
    def __init__(self, *args):
        """
        __init__(self, _pfn=None) -> mba_ranges_t
        __init__(self, r) -> mba_ranges_t
        """
        this = _ida_hexrays.new_mba_ranges_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def start(self, *args):
        """
        start(self) -> ea_t
        """
        return _ida_hexrays.mba_ranges_t_start(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.mba_ranges_t_empty(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.mba_ranges_t_clear(self, *args)

    def is_snippet(self, *args):
        """
        is_snippet(self) -> bool
        """
        return _ida_hexrays.mba_ranges_t_is_snippet(self, *args)

    def is_fragmented(self, *args):
        """
        is_fragmented(self) -> bool
        """
        return _ida_hexrays.mba_ranges_t_is_fragmented(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mba_ranges_t
    __del__ = lambda self : None;
mba_ranges_t_swigregister = _ida_hexrays.mba_ranges_t_swigregister
mba_ranges_t_swigregister(mba_ranges_t)

class mba_range_iterator_t(object):
    """
    Proxy of C++ mba_range_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rii = _swig_property(_ida_hexrays.mba_range_iterator_t_rii_get, _ida_hexrays.mba_range_iterator_t_rii_set)
    fii = _swig_property(_ida_hexrays.mba_range_iterator_t_fii_get, _ida_hexrays.mba_range_iterator_t_fii_set)
    def is_snippet(self, *args):
        """
        is_snippet(self) -> bool
        """
        return _ida_hexrays.mba_range_iterator_t_is_snippet(self, *args)

    def set(self, *args):
        """
        set(self, mbr) -> bool
        """
        return _ida_hexrays.mba_range_iterator_t_set(self, *args)

    def next(self, *args):
        """
        next(self) -> bool
        """
        return _ida_hexrays.mba_range_iterator_t_next(self, *args)

    def chunk(self, *args):
        """
        chunk(self) -> range_t
        """
        return _ida_hexrays.mba_range_iterator_t_chunk(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> mba_range_iterator_t
        """
        this = _ida_hexrays.new_mba_range_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_mba_range_iterator_t
    __del__ = lambda self : None;
mba_range_iterator_t_swigregister = _ida_hexrays.mba_range_iterator_t_swigregister
mba_range_iterator_t_swigregister(mba_range_iterator_t)

class mbl_array_t(object):
    """
    Proxy of C++ mbl_array_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def precise_defeas(self, *args):
        """
        precise_defeas(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_precise_defeas(self, *args)

    def optimized(self, *args):
        """
        optimized(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_optimized(self, *args)

    def short_display(self, *args):
        """
        short_display(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_short_display(self, *args)

    def show_reduction(self, *args):
        """
        show_reduction(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_show_reduction(self, *args)

    def graph_insns(self, *args):
        """
        graph_insns(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_graph_insns(self, *args)

    def loaded_gdl(self, *args):
        """
        loaded_gdl(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_loaded_gdl(self, *args)

    def should_beautify(self, *args):
        """
        should_beautify(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_should_beautify(self, *args)

    def rtype_refined(self, *args):
        """
        rtype_refined(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_rtype_refined(self, *args)

    def may_refine_rettype(self, *args):
        """
        may_refine_rettype(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_may_refine_rettype(self, *args)

    def use_wingraph32(self, *args):
        """
        use_wingraph32(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_use_wingraph32(self, *args)

    def display_numaddrs(self, *args):
        """
        display_numaddrs(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_display_numaddrs(self, *args)

    def display_valnums(self, *args):
        """
        display_valnums(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_display_valnums(self, *args)

    def is_pattern(self, *args):
        """
        is_pattern(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_pattern(self, *args)

    def is_thunk(self, *args):
        """
        is_thunk(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_thunk(self, *args)

    def saverest_done(self, *args):
        """
        saverest_done(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_saverest_done(self, *args)

    def callinfo_built(self, *args):
        """
        callinfo_built(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_callinfo_built(self, *args)

    def has_overvars(self, *args):
        """
        has_overvars(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_has_overvars(self, *args)

    def really_alloc(self, *args):
        """
        really_alloc(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_really_alloc(self, *args)

    def lvars_allocated(self, *args):
        """
        lvars_allocated(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_lvars_allocated(self, *args)

    def chain_varnums_ok(self, *args):
        """
        chain_varnums_ok(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_chain_varnums_ok(self, *args)

    def returns_fpval(self, *args):
        """
        returns_fpval(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_returns_fpval(self, *args)

    def has_passregs(self, *args):
        """
        has_passregs(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_has_passregs(self, *args)

    def generated_asserts(self, *args):
        """
        generated_asserts(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_generated_asserts(self, *args)

    def propagated_asserts(self, *args):
        """
        propagated_asserts(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_propagated_asserts(self, *args)

    def deleted_pairs(self, *args):
        """
        deleted_pairs(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_deleted_pairs(self, *args)

    def common_stkvars_stkargs(self, *args):
        """
        common_stkvars_stkargs(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_common_stkvars_stkargs(self, *args)

    def lvar_names_ok(self, *args):
        """
        lvar_names_ok(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_lvar_names_ok(self, *args)

    def lvars_renamed(self, *args):
        """
        lvars_renamed(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_lvars_renamed(self, *args)

    def has_over_chains(self, *args):
        """
        has_over_chains(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_has_over_chains(self, *args)

    def valranges_done(self, *args):
        """
        valranges_done(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_valranges_done(self, *args)

    def argidx_ok(self, *args):
        """
        argidx_ok(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_argidx_ok(self, *args)

    def is_ctr(self, *args):
        """
        is_ctr(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_ctr(self, *args)

    def is_dtr(self, *args):
        """
        is_dtr(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_dtr(self, *args)

    def is_cdtr(self, *args):
        """
        is_cdtr(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_cdtr(self, *args)

    def get_mba_flags(self, *args):
        """
        get_mba_flags(self) -> int
        """
        return _ida_hexrays.mbl_array_t_get_mba_flags(self, *args)

    def get_mba_flags2(self, *args):
        """
        get_mba_flags2(self) -> int
        """
        return _ida_hexrays.mbl_array_t_get_mba_flags2(self, *args)

    def set_mba_flags(self, *args):
        """
        set_mba_flags(self, f)
        """
        return _ida_hexrays.mbl_array_t_set_mba_flags(self, *args)

    def clr_mba_flags(self, *args):
        """
        clr_mba_flags(self, f)
        """
        return _ida_hexrays.mbl_array_t_clr_mba_flags(self, *args)

    def set_mba_flags2(self, *args):
        """
        set_mba_flags2(self, f)
        """
        return _ida_hexrays.mbl_array_t_set_mba_flags2(self, *args)

    def clr_mba_flags2(self, *args):
        """
        clr_mba_flags2(self, f)
        """
        return _ida_hexrays.mbl_array_t_clr_mba_flags2(self, *args)

    def clr_cdtr(self, *args):
        """
        clr_cdtr(self)
        """
        return _ida_hexrays.mbl_array_t_clr_cdtr(self, *args)

    def calc_shins_flags(self, *args):
        """
        calc_shins_flags(self) -> int
        """
        return _ida_hexrays.mbl_array_t_calc_shins_flags(self, *args)

    def stkoff_vd2ida(self, *args):
        """
        stkoff_vd2ida(self, off) -> sval_t
        """
        return _ida_hexrays.mbl_array_t_stkoff_vd2ida(self, *args)

    def stkoff_ida2vd(self, *args):
        """
        stkoff_ida2vd(self, off) -> sval_t
        """
        return _ida_hexrays.mbl_array_t_stkoff_ida2vd(self, *args)

    def argbase(self, *args):
        """
        argbase(self) -> sval_t
        """
        return _ida_hexrays.mbl_array_t_argbase(self, *args)

    def idaloc2vd(self, *args):
        """
        idaloc2vd(self, loc, width) -> vdloc_t
        """
        return _ida_hexrays.mbl_array_t_idaloc2vd(self, *args)

    def vd2idaloc(self, *args):
        """
        vd2idaloc(self, loc, width, spd) -> argloc_t
        vd2idaloc(self, loc, width) -> argloc_t
        """
        return _ida_hexrays.mbl_array_t_vd2idaloc(self, *args)

    def is_stkarg(self, *args):
        """
        is_stkarg(self, v) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_stkarg(self, *args)

    def get_ida_argloc(self, *args):
        """
        get_ida_argloc(self, v) -> argloc_t
        """
        return _ida_hexrays.mbl_array_t_get_ida_argloc(self, *args)

    mbr = _swig_property(_ida_hexrays.mbl_array_t_mbr_get, _ida_hexrays.mbl_array_t_mbr_set)
    entry_ea = _swig_property(_ida_hexrays.mbl_array_t_entry_ea_get, _ida_hexrays.mbl_array_t_entry_ea_set)
    last_prolog_ea = _swig_property(_ida_hexrays.mbl_array_t_last_prolog_ea_get, _ida_hexrays.mbl_array_t_last_prolog_ea_set)
    first_epilog_ea = _swig_property(_ida_hexrays.mbl_array_t_first_epilog_ea_get, _ida_hexrays.mbl_array_t_first_epilog_ea_set)
    qty = _swig_property(_ida_hexrays.mbl_array_t_qty_get, _ida_hexrays.mbl_array_t_qty_set)
    npurged = _swig_property(_ida_hexrays.mbl_array_t_npurged_get, _ida_hexrays.mbl_array_t_npurged_set)
    cc = _swig_property(_ida_hexrays.mbl_array_t_cc_get, _ida_hexrays.mbl_array_t_cc_set)
    tmpstk_size = _swig_property(_ida_hexrays.mbl_array_t_tmpstk_size_get, _ida_hexrays.mbl_array_t_tmpstk_size_set)
    frsize = _swig_property(_ida_hexrays.mbl_array_t_frsize_get, _ida_hexrays.mbl_array_t_frsize_set)
    frregs = _swig_property(_ida_hexrays.mbl_array_t_frregs_get, _ida_hexrays.mbl_array_t_frregs_set)
    fpd = _swig_property(_ida_hexrays.mbl_array_t_fpd_get, _ida_hexrays.mbl_array_t_fpd_set)
    pfn_flags = _swig_property(_ida_hexrays.mbl_array_t_pfn_flags_get, _ida_hexrays.mbl_array_t_pfn_flags_set)
    retsize = _swig_property(_ida_hexrays.mbl_array_t_retsize_get, _ida_hexrays.mbl_array_t_retsize_set)
    shadow_args = _swig_property(_ida_hexrays.mbl_array_t_shadow_args_get, _ida_hexrays.mbl_array_t_shadow_args_set)
    fullsize = _swig_property(_ida_hexrays.mbl_array_t_fullsize_get, _ida_hexrays.mbl_array_t_fullsize_set)
    stacksize = _swig_property(_ida_hexrays.mbl_array_t_stacksize_get, _ida_hexrays.mbl_array_t_stacksize_set)
    inargoff = _swig_property(_ida_hexrays.mbl_array_t_inargoff_get, _ida_hexrays.mbl_array_t_inargoff_set)
    minstkref = _swig_property(_ida_hexrays.mbl_array_t_minstkref_get, _ida_hexrays.mbl_array_t_minstkref_set)
    minstkref_ea = _swig_property(_ida_hexrays.mbl_array_t_minstkref_ea_get, _ida_hexrays.mbl_array_t_minstkref_ea_set)
    minargref = _swig_property(_ida_hexrays.mbl_array_t_minargref_get, _ida_hexrays.mbl_array_t_minargref_set)
    spd_adjust = _swig_property(_ida_hexrays.mbl_array_t_spd_adjust_get, _ida_hexrays.mbl_array_t_spd_adjust_set)
    aliased_vars = _swig_property(_ida_hexrays.mbl_array_t_aliased_vars_get, _ida_hexrays.mbl_array_t_aliased_vars_set)
    aliased_args = _swig_property(_ida_hexrays.mbl_array_t_aliased_args_get, _ida_hexrays.mbl_array_t_aliased_args_set)
    gotoff_stkvars = _swig_property(_ida_hexrays.mbl_array_t_gotoff_stkvars_get, _ida_hexrays.mbl_array_t_gotoff_stkvars_set)
    restricted_memory = _swig_property(_ida_hexrays.mbl_array_t_restricted_memory_get, _ida_hexrays.mbl_array_t_restricted_memory_set)
    aliased_memory = _swig_property(_ida_hexrays.mbl_array_t_aliased_memory_get, _ida_hexrays.mbl_array_t_aliased_memory_set)
    nodel_memory = _swig_property(_ida_hexrays.mbl_array_t_nodel_memory_get, _ida_hexrays.mbl_array_t_nodel_memory_set)
    consumed_argregs = _swig_property(_ida_hexrays.mbl_array_t_consumed_argregs_get, _ida_hexrays.mbl_array_t_consumed_argregs_set)
    maturity = _swig_property(_ida_hexrays.mbl_array_t_maturity_get, _ida_hexrays.mbl_array_t_maturity_set)
    reqmat = _swig_property(_ida_hexrays.mbl_array_t_reqmat_get, _ida_hexrays.mbl_array_t_reqmat_set)
    final_type = _swig_property(_ida_hexrays.mbl_array_t_final_type_get, _ida_hexrays.mbl_array_t_final_type_set)
    idb_type = _swig_property(_ida_hexrays.mbl_array_t_idb_type_get, _ida_hexrays.mbl_array_t_idb_type_set)
    idb_spoiled = _swig_property(_ida_hexrays.mbl_array_t_idb_spoiled_get, _ida_hexrays.mbl_array_t_idb_spoiled_set)
    spoiled_list = _swig_property(_ida_hexrays.mbl_array_t_spoiled_list_get, _ida_hexrays.mbl_array_t_spoiled_list_set)
    fti_flags = _swig_property(_ida_hexrays.mbl_array_t_fti_flags_get, _ida_hexrays.mbl_array_t_fti_flags_set)
    idb_node = _swig_property(_ida_hexrays.mbl_array_t_idb_node_get, _ida_hexrays.mbl_array_t_idb_node_set)
    label = _swig_property(_ida_hexrays.mbl_array_t_label_get, _ida_hexrays.mbl_array_t_label_set)
    vars = _swig_property(_ida_hexrays.mbl_array_t_vars_get, _ida_hexrays.mbl_array_t_vars_set)
    argidx = _swig_property(_ida_hexrays.mbl_array_t_argidx_get, _ida_hexrays.mbl_array_t_argidx_set)
    retvaridx = _swig_property(_ida_hexrays.mbl_array_t_retvaridx_get, _ida_hexrays.mbl_array_t_retvaridx_set)
    error_ea = _swig_property(_ida_hexrays.mbl_array_t_error_ea_get, _ida_hexrays.mbl_array_t_error_ea_set)
    error_strarg = _swig_property(_ida_hexrays.mbl_array_t_error_strarg_get, _ida_hexrays.mbl_array_t_error_strarg_set)
    blocks = _swig_property(_ida_hexrays.mbl_array_t_blocks_get, _ida_hexrays.mbl_array_t_blocks_set)
    natural = _swig_property(_ida_hexrays.mbl_array_t_natural_get, _ida_hexrays.mbl_array_t_natural_set)
    std_ivls = _swig_property(_ida_hexrays.mbl_array_t_std_ivls_get, _ida_hexrays.mbl_array_t_std_ivls_set)
    notes = _swig_property(_ida_hexrays.mbl_array_t_notes_get, _ida_hexrays.mbl_array_t_notes_set)
    occurred_warns = _swig_property(_ida_hexrays.mbl_array_t_occurred_warns_get, _ida_hexrays.mbl_array_t_occurred_warns_set)
    def write_to_const_detected(self, *args):
        """
        write_to_const_detected(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_write_to_const_detected(self, *args)

    def bad_call_sp_detected(self, *args):
        """
        bad_call_sp_detected(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_bad_call_sp_detected(self, *args)

    def regargs_is_not_aligned(self, *args):
        """
        regargs_is_not_aligned(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_regargs_is_not_aligned(self, *args)

    def has_bad_sp(self, *args):
        """
        has_bad_sp(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_has_bad_sp(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_mbl_array_t
    __del__ = lambda self : None;
    def term(self, *args):
        """
        term(self)
        """
        return _ida_hexrays.mbl_array_t_term(self, *args)

    def get_curfunc(self, *args):
        """
        get_curfunc(self) -> func_t *
        """
        return _ida_hexrays.mbl_array_t_get_curfunc(self, *args)

    def use_frame(self, *args):
        """
        use_frame(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_use_frame(self, *args)

    def is_snippet(self, *args):
        """
        is_snippet(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_is_snippet(self, *args)

    def optimize_local(self, *args):
        """
        optimize_local(self, locopt_bits) -> int
        """
        return _ida_hexrays.mbl_array_t_optimize_local(self, *args)

    def build_graph(self, *args):
        """
        build_graph(self) -> merror_t
        """
        return _ida_hexrays.mbl_array_t_build_graph(self, *args)

    def get_graph(self, *args):
        """
        get_graph(self) -> mbl_graph_t
        """
        return _ida_hexrays.mbl_array_t_get_graph(self, *args)

    def analyze_calls(self, *args):
        """
        analyze_calls(self, acflags) -> int
        """
        return _ida_hexrays.mbl_array_t_analyze_calls(self, *args)

    def optimize_global(self, *args):
        """
        optimize_global(self) -> merror_t
        """
        return _ida_hexrays.mbl_array_t_optimize_global(self, *args)

    def alloc_lvars(self, *args):
        """
        alloc_lvars(self)
        """
        return _ida_hexrays.mbl_array_t_alloc_lvars(self, *args)

    def dump(self, *args):
        """
        dump(self)
        """
        return _ida_hexrays.mbl_array_t_dump(self, *args)

    def dump_mba(self, *args):
        """
        dump_mba(self, _verify, title)
        """
        return _ida_hexrays.mbl_array_t_dump_mba(self, *args)

    def _print(self, *args):
        """
        _print(self, vp)
        """
        return _ida_hexrays.mbl_array_t__print(self, *args)

    def verify(self, *args):
        """
        verify(self, always)
        """
        return _ida_hexrays.mbl_array_t_verify(self, *args)

    def mark_chains_dirty(self, *args):
        """
        mark_chains_dirty(self)
        """
        return _ida_hexrays.mbl_array_t_mark_chains_dirty(self, *args)

    def get_mblock(self, *args):
        """
        get_mblock(self, n) -> mblock_t
        get_mblock(self, n) -> mblock_t
        """
        return _ida_hexrays.mbl_array_t_get_mblock(self, *args)

    def insert_block(self, *args):
        """
        insert_block(self, bblk) -> mblock_t
        """
        return _ida_hexrays.mbl_array_t_insert_block(self, *args)

    def remove_block(self, *args):
        """
        remove_block(self, blk) -> bool
        """
        return _ida_hexrays.mbl_array_t_remove_block(self, *args)

    def copy_block(self, *args):
        """
        copy_block(self, blk, new_serial, cpblk_flags=3) -> mblock_t
        """
        return _ida_hexrays.mbl_array_t_copy_block(self, *args)

    def remove_empty_blocks(self, *args):
        """
        remove_empty_blocks(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_remove_empty_blocks(self, *args)

    def combine_blocks(self, *args):
        """
        combine_blocks(self) -> bool
        """
        return _ida_hexrays.mbl_array_t_combine_blocks(self, *args)

    def for_all_ops(self, *args):
        """
        for_all_ops(self, mv) -> int
        """
        return _ida_hexrays.mbl_array_t_for_all_ops(self, *args)

    def for_all_insns(self, *args):
        """
        for_all_insns(self, mv) -> int
        """
        return _ida_hexrays.mbl_array_t_for_all_insns(self, *args)

    def for_all_topinsns(self, *args):
        """
        for_all_topinsns(self, mv) -> int
        """
        return _ida_hexrays.mbl_array_t_for_all_topinsns(self, *args)

    def find_mop(self, *args):
        """
        find_mop(self, ctx, ea, is_dest, list) -> mop_t
        """
        return _ida_hexrays.mbl_array_t_find_mop(self, *args)

    def arg(self, *args):
        """
        arg(self, n) -> lvar_t
        arg(self, n) -> lvar_t
        """
        return _ida_hexrays.mbl_array_t_arg(self, *args)

    def get_std_region(self, *args):
        """
        get_std_region(self, idx) -> ivl_t
        """
        return _ida_hexrays.mbl_array_t_get_std_region(self, *args)

    def get_lvars_region(self, *args):
        """
        get_lvars_region(self) -> ivl_t
        """
        return _ida_hexrays.mbl_array_t_get_lvars_region(self, *args)

    def get_shadow_region(self, *args):
        """
        get_shadow_region(self) -> ivl_t
        """
        return _ida_hexrays.mbl_array_t_get_shadow_region(self, *args)

    def get_args_region(self, *args):
        """
        get_args_region(self) -> ivl_t
        """
        return _ida_hexrays.mbl_array_t_get_args_region(self, *args)

    def get_stack_region(self, *args):
        """
        get_stack_region(self) -> ivl_t
        """
        return _ida_hexrays.mbl_array_t_get_stack_region(self, *args)

    def serialize(self, *args):
        """
        serialize(self)
        """
        return _ida_hexrays.mbl_array_t_serialize(self, *args)

    def deserialize(*args):
        """
        deserialize(bytes, nbytes) -> mbl_array_t
        """
        return _ida_hexrays.mbl_array_t_deserialize(*args)

    deserialize = staticmethod(deserialize)
    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.mbl_array_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.mbl_array_t__deregister(self, *args)

mbl_array_t_swigregister = _ida_hexrays.mbl_array_t_swigregister
mbl_array_t_swigregister(mbl_array_t)
MBA_PRCDEFS = _ida_hexrays.MBA_PRCDEFS
"""
use precise defeas for chain-allocated lvars
"""
MBA_NOFUNC = _ida_hexrays.MBA_NOFUNC
"""
function is not present, addresses might be wrong
"""
MBA_PATTERN = _ida_hexrays.MBA_PATTERN
"""
microcode pattern, callinfo is present
"""
MBA_LOADED = _ida_hexrays.MBA_LOADED
"""
loaded gdl, no instructions (debugging)
"""
MBA_RETFP = _ida_hexrays.MBA_RETFP
"""
function returns floating point value
"""
MBA_SPLINFO = _ida_hexrays.MBA_SPLINFO
"""
(final_type ? idb_spoiled : spoiled_regs) is valid
"""
MBA_PASSREGS = _ida_hexrays.MBA_PASSREGS
"""
has 'mcallinfo_t::pass_regs'
"""
MBA_THUNK = _ida_hexrays.MBA_THUNK
"""
thunk function
"""
MBA_CMNSTK = _ida_hexrays.MBA_CMNSTK
"""
stkvars+stkargs should be considered as one area
"""
MBA_PREOPT = _ida_hexrays.MBA_PREOPT
"""
preoptimization stage complete
"""
MBA_CMBBLK = _ida_hexrays.MBA_CMBBLK
"""
request to combine blocks
"""
MBA_ASRTOK = _ida_hexrays.MBA_ASRTOK
"""
assertions have been generated
"""
MBA_CALLS = _ida_hexrays.MBA_CALLS
"""
callinfo has been built
"""
MBA_ASRPROP = _ida_hexrays.MBA_ASRPROP
"""
assertion have been propagated
"""
MBA_SAVRST = _ida_hexrays.MBA_SAVRST
"""
save-restore analysis has been performed
"""
MBA_RETREF = _ida_hexrays.MBA_RETREF
"""
return type has been refined
"""
MBA_GLBOPT = _ida_hexrays.MBA_GLBOPT
"""
microcode has been optimized globally
"""
MBA_OVERVAR = _ida_hexrays.MBA_OVERVAR
"""
an overlapped variable has been detected
"""
MBA_LVARS0 = _ida_hexrays.MBA_LVARS0
"""
lvar pre-allocation has been performed
"""
MBA_LVARS1 = _ida_hexrays.MBA_LVARS1
"""
lvar real allocation has been performed
"""
MBA_DELPAIRS = _ida_hexrays.MBA_DELPAIRS
"""
pairs have been deleted once
"""
MBA_CHVARS = _ida_hexrays.MBA_CHVARS
"""
can verify chain varnums
"""
MBA_SHORT = _ida_hexrays.MBA_SHORT
"""
use short display
"""
MBA_COLGDL = _ida_hexrays.MBA_COLGDL
"""
display graph after each reduction
"""
MBA_INSGDL = _ida_hexrays.MBA_INSGDL
"""
display instruction in graphs
"""
MBA_NICE = _ida_hexrays.MBA_NICE
"""
apply transformations to c code
"""
MBA_REFINE = _ida_hexrays.MBA_REFINE
"""
may refine return value size
"""
MBA_RESERVED = _ida_hexrays.MBA_RESERVED
MBA_WINGR32 = _ida_hexrays.MBA_WINGR32
"""
use wingraph32
"""
MBA_NUMADDR = _ida_hexrays.MBA_NUMADDR
"""
display definition addresses for numbers
"""
MBA_VALNUM = _ida_hexrays.MBA_VALNUM
"""
display value numbers
"""
MBA_INITIAL_FLAGS = _ida_hexrays.MBA_INITIAL_FLAGS
MBA2_LVARNAMES_OK = _ida_hexrays.MBA2_LVARNAMES_OK
MBA2_LVARS_RENAMED = _ida_hexrays.MBA2_LVARS_RENAMED
MBA2_OVER_CHAINS = _ida_hexrays.MBA2_OVER_CHAINS
MBA2_VALRNG_DONE = _ida_hexrays.MBA2_VALRNG_DONE
MBA2_IS_CTR = _ida_hexrays.MBA2_IS_CTR
MBA2_IS_DTR = _ida_hexrays.MBA2_IS_DTR
MBA2_ARGIDX_OK = _ida_hexrays.MBA2_ARGIDX_OK
MBA2_NO_DUP_CALLS = _ida_hexrays.MBA2_NO_DUP_CALLS
MBA2_NO_DUP_LVARS = _ida_hexrays.MBA2_NO_DUP_LVARS
MBA2_INITIAL_FLAGS = _ida_hexrays.MBA2_INITIAL_FLAGS
MBA2_ALL_FLAGS = _ida_hexrays.MBA2_ALL_FLAGS
NALT_VD = _ida_hexrays.NALT_VD
"""
this index is not used by ida
"""
LOCOPT_ALL = _ida_hexrays.LOCOPT_ALL
"""
is not set, only dirty blocks will be optimized

redo optimization for all blocks. if this bit
"""
LOCOPT_REFINE = _ida_hexrays.LOCOPT_REFINE
"""
refine return type, ok to fail
"""
LOCOPT_REFINE2 = _ida_hexrays.LOCOPT_REFINE2
"""
refine return type, try harder
"""
ACFL_LOCOPT = _ida_hexrays.ACFL_LOCOPT
"""
perform local propagation (requires ACFL_BLKOPT)
"""
ACFL_BLKOPT = _ida_hexrays.ACFL_BLKOPT
"""
perform interblock transformations
"""
ACFL_GLBPROP = _ida_hexrays.ACFL_GLBPROP
"""
perform global propagation
"""
ACFL_GLBDEL = _ida_hexrays.ACFL_GLBDEL
"""
perform dead code eliminition
"""
ACFL_GUESS = _ida_hexrays.ACFL_GUESS
"""
may guess calling conventions
"""
CPBLK_FAST = _ida_hexrays.CPBLK_FAST
"""
do not update minbstkref and minbargref
"""
CPBLK_MINREF = _ida_hexrays.CPBLK_MINREF
"""
update minbstkref and minbargref
"""
CPBLK_OPTJMP = _ida_hexrays.CPBLK_OPTJMP
"""
if it becomes useless

del the jump insn at the end of the block
"""

def mbl_array_t_deserialize(*args):
  """
  mbl_array_t_deserialize(bytes, nbytes) -> mbl_array_t
  """
  return _ida_hexrays.mbl_array_t_deserialize(*args)

class chain_keeper_t(object):
    """
    Proxy of C++ chain_keeper_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _gc) -> chain_keeper_t
        """
        this = _ida_hexrays.new_chain_keeper_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_chain_keeper_t
    __del__ = lambda self : None;
    def front(self, *args):
        """
        front(self) -> block_chains_t
        """
        return _ida_hexrays.chain_keeper_t_front(self, *args)

    def back(self, *args):
        """
        back(self) -> block_chains_t
        """
        return _ida_hexrays.chain_keeper_t_back(self, *args)

    def for_all_chains(self, *args):
        """
        for_all_chains(self, cv, gca) -> int
        """
        return _ida_hexrays.chain_keeper_t_for_all_chains(self, *args)

chain_keeper_t_swigregister = _ida_hexrays.chain_keeper_t_swigregister
chain_keeper_t_swigregister(chain_keeper_t)

GC_REGS_AND_STKVARS = _ida_hexrays.GC_REGS_AND_STKVARS
GC_ASR = _ida_hexrays.GC_ASR
GC_XDSU = _ida_hexrays.GC_XDSU
GC_END = _ida_hexrays.GC_END
GC_DIRTY_ALL = _ida_hexrays.GC_DIRTY_ALL
class mbl_graph_t(simple_graph_t):
    """
    Proxy of C++ mbl_graph_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def is_ud_chain_dirty(self, *args):
        """
        is_ud_chain_dirty(self, gctype) -> bool
        """
        return _ida_hexrays.mbl_graph_t_is_ud_chain_dirty(self, *args)

    def is_du_chain_dirty(self, *args):
        """
        is_du_chain_dirty(self, gctype) -> bool
        """
        return _ida_hexrays.mbl_graph_t_is_du_chain_dirty(self, *args)

    def get_chain_stamp(self, *args):
        """
        get_chain_stamp(self) -> int
        """
        return _ida_hexrays.mbl_graph_t_get_chain_stamp(self, *args)

    def get_ud(self, *args):
        """
        get_ud(self, gctype) -> graph_chains_t
        """
        return _ida_hexrays.mbl_graph_t_get_ud(self, *args)

    def get_du(self, *args):
        """
        get_du(self, gctype) -> graph_chains_t
        """
        return _ida_hexrays.mbl_graph_t_get_du(self, *args)

    def is_redefined_globally(self, *args):
        """
        is_redefined_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
        """
        return _ida_hexrays.mbl_graph_t_is_redefined_globally(self, *args)

    def is_used_globally(self, *args):
        """
        is_used_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
        """
        return _ida_hexrays.mbl_graph_t_is_used_globally(self, *args)

    def get_mblock(self, *args):
        """
        get_mblock(self, n) -> mblock_t
        """
        return _ida_hexrays.mbl_graph_t_get_mblock(self, *args)

mbl_graph_t_swigregister = _ida_hexrays.mbl_graph_t_swigregister
mbl_graph_t_swigregister(mbl_graph_t)

class codegen_t(object):
    """
    Proxy of C++ codegen_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.codegen_t_mba_get, _ida_hexrays.codegen_t_mba_set)
    mb = _swig_property(_ida_hexrays.codegen_t_mb_get, _ida_hexrays.codegen_t_mb_set)
    insn = _swig_property(_ida_hexrays.codegen_t_insn_get, _ida_hexrays.codegen_t_insn_set)
    ignore_micro = _swig_property(_ida_hexrays.codegen_t_ignore_micro_get, _ida_hexrays.codegen_t_ignore_micro_set)
    def __init__(self, *args):
        """
        __init__(self, m) -> codegen_t
        """
        if self.__class__ == codegen_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_codegen_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_codegen_t
    __del__ = lambda self : None;
    def analyze_prolog(self, *args):
        """
        analyze_prolog(self, fc, reachable) -> merror_t
        """
        return _ida_hexrays.codegen_t_analyze_prolog(self, *args)

    def gen_micro(self, *args):
        """
        gen_micro(self) -> merror_t
        """
        return _ida_hexrays.codegen_t_gen_micro(self, *args)

    def load_operand(self, *args):
        """
        load_operand(self, opnum) -> mreg_t
        """
        return _ida_hexrays.codegen_t_load_operand(self, *args)

    def emit_micro_mvm(self, *args):
        """
        emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t
        """
        return _ida_hexrays.codegen_t_emit_micro_mvm(self, *args)

    def emit(self, *args):
        """
        emit(self, code, width, l, r, d, offsize) -> minsn_t
        emit(self, code, l, r, d) -> minsn_t
        """
        return _ida_hexrays.codegen_t_emit(self, *args)

    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_codegen_t(self)
        return weakref_proxy(self)
codegen_t_swigregister = _ida_hexrays.codegen_t_swigregister
codegen_t_swigregister(codegen_t)


def is_kreg(*args):
  """
  is_kreg(r) -> bool


  Is a kernel register?
  
  
  @param r (C++: mreg_t)
  """
  return _ida_hexrays.is_kreg(*args)

def get_temp_regs(*args):
  """
  get_temp_regs() -> mlist_t


  Get list of temporary registers. Tempregs are temporary registers that
  are used during code generation. They do not map to regular processor
  registers. They are used only to store temporary values during
  execution of one instruction. Tempregs may not be used to pass a value
  from one block to another. In other words, at the end of a block all
  tempregs must be dead.
  """
  return _ida_hexrays.get_temp_regs(*args)

def get_hexrays_version(*args):
  """
  get_hexrays_version() -> char const *


  Get decompiler version. The returned string is of the form
  <major>.<minor>.<revision>.<build-date>
  
  @return: pointer to version string. For example: "2.0.0.140605"
  """
  return _ida_hexrays.get_hexrays_version(*args)

def checkout_hexrays_license(*args):
  """
  checkout_hexrays_license(silent) -> bool


  Check out a floating decompiler license. This function will display a
  dialog box if the license is not available. For non-floating licenses
  this function is effectively no-op. It is not necessary to call this
  function before decompiling. If the license was not checked out, the
  decompiler will automatically do it. This function can be used to
  check out a license in advance and ensure that a license is available.
  
  @param silent: silently fail if the license can not be checked out.
                 (C++: bool)
  @return: false if failed
  """
  return _ida_hexrays.checkout_hexrays_license(*args)

def open_pseudocode(*args):
  """
  open_pseudocode(ea, new_window) -> vdui_t


  Open pseudocode window. The specified function is decompiled and the
  pseudocode window is opened.
  
  @param ea: function to decompile (C++: ea_t)
  @param new_window: 0:reuse existing window; 1:open new window; -1:
                     reuse existing window if the current view is
                     pseudocode (C++: int)
  @return: false if failed
  """
  return _ida_hexrays.open_pseudocode(*args)

def close_pseudocode(*args):
  """
  close_pseudocode(f) -> bool


  Close pseudocode window.
  
  @param f: pointer to window (C++: TWidget *)
  @return: false if failed
  """
  return _ida_hexrays.close_pseudocode(*args)
VDRUN_NEWFILE = _ida_hexrays.VDRUN_NEWFILE
"""
Create a new file or overwrite existing file.
"""
VDRUN_APPEND = _ida_hexrays.VDRUN_APPEND
"""
Create a new file or append to existing file.
"""
VDRUN_ONLYNEW = _ida_hexrays.VDRUN_ONLYNEW
"""
Fail if output file already exists.
"""
VDRUN_SILENT = _ida_hexrays.VDRUN_SILENT
"""
Silent decompilation.
"""
VDRUN_SENDIDB = _ida_hexrays.VDRUN_SENDIDB
"""
Send problematic databases to hex-rays.com.
"""
VDRUN_MAYSTOP = _ida_hexrays.VDRUN_MAYSTOP
"""
the user can cancel decompilation
"""
VDRUN_CMDLINE = _ida_hexrays.VDRUN_CMDLINE
"""
called from ida's command line
"""
VDRUN_STATS = _ida_hexrays.VDRUN_STATS
"""
print statistics into vd_stats.txt
"""
VDRUN_LUMINA = _ida_hexrays.VDRUN_LUMINA
"""
use lumina server
"""

def decompile_many(*args):
  """
  decompile_many(outfile, funcaddrs, flags) -> bool


  Batch decompilation. Decompile all or the specified functions
  
  @param outfile: name of the output file (C++: const char *)
  @param funcaddrs: list of functions to decompile. If NULL or empty,
                    then decompile all nonlib functions (C++: eavec_t
                    *)
  @param flags: Batch decompilation bits (C++: int)
  @return: true if no internal error occurred and the user has not
           cancelled decompilation
  """
  return _ida_hexrays.decompile_many(*args)
class hexrays_failure_t(object):
    """
    Proxy of C++ hexrays_failure_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_hexrays.hexrays_failure_t_code_get, _ida_hexrays.hexrays_failure_t_code_set)
    errea = _swig_property(_ida_hexrays.hexrays_failure_t_errea_get, _ida_hexrays.hexrays_failure_t_errea_set)
    str = _swig_property(_ida_hexrays.hexrays_failure_t_str_get, _ida_hexrays.hexrays_failure_t_str_set)
    def __init__(self, *args):
        """
        __init__(self) -> hexrays_failure_t
        __init__(self, c, ea, buf=None) -> hexrays_failure_t
        __init__(self, c, ea, buf) -> hexrays_failure_t
        """
        this = _ida_hexrays.new_hexrays_failure_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def desc(self, *args):
        """
        desc(self) -> qstring
        """
        return _ida_hexrays.hexrays_failure_t_desc(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_hexrays_failure_t
    __del__ = lambda self : None;
hexrays_failure_t_swigregister = _ida_hexrays.hexrays_failure_t_swigregister
hexrays_failure_t_swigregister(hexrays_failure_t)

class vd_failure_t(object):
    """
    Proxy of C++ vd_failure_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hf = _swig_property(_ida_hexrays.vd_failure_t_hf_get, _ida_hexrays.vd_failure_t_hf_set)
    def __init__(self, *args):
        """
        __init__(self) -> vd_failure_t
        __init__(self, code, ea, buf=None) -> vd_failure_t
        __init__(self, code, ea, buf) -> vd_failure_t
        __init__(self, _hf) -> vd_failure_t
        """
        this = _ida_hexrays.new_vd_failure_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def desc(self, *args):
        """
        desc(self) -> qstring
        """
        return _ida_hexrays.vd_failure_t_desc(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vd_failure_t
    __del__ = lambda self : None;
vd_failure_t_swigregister = _ida_hexrays.vd_failure_t_swigregister
vd_failure_t_swigregister(vd_failure_t)

class vd_interr_t(vd_failure_t):
    """
    Proxy of C++ vd_interr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, ea, buf) -> vd_interr_t
        """
        this = _ida_hexrays.new_vd_interr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vd_interr_t
    __del__ = lambda self : None;
vd_interr_t_swigregister = _ida_hexrays.vd_interr_t_swigregister
vd_interr_t_swigregister(vd_interr_t)


def send_database(*args):
  """
  send_database(err, silent)


  Send the database to Hex-Rays. This function sends the current
  database to the Hex-Rays server. The database is sent in the
  compressed form over an encrypted (SSL) connection.
  
  @param err: failure description object. Empty  hexrays_failure_t
              object can be used if error information is not available.
              (C++: const  hexrays_failure_t  &)
  @param silent: if false, a dialog box will be displayed before sending
                 the database. (C++: bool)
  """
  return _ida_hexrays.send_database(*args)
class gco_info_t(object):
    """
    Proxy of C++ gco_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_hexrays.gco_info_t_name_get, _ida_hexrays.gco_info_t_name_set)
    size = _swig_property(_ida_hexrays.gco_info_t_size_get, _ida_hexrays.gco_info_t_size_set)
    flags = _swig_property(_ida_hexrays.gco_info_t_flags_get, _ida_hexrays.gco_info_t_flags_set)
    def is_reg(self, *args):
        """
        is_reg(self) -> bool
        """
        return _ida_hexrays.gco_info_t_is_reg(self, *args)

    def is_use(self, *args):
        """
        is_use(self) -> bool
        """
        return _ida_hexrays.gco_info_t_is_use(self, *args)

    def is_def(self, *args):
        """
        is_def(self) -> bool
        """
        return _ida_hexrays.gco_info_t_is_def(self, *args)

    def append_to_list(self, *args):
        """
        append_to_list(self, list, mba) -> bool
        """
        return _ida_hexrays.gco_info_t_append_to_list(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> gco_info_t
        """
        this = _ida_hexrays.new_gco_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_gco_info_t
    __del__ = lambda self : None;
gco_info_t_swigregister = _ida_hexrays.gco_info_t_swigregister
gco_info_t_swigregister(gco_info_t)
GCO_STK = _ida_hexrays.GCO_STK
"""
a stack variable
"""
GCO_REG = _ida_hexrays.GCO_REG
"""
is register? otherwise a stack variable
"""
GCO_USE = _ida_hexrays.GCO_USE
"""
is source operand?
"""
GCO_DEF = _ida_hexrays.GCO_DEF
"""
is destination operand?
"""


def get_current_operand(*args):
  """
  get_current_operand(out) -> bool


  Get the instruction operand under the cursor. This function determines
  the operand that is under the cursor in the active disassembly
  listing. If the operand refers to a register or stack variable, it
  return true.
  
  @param out (C++: gco_info_t  *)
  """
  return _ida_hexrays.get_current_operand(*args)

def remitem(*args):
  """
  remitem(e)
  """
  return _ida_hexrays.remitem(*args)
cot_empty = _ida_hexrays.cot_empty
cot_comma = _ida_hexrays.cot_comma
cot_asg = _ida_hexrays.cot_asg
cot_asgbor = _ida_hexrays.cot_asgbor
cot_asgxor = _ida_hexrays.cot_asgxor
cot_asgband = _ida_hexrays.cot_asgband
cot_asgadd = _ida_hexrays.cot_asgadd
cot_asgsub = _ida_hexrays.cot_asgsub
cot_asgmul = _ida_hexrays.cot_asgmul
cot_asgsshr = _ida_hexrays.cot_asgsshr
cot_asgushr = _ida_hexrays.cot_asgushr
cot_asgshl = _ida_hexrays.cot_asgshl
cot_asgsdiv = _ida_hexrays.cot_asgsdiv
cot_asgudiv = _ida_hexrays.cot_asgudiv
cot_asgsmod = _ida_hexrays.cot_asgsmod
cot_asgumod = _ida_hexrays.cot_asgumod
cot_tern = _ida_hexrays.cot_tern
cot_lor = _ida_hexrays.cot_lor
cot_land = _ida_hexrays.cot_land
cot_bor = _ida_hexrays.cot_bor
cot_xor = _ida_hexrays.cot_xor
cot_band = _ida_hexrays.cot_band
cot_eq = _ida_hexrays.cot_eq
cot_ne = _ida_hexrays.cot_ne
cot_sge = _ida_hexrays.cot_sge
cot_uge = _ida_hexrays.cot_uge
cot_sle = _ida_hexrays.cot_sle
cot_ule = _ida_hexrays.cot_ule
cot_sgt = _ida_hexrays.cot_sgt
cot_ugt = _ida_hexrays.cot_ugt
cot_slt = _ida_hexrays.cot_slt
cot_ult = _ida_hexrays.cot_ult
cot_sshr = _ida_hexrays.cot_sshr
cot_ushr = _ida_hexrays.cot_ushr
cot_shl = _ida_hexrays.cot_shl
cot_add = _ida_hexrays.cot_add
cot_sub = _ida_hexrays.cot_sub
cot_mul = _ida_hexrays.cot_mul
cot_sdiv = _ida_hexrays.cot_sdiv
cot_udiv = _ida_hexrays.cot_udiv
cot_smod = _ida_hexrays.cot_smod
cot_umod = _ida_hexrays.cot_umod
cot_fadd = _ida_hexrays.cot_fadd
cot_fsub = _ida_hexrays.cot_fsub
cot_fmul = _ida_hexrays.cot_fmul
cot_fdiv = _ida_hexrays.cot_fdiv
cot_fneg = _ida_hexrays.cot_fneg
cot_neg = _ida_hexrays.cot_neg
cot_cast = _ida_hexrays.cot_cast
cot_lnot = _ida_hexrays.cot_lnot
cot_bnot = _ida_hexrays.cot_bnot
cot_ptr = _ida_hexrays.cot_ptr
cot_ref = _ida_hexrays.cot_ref
cot_postinc = _ida_hexrays.cot_postinc
cot_postdec = _ida_hexrays.cot_postdec
cot_preinc = _ida_hexrays.cot_preinc
cot_predec = _ida_hexrays.cot_predec
cot_call = _ida_hexrays.cot_call
cot_idx = _ida_hexrays.cot_idx
cot_memref = _ida_hexrays.cot_memref
cot_memptr = _ida_hexrays.cot_memptr
cot_num = _ida_hexrays.cot_num
cot_fnum = _ida_hexrays.cot_fnum
cot_str = _ida_hexrays.cot_str
cot_obj = _ida_hexrays.cot_obj
cot_var = _ida_hexrays.cot_var
cot_insn = _ida_hexrays.cot_insn
cot_sizeof = _ida_hexrays.cot_sizeof
cot_helper = _ida_hexrays.cot_helper
cot_type = _ida_hexrays.cot_type
cot_last = _ida_hexrays.cot_last
cit_empty = _ida_hexrays.cit_empty
cit_block = _ida_hexrays.cit_block
cit_expr = _ida_hexrays.cit_expr
cit_if = _ida_hexrays.cit_if
cit_for = _ida_hexrays.cit_for
cit_while = _ida_hexrays.cit_while
cit_do = _ida_hexrays.cit_do
cit_switch = _ida_hexrays.cit_switch
cit_break = _ida_hexrays.cit_break
cit_continue = _ida_hexrays.cit_continue
cit_return = _ida_hexrays.cit_return
cit_goto = _ida_hexrays.cit_goto
cit_asm = _ida_hexrays.cit_asm
cit_end = _ida_hexrays.cit_end
class operator_info_t(object):
    """
    Proxy of C++ operator_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_ida_hexrays.operator_info_t_text_get, _ida_hexrays.operator_info_t_text_set)
    precedence = _swig_property(_ida_hexrays.operator_info_t_precedence_get, _ida_hexrays.operator_info_t_precedence_set)
    valency = _swig_property(_ida_hexrays.operator_info_t_valency_get, _ida_hexrays.operator_info_t_valency_set)
    fixtype = _swig_property(_ida_hexrays.operator_info_t_fixtype_get, _ida_hexrays.operator_info_t_fixtype_set)
    flags = _swig_property(_ida_hexrays.operator_info_t_flags_get, _ida_hexrays.operator_info_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> operator_info_t
        """
        this = _ida_hexrays.new_operator_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_operator_info_t
    __del__ = lambda self : None;
operator_info_t_swigregister = _ida_hexrays.operator_info_t_swigregister
operator_info_t_swigregister(operator_info_t)
FX_NONE = cvar.FX_NONE
FX_INFIX = cvar.FX_INFIX
FX_PREFIX = cvar.FX_PREFIX
FX_POSTFIX = cvar.FX_POSTFIX
FX_TERNARY = cvar.FX_TERNARY
COI_RL = cvar.COI_RL
COI_LR = cvar.COI_LR
COI_INT = cvar.COI_INT
COI_FP = cvar.COI_FP
COI_SH = cvar.COI_SH
COI_SGN = cvar.COI_SGN
COI_SBN = cvar.COI_SBN


def negated_relation(*args):
  """
  negated_relation(op) -> ctype_t


  Negate a comparison operator. For example, cot_sge becomes cot_slt.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.negated_relation(*args)

def swapped_relation(*args):
  """
  swapped_relation(op) -> ctype_t


  Swap a comparison operator. For example, cot_sge becomes cot_sle.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.swapped_relation(*args)

def get_op_signness(*args):
  """
  get_op_signness(op) -> type_sign_t


  Get operator sign. Meaningful for sign-dependent operators, like
  cot_sdiv.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.get_op_signness(*args)

def asgop(*args):
  """
  asgop(cop) -> ctype_t


  Convert plain operator into assignment operator. For example, cot_add
  returns cot_asgadd.
  
  
  @param cop (C++: ctype_t)
  """
  return _ida_hexrays.asgop(*args)

def asgop_revert(*args):
  """
  asgop_revert(cop) -> ctype_t


  Convert assignment operator into plain operator. For example,
  cot_asgadd returns cot_add
  
  @param cop (C++: ctype_t)
  @return: cot_empty is the input operator is not an assignment
           operator.
  """
  return _ida_hexrays.asgop_revert(*args)

def op_uses_x(*args):
  """
  op_uses_x(op) -> bool


  Does operator use the 'x' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_x(*args)

def op_uses_y(*args):
  """
  op_uses_y(op) -> bool


  Does operator use the 'y' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_y(*args)

def op_uses_z(*args):
  """
  op_uses_z(op) -> bool


  Does operator use the 'z' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_z(*args)

def is_binary(*args):
  """
  is_binary(op) -> bool


  Is binary operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_binary(*args)

def is_unary(*args):
  """
  is_unary(op) -> bool


  Is unary operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_unary(*args)

def is_relational(*args):
  """
  is_relational(op) -> bool


  Is comparison operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_relational(*args)

def is_assignment(*args):
  """
  is_assignment(op) -> bool


  Is assignment operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_assignment(*args)

def accepts_udts(*args):
  """
  accepts_udts(op) -> bool
  """
  return _ida_hexrays.accepts_udts(*args)

def is_prepost(*args):
  """
  is_prepost(op) -> bool


  Is pre/post increment/decrement operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_prepost(*args)

def is_commutative(*args):
  """
  is_commutative(op) -> bool


  Is commutative operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_commutative(*args)

def is_additive(*args):
  """
  is_additive(op) -> bool


  Is additive operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_additive(*args)

def is_multiplicative(*args):
  """
  is_multiplicative(op) -> bool


  Is multiplicative operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_multiplicative(*args)

def is_bitop(*args):
  """
  is_bitop(op) -> bool


  Is bit related operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_bitop(*args)

def is_logical(*args):
  """
  is_logical(op) -> bool


  Is logical operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_logical(*args)

def is_loop(*args):
  """
  is_loop(op) -> bool


  Is loop statement code?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_loop(*args)

def is_break_consumer(*args):
  """
  is_break_consumer(op) -> bool


  Does a break statement influence the specified statement code?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_break_consumer(*args)

def is_lvalue(*args):
  """
  is_lvalue(op) -> bool


  Is Lvalue operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_lvalue(*args)

def accepts_small_udts(*args):
  """
  accepts_small_udts(op) -> bool


  Is the operator allowed on small structure or union?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.accepts_small_udts(*args)
class cnumber_t(object):
    """
    Proxy of C++ cnumber_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _value = _swig_property(_ida_hexrays.cnumber_t__value_get, _ida_hexrays.cnumber_t__value_set)
    nf = _swig_property(_ida_hexrays.cnumber_t_nf_get, _ida_hexrays.cnumber_t_nf_set)
    def __init__(self, *args):
        """
        __init__(self, _opnum=0) -> cnumber_t
        """
        this = _ida_hexrays.new_cnumber_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def _print(self, *args):
        """
        _print(self, type, parent=None, nice_stroff=None)
        """
        return _ida_hexrays.cnumber_t__print(self, *args)

    def value(self, *args):
        """
        value(self, type) -> uint64
        """
        return _ida_hexrays.cnumber_t_value(self, *args)

    def assign(self, *args):
        """
        assign(self, v, nbytes, sign)
        """
        return _ida_hexrays.cnumber_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cnumber_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cnumber_t
    __del__ = lambda self : None;
cnumber_t_swigregister = _ida_hexrays.cnumber_t_swigregister
cnumber_t_swigregister(cnumber_t)

class var_ref_t(object):
    """
    Proxy of C++ var_ref_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.var_ref_t_mba_get, _ida_hexrays.var_ref_t_mba_set)
    idx = _swig_property(_ida_hexrays.var_ref_t_idx_get, _ida_hexrays.var_ref_t_idx_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.var_ref_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> var_ref_t
        """
        this = _ida_hexrays.new_var_ref_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_var_ref_t
    __del__ = lambda self : None;
var_ref_t_swigregister = _ida_hexrays.var_ref_t_swigregister
var_ref_t_swigregister(var_ref_t)

class ctree_visitor_t(object):
    """
    Proxy of C++ ctree_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cv_flags = _swig_property(_ida_hexrays.ctree_visitor_t_cv_flags_get, _ida_hexrays.ctree_visitor_t_cv_flags_set)
    def maintain_parents(self, *args):
        """
        maintain_parents(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_maintain_parents(self, *args)

    def must_prune(self, *args):
        """
        must_prune(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_must_prune(self, *args)

    def must_restart(self, *args):
        """
        must_restart(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_must_restart(self, *args)

    def is_postorder(self, *args):
        """
        is_postorder(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_is_postorder(self, *args)

    def only_insns(self, *args):
        """
        only_insns(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_only_insns(self, *args)

    def prune_now(self, *args):
        """
        prune_now(self)
        """
        return _ida_hexrays.ctree_visitor_t_prune_now(self, *args)

    def clr_prune(self, *args):
        """
        clr_prune(self)
        """
        return _ida_hexrays.ctree_visitor_t_clr_prune(self, *args)

    def set_restart(self, *args):
        """
        set_restart(self)
        """
        return _ida_hexrays.ctree_visitor_t_set_restart(self, *args)

    def clr_restart(self, *args):
        """
        clr_restart(self)
        """
        return _ida_hexrays.ctree_visitor_t_clr_restart(self, *args)

    parents = _swig_property(_ida_hexrays.ctree_visitor_t_parents_get, _ida_hexrays.ctree_visitor_t_parents_set)
    def __init__(self, *args):
        """
        __init__(self, _flags) -> ctree_visitor_t
        """
        if self.__class__ == ctree_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_ctree_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def apply_to(self, *args):
        """
        apply_to(self, item, parent) -> int
        """
        return _ida_hexrays.ctree_visitor_t_apply_to(self, *args)

    def apply_to_exprs(self, *args):
        """
        apply_to_exprs(self, item, parent) -> int
        """
        return _ida_hexrays.ctree_visitor_t_apply_to_exprs(self, *args)

    def parent_expr(self, *args):
        """
        parent_expr(self) -> cexpr_t
        """
        return _ida_hexrays.ctree_visitor_t_parent_expr(self, *args)

    def parent_insn(self, *args):
        """
        parent_insn(self) -> cinsn_t
        """
        return _ida_hexrays.ctree_visitor_t_parent_insn(self, *args)

    def visit_insn(self, *args):
        """
        visit_insn(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_visit_insn(self, *args)

    def visit_expr(self, *args):
        """
        visit_expr(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_visit_expr(self, *args)

    def leave_insn(self, *args):
        """
        leave_insn(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_leave_insn(self, *args)

    def leave_expr(self, *args):
        """
        leave_expr(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_leave_expr(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_ctree_visitor_t(self)
        return weakref_proxy(self)
ctree_visitor_t_swigregister = _ida_hexrays.ctree_visitor_t_swigregister
ctree_visitor_t_swigregister(ctree_visitor_t)
CV_FAST = _ida_hexrays.CV_FAST
"""
do not maintain parent information
"""
CV_PRUNE = _ida_hexrays.CV_PRUNE
"""
this bit is set by visit...() to prune the walk
"""
CV_PARENTS = _ida_hexrays.CV_PARENTS
"""
maintain parent information
"""
CV_POST = _ida_hexrays.CV_POST
"""
call the leave...() functions
"""
CV_RESTART = _ida_hexrays.CV_RESTART
"""
restart enumeration at the top expr (apply_to_exprs)
"""
CV_INSNS = _ida_hexrays.CV_INSNS
"""
visit only statements, prune all expressions do not use before the
final ctree maturity because expressions may contain statements at
intermediate stages (see cot_insn). Otherwise you risk missing
statements embedded into expressions.
"""

class ctree_parentee_t(ctree_visitor_t):
    """
    Proxy of C++ ctree_parentee_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, post=False) -> ctree_parentee_t
        """
        if self.__class__ == ctree_parentee_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_ctree_parentee_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def recalc_parent_types(self, *args):
        """
        recalc_parent_types(self) -> bool
        """
        return _ida_hexrays.ctree_parentee_t_recalc_parent_types(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_parentee_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_ctree_parentee_t(self)
        return weakref_proxy(self)
ctree_parentee_t_swigregister = _ida_hexrays.ctree_parentee_t_swigregister
ctree_parentee_t_swigregister(ctree_parentee_t)

class cfunc_parentee_t(ctree_parentee_t):
    """
    Proxy of C++ cfunc_parentee_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    func = _swig_property(_ida_hexrays.cfunc_parentee_t_func_get, _ida_hexrays.cfunc_parentee_t_func_set)
    def __init__(self, *args):
        """
        __init__(self, f, post=False) -> cfunc_parentee_t
        """
        if self.__class__ == cfunc_parentee_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_cfunc_parentee_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def calc_rvalue_type(self, *args):
        """
        calc_rvalue_type(self, target, e) -> bool
        """
        return _ida_hexrays.cfunc_parentee_t_calc_rvalue_type(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cfunc_parentee_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_cfunc_parentee_t(self)
        return weakref_proxy(self)
cfunc_parentee_t_swigregister = _ida_hexrays.cfunc_parentee_t_swigregister
cfunc_parentee_t_swigregister(cfunc_parentee_t)

CMAT_ZERO = _ida_hexrays.CMAT_ZERO
CMAT_BUILT = _ida_hexrays.CMAT_BUILT
CMAT_TRANS1 = _ida_hexrays.CMAT_TRANS1
CMAT_NICE = _ida_hexrays.CMAT_NICE
CMAT_TRANS2 = _ida_hexrays.CMAT_TRANS2
CMAT_CPA = _ida_hexrays.CMAT_CPA
CMAT_TRANS3 = _ida_hexrays.CMAT_TRANS3
CMAT_CASTED = _ida_hexrays.CMAT_CASTED
CMAT_FINAL = _ida_hexrays.CMAT_FINAL
ITP_EMPTY = _ida_hexrays.ITP_EMPTY
ITP_ARG1 = _ida_hexrays.ITP_ARG1
ITP_ARG64 = _ida_hexrays.ITP_ARG64
ITP_BRACE1 = _ida_hexrays.ITP_BRACE1
ITP_INNER_LAST = _ida_hexrays.ITP_INNER_LAST
ITP_ASM = _ida_hexrays.ITP_ASM
ITP_ELSE = _ida_hexrays.ITP_ELSE
ITP_DO = _ida_hexrays.ITP_DO
ITP_SEMI = _ida_hexrays.ITP_SEMI
ITP_CURLY1 = _ida_hexrays.ITP_CURLY1
ITP_CURLY2 = _ida_hexrays.ITP_CURLY2
ITP_BRACE2 = _ida_hexrays.ITP_BRACE2
ITP_COLON = _ida_hexrays.ITP_COLON
ITP_BLOCK1 = _ida_hexrays.ITP_BLOCK1
ITP_BLOCK2 = _ida_hexrays.ITP_BLOCK2
ITP_CASE = _ida_hexrays.ITP_CASE
ITP_SIGN = _ida_hexrays.ITP_SIGN
class treeloc_t(object):
    """
    Proxy of C++ treeloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.treeloc_t_ea_get, _ida_hexrays.treeloc_t_ea_set)
    itp = _swig_property(_ida_hexrays.treeloc_t_itp_get, _ida_hexrays.treeloc_t_itp_set)
    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.treeloc_t___lt__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.treeloc_t___eq__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> treeloc_t
        """
        this = _ida_hexrays.new_treeloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_treeloc_t
    __del__ = lambda self : None;
treeloc_t_swigregister = _ida_hexrays.treeloc_t_swigregister
treeloc_t_swigregister(treeloc_t)

RETRIEVE_ONCE = _ida_hexrays.RETRIEVE_ONCE
RETRIEVE_ALWAYS = _ida_hexrays.RETRIEVE_ALWAYS
class citem_cmt_t(object):
    """
    Proxy of C++ citem_cmt_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    used = _swig_property(_ida_hexrays.citem_cmt_t_used_get, _ida_hexrays.citem_cmt_t_used_set)
    def __init__(self, *args):
        """
        __init__(self) -> citem_cmt_t
        __init__(self, s) -> citem_cmt_t
        """
        this = _ida_hexrays.new_citem_cmt_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def c_str(self, *args):
        """
        c_str(self) -> char const *
        """
        return _ida_hexrays.citem_cmt_t_c_str(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> char const *
        """
        return _ida_hexrays.citem_cmt_t___str__(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_cmt_t
    __del__ = lambda self : None;
citem_cmt_t_swigregister = _ida_hexrays.citem_cmt_t_swigregister
citem_cmt_t_swigregister(citem_cmt_t)

class citem_locator_t(object):
    """
    Proxy of C++ citem_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.citem_locator_t_ea_get, _ida_hexrays.citem_locator_t_ea_set)
    op = _swig_property(_ida_hexrays.citem_locator_t_op_get, _ida_hexrays.citem_locator_t_op_set)
    def __init__(self, *args):
        """
        __init__(self, _ea, _op) -> citem_locator_t
        __init__(self, i) -> citem_locator_t
        """
        this = _ida_hexrays.new_citem_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.citem_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_locator_t
    __del__ = lambda self : None;
citem_locator_t_swigregister = _ida_hexrays.citem_locator_t_swigregister
citem_locator_t_swigregister(citem_locator_t)

class bit_bound_t(object):
    """
    Proxy of C++ bit_bound_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nbits = _swig_property(_ida_hexrays.bit_bound_t_nbits_get, _ida_hexrays.bit_bound_t_nbits_set)
    sbits = _swig_property(_ida_hexrays.bit_bound_t_sbits_get, _ida_hexrays.bit_bound_t_sbits_set)
    def __init__(self, *args):
        """
        __init__(self, n=0, s=0) -> bit_bound_t
        """
        this = _ida_hexrays.new_bit_bound_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_bit_bound_t
    __del__ = lambda self : None;
bit_bound_t_swigregister = _ida_hexrays.bit_bound_t_swigregister
bit_bound_t_swigregister(bit_bound_t)

class citem_t(object):
    """
    Proxy of C++ citem_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.citem_t_ea_get, _ida_hexrays.citem_t_ea_set)
    label_num = _swig_property(_ida_hexrays.citem_t_label_num_get, _ida_hexrays.citem_t_label_num_set)
    index = _swig_property(_ida_hexrays.citem_t_index_get, _ida_hexrays.citem_t_index_set)
    def __init__(self, *args):
        """
        __init__(self) -> citem_t
        __init__(self, o) -> citem_t
        """
        this = _ida_hexrays.new_citem_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.citem_t_swap(self, *args)

    def is_expr(self, *args):
        """
        is_expr(self) -> bool
        """
        return _ida_hexrays.citem_t_is_expr(self, *args)

    def contains_expr(self, *args):
        """
        contains_expr(self, e) -> bool
        """
        return _ida_hexrays.citem_t_contains_expr(self, *args)

    def contains_label(self, *args):
        """
        contains_label(self) -> bool
        """
        return _ida_hexrays.citem_t_contains_label(self, *args)

    def find_parent_of(self, *args):
        """
        find_parent_of(self, sitem) -> citem_t
        find_parent_of(self, item) -> citem_t
        """
        return _ida_hexrays.citem_t_find_parent_of(self, *args)

    def find_closest_addr(self, *args):
        """
        find_closest_addr(self, _ea) -> citem_t
        """
        return _ida_hexrays.citem_t_find_closest_addr(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.citem_t_print1(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_t
    __del__ = lambda self : None;
    cinsn = _swig_property(_ida_hexrays.citem_t_cinsn_get)
    cexpr = _swig_property(_ida_hexrays.citem_t_cexpr_get)
    def _get_op(self, *args):
        """
        _get_op(self) -> ctype_t
        """
        return _ida_hexrays.citem_t__get_op(self, *args)

    def _set_op(self, *args):
        """
        _set_op(self, v)
        """
        return _ida_hexrays.citem_t__set_op(self, *args)

    def _ensure_no_op(self):
        if self.op not in [cot_empty, cit_empty]:
            raise Exception("%s has op %s; cannot be modified" % (self, self.op))
        return True
    op = property(
            _get_op,
            lambda self, v: self._ensure_no_op() and self._set_op(v))

    def __dbg_get_meminfo(self, *args):
        """
        __dbg_get_meminfo(self) -> qstring
        """
        return _ida_hexrays.citem_t___dbg_get_meminfo(self, *args)

    def __dbg_get_registered_kind(self, *args):
        """
        __dbg_get_registered_kind(self) -> int
        """
        return _ida_hexrays.citem_t___dbg_get_registered_kind(self, *args)

    def _obj_id(self, *args):
        """
        _obj_id(self) -> PyObject *
        """
        return _ida_hexrays.citem_t__obj_id(self, *args)

    obj_id = property(_obj_id)

    def _ensure_cond(self, ok, cond_str):
        if not ok:
            raise Exception("Condition \"%s\" not verified" % cond_str)
        return True

    def _ensure_no_obj(self, o, attr, attr_is_acquired):
        if attr_is_acquired and o is not None:
            raise Exception("%s already owns attribute \"%s\" (%s); cannot be modified" % (self, attr, o))
        return True

    def _acquire_ownership(self, v, acquire):
        if acquire and (v is not None) and not isinstance(v, (int, long)):
            if not v.thisown:
                raise Exception("%s is already owned, and cannot be reused" % v)
            v.thisown = False
            dereg = getattr(v, "_deregister", None)
            if dereg:
                dereg()
        return True

    def _maybe_disown_and_deregister(self):
        if self.thisown:
            self.thisown = False
            self._deregister()

    def _own_and_register(self):
        assert(not self.thisown)
        self.thisown = True
        self._register()

    def replace_by(self, o):
        assert(isinstance(o, (cexpr_t, cinsn_t)))
        o._maybe_disown_and_deregister()
        self._replace_by(o)

    def _meminfo(self):
        cpp = self.__dbg_get_meminfo()
        rkind = self.__dbg_get_registered_kind()
        rkind_str = [
                "(not owned)",
                "cfuncptr_t",
                "cinsn_t",
                "cexpr_t",
                "cblock_t",
                "mbl_array_t",
                "mop_t",
                "minsn_t",
                "optinsn_t",
                "optblock_t",
                "valrng_t"][rkind]
        return "%s [thisown=%s, owned by IDAPython as=%s]" % (
                cpp,
                self.thisown,
                rkind_str)
    meminfo = property(_meminfo)

citem_t_swigregister = _ida_hexrays.citem_t_swigregister
citem_t_swigregister(citem_t)

class cexpr_t(citem_t):
    """
    Proxy of C++ cexpr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    type = _swig_property(_ida_hexrays.cexpr_t_type_get, _ida_hexrays.cexpr_t_type_set)
    exflags = _swig_property(_ida_hexrays.cexpr_t_exflags_get, _ida_hexrays.cexpr_t_exflags_set)
    def cpadone(self, *args):
        """
        cpadone(self) -> bool
        """
        return _ida_hexrays.cexpr_t_cpadone(self, *args)

    def is_odd_lvalue(self, *args):
        """
        is_odd_lvalue(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_odd_lvalue(self, *args)

    def is_fpop(self, *args):
        """
        is_fpop(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_fpop(self, *args)

    def is_cstr(self, *args):
        """
        is_cstr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_cstr(self, *args)

    def is_undef_val(self, *args):
        """
        is_undef_val(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_undef_val(self, *args)

    def is_jumpout(self, *args):
        """
        is_jumpout(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_jumpout(self, *args)

    def is_vftable(self, *args):
        """
        is_vftable(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_vftable(self, *args)

    def set_cpadone(self, *args):
        """
        set_cpadone(self)
        """
        return _ida_hexrays.cexpr_t_set_cpadone(self, *args)

    def set_vftable(self, *args):
        """
        set_vftable(self)
        """
        return _ida_hexrays.cexpr_t_set_vftable(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cexpr_t
        __init__(self, cop, _x) -> cexpr_t
        __init__(self, cop, _x, _y) -> cexpr_t
        __init__(self, cop, _x, _y, _z) -> cexpr_t
        __init__(self, r) -> cexpr_t
        """
        this = _ida_hexrays.new_cexpr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cexpr_t_swap(self, *args)

    def assign(self, *args):
        """
        assign(self, r) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cexpr_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cexpr_t
    __del__ = lambda self : None;
    def _replace_by(self, *args):
        """
        _replace_by(self, r)
        """
        return _ida_hexrays.cexpr_t__replace_by(self, *args)

    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cexpr_t_cleanup(self, *args)

    def put_number(self, *args):
        """
        put_number(self, func, value, nbytes, sign=no_sign)
        """
        return _ida_hexrays.cexpr_t_put_number(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.cexpr_t_print1(self, *args)

    def calc_type(self, *args):
        """
        calc_type(self, recursive)
        """
        return _ida_hexrays.cexpr_t_calc_type(self, *args)

    def equal_effect(self, *args):
        """
        equal_effect(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t_equal_effect(self, *args)

    def is_child_of(self, *args):
        """
        is_child_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_child_of(self, *args)

    def contains_operator(self, *args):
        """
        contains_operator(self, needed_op, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_operator(self, *args)

    def contains_comma(self, *args):
        """
        contains_comma(self, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_comma(self, *args)

    def contains_insn(self, *args):
        """
        contains_insn(self, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_insn(self, *args)

    def contains_insn_or_label(self, *args):
        """
        contains_insn_or_label(self) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_insn_or_label(self, *args)

    def contains_comma_or_insn_or_label(self, *args):
        """
        contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_comma_or_insn_or_label(self, *args)

    def is_nice_expr(self, *args):
        """
        is_nice_expr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_nice_expr(self, *args)

    def is_nice_cond(self, *args):
        """
        is_nice_cond(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_nice_cond(self, *args)

    def is_call_object_of(self, *args):
        """
        is_call_object_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_call_object_of(self, *args)

    def is_call_arg_of(self, *args):
        """
        is_call_arg_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_call_arg_of(self, *args)

    def get_type_sign(self, *args):
        """
        get_type_sign(self) -> type_sign_t
        """
        return _ida_hexrays.cexpr_t_get_type_sign(self, *args)

    def is_type_unsigned(self, *args):
        """
        is_type_unsigned(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_type_unsigned(self, *args)

    def is_type_signed(self, *args):
        """
        is_type_signed(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_type_signed(self, *args)

    def get_high_nbit_bound(self, *args):
        """
        get_high_nbit_bound(self) -> bit_bound_t
        """
        return _ida_hexrays.cexpr_t_get_high_nbit_bound(self, *args)

    def get_low_nbit_bound(self, *args):
        """
        get_low_nbit_bound(self) -> int
        """
        return _ida_hexrays.cexpr_t_get_low_nbit_bound(self, *args)

    def requires_lvalue(self, *args):
        """
        requires_lvalue(self, child) -> bool
        """
        return _ida_hexrays.cexpr_t_requires_lvalue(self, *args)

    def has_side_effects(self, *args):
        """
        has_side_effects(self) -> bool
        """
        return _ida_hexrays.cexpr_t_has_side_effects(self, *args)

    def numval(self, *args):
        """
        numval(self) -> uint64
        """
        return _ida_hexrays.cexpr_t_numval(self, *args)

    def is_const_value(self, *args):
        """
        is_const_value(self, _v) -> bool
        """
        return _ida_hexrays.cexpr_t_is_const_value(self, *args)

    def is_negative_const(self, *args):
        """
        is_negative_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_negative_const(self, *args)

    def is_non_negative_const(self, *args):
        """
        is_non_negative_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_non_negative_const(self, *args)

    def is_non_zero_const(self, *args):
        """
        is_non_zero_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_non_zero_const(self, *args)

    def is_zero_const(self, *args):
        """
        is_zero_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_zero_const(self, *args)

    def get_const_value(self, *args):
        """
        get_const_value(self) -> bool
        """
        return _ida_hexrays.cexpr_t_get_const_value(self, *args)

    def maybe_ptr(self, *args):
        """
        maybe_ptr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_maybe_ptr(self, *args)

    def get_ptr_or_array(self, *args):
        """
        get_ptr_or_array(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_get_ptr_or_array(self, *args)

    def find_op(self, *args):
        """
        find_op(self, _op) -> cexpr_t
        find_op(self, _op) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_find_op(self, *args)

    def find_num_op(self, *args):
        """
        find_num_op(self) -> cexpr_t
        find_num_op(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_find_num_op(self, *args)

    def theother(self, *args):
        """
        theother(self, what) -> cexpr_t
        theother(self, what) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_theother(self, *args)

    def get_1num_op(self, *args):
        """
        get_1num_op(self, o1, o2) -> bool
        """
        return _ida_hexrays.cexpr_t_get_1num_op(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.cexpr_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cexpr_t__deregister(self, *args)

    def _get_n(self, *args):
        """
        _get_n(self) -> cnumber_t
        """
        return _ida_hexrays.cexpr_t__get_n(self, *args)

    def _set_n(self, *args):
        """
        _set_n(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_n(self, *args)

    n = property(                                                                lambda self: self._get_n() if self.op == cot_num else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_num,"self.op == cot_num")                                           and self._ensure_no_obj(self._get_n(),"n", True)                  and self._acquire_ownership(v, True)                                  and self._set_n(v))
    def _get_fpc(self, *args):
        """
        _get_fpc(self) -> fnumber_t
        """
        return _ida_hexrays.cexpr_t__get_fpc(self, *args)

    def _set_fpc(self, *args):
        """
        _set_fpc(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_fpc(self, *args)

    fpc = property(                                                                lambda self: self._get_fpc() if self.op == cot_fnum else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_fnum,"self.op == cot_fnum")                                           and self._ensure_no_obj(self._get_fpc(),"fpc", True)                  and self._acquire_ownership(v, True)                                  and self._set_fpc(v))
    def get_v(self, *args):
        """
        get_v(self) -> var_ref_t
        """
        return _ida_hexrays.cexpr_t_get_v(self, *args)

    def set_v(self, *args):
        """
        set_v(self, v)
        """
        return _ida_hexrays.cexpr_t_set_v(self, *args)

    v = property(lambda self: self.get_v(), lambda self, v: self.set_v(v))

    def _get_obj_ea(self, *args):
        """
        _get_obj_ea(self) -> ea_t
        """
        return _ida_hexrays.cexpr_t__get_obj_ea(self, *args)

    def _set_obj_ea(self, *args):
        """
        _set_obj_ea(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_obj_ea(self, *args)

    obj_ea = property(                                                                lambda self: self._get_obj_ea() if self.op == cot_obj else ida_idaapi.BADADDR,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_obj,"self.op == cot_obj")                                           and self._ensure_no_obj(self._get_obj_ea(),"obj_ea", False)                  and self._acquire_ownership(v, False)                                  and self._set_obj_ea(v))
    def _get_refwidth(self, *args):
        """
        _get_refwidth(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_refwidth(self, *args)

    def _set_refwidth(self, *args):
        """
        _set_refwidth(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_refwidth(self, *args)

    refwidth = property(                                                                lambda self: self._get_refwidth() if True else 0,                    lambda self, v:                                                              self._ensure_cond(True,"True")                                           and self._ensure_no_obj(self._get_refwidth(),"refwidth", False)                  and self._acquire_ownership(v, False)                                  and self._set_refwidth(v))
    def _get_x(self, *args):
        """
        _get_x(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_x(self, *args)

    def _set_x(self, *args):
        """
        _set_x(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_x(self, *args)

    x = property(                                                                lambda self: self._get_x() if op_uses_x(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_x(self.op),"op_uses_x(self.op)")                                           and self._ensure_no_obj(self._get_x(),"x", True)                  and self._acquire_ownership(v, True)                                  and self._set_x(v))
    def _get_y(self, *args):
        """
        _get_y(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_y(self, *args)

    def _set_y(self, *args):
        """
        _set_y(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_y(self, *args)

    y = property(                                                                lambda self: self._get_y() if op_uses_y(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_y(self.op),"op_uses_y(self.op)")                                           and self._ensure_no_obj(self._get_y(),"y", True)                  and self._acquire_ownership(v, True)                                  and self._set_y(v))
    def _get_a(self, *args):
        """
        _get_a(self) -> carglist_t
        """
        return _ida_hexrays.cexpr_t__get_a(self, *args)

    def _set_a(self, *args):
        """
        _set_a(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_a(self, *args)

    a = property(                                                                lambda self: self._get_a() if self.op == cot_call else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_call,"self.op == cot_call")                                           and self._ensure_no_obj(self._get_a(),"a", True)                  and self._acquire_ownership(v, True)                                  and self._set_a(v))
    def _get_m(self, *args):
        """
        _get_m(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_m(self, *args)

    def _set_m(self, *args):
        """
        _set_m(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_m(self, *args)

    m = property(                                                                lambda self: self._get_m() if (self.op == cot_memptr or self.op == cot_memref) else 0,                    lambda self, v:                                                              self._ensure_cond((self.op == cot_memptr or self.op == cot_memref),"(self.op == cot_memptr or self.op == cot_memref)")                                           and self._ensure_no_obj(self._get_m(),"m", False)                  and self._acquire_ownership(v, False)                                  and self._set_m(v))
    def _get_z(self, *args):
        """
        _get_z(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_z(self, *args)

    def _set_z(self, *args):
        """
        _set_z(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_z(self, *args)

    z = property(                                                                lambda self: self._get_z() if op_uses_z(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_z(self.op),"op_uses_z(self.op)")                                           and self._ensure_no_obj(self._get_z(),"z", True)                  and self._acquire_ownership(v, True)                                  and self._set_z(v))
    def _get_ptrsize(self, *args):
        """
        _get_ptrsize(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_ptrsize(self, *args)

    def _set_ptrsize(self, *args):
        """
        _set_ptrsize(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_ptrsize(self, *args)

    ptrsize = property(                                                                lambda self: self._get_ptrsize() if (self.op == cot_ptr or self.op == cot_memptr) else 0,                    lambda self, v:                                                              self._ensure_cond((self.op == cot_ptr or self.op == cot_memptr),"(self.op == cot_ptr or self.op == cot_memptr)")                                           and self._ensure_no_obj(self._get_ptrsize(),"ptrsize", False)                  and self._acquire_ownership(v, False)                                  and self._set_ptrsize(v))
    def _get_insn(self, *args):
        """
        _get_insn(self) -> cinsn_t
        """
        return _ida_hexrays.cexpr_t__get_insn(self, *args)

    def _set_insn(self, *args):
        """
        _set_insn(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_insn(self, *args)

    insn = property(                                                                lambda self: self._get_insn() if self.op == cot_insn else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_insn,"self.op == cot_insn")                                           and self._ensure_no_obj(self._get_insn(),"insn", True)                  and self._acquire_ownership(v, True)                                  and self._set_insn(v))
    def _get_helper(self, *args):
        """
        _get_helper(self) -> char *
        """
        return _ida_hexrays.cexpr_t__get_helper(self, *args)

    def _set_helper(self, *args):
        """
        _set_helper(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_helper(self, *args)

    helper = property(                                                                lambda self: self._get_helper() if self.op == cot_helper else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_helper,"self.op == cot_helper")                                           and self._ensure_no_obj(self._get_helper(),"helper", False)                  and self._acquire_ownership(v, False)                                  and self._set_helper(v))
    def _get_string(self, *args):
        """
        _get_string(self) -> char *
        """
        return _ida_hexrays.cexpr_t__get_string(self, *args)

    def _set_string(self, *args):
        """
        _set_string(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_string(self, *args)

    string = property(                                                                lambda self: self._get_string() if self.op == cot_str else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_str,"self.op == cot_str")                                           and self._ensure_no_obj(self._get_string(),"string", False)                  and self._acquire_ownership(v, False)                                  and self._set_string(v))
cexpr_t_swigregister = _ida_hexrays.cexpr_t_swigregister
cexpr_t_swigregister(cexpr_t)
EXFL_CPADONE = _ida_hexrays.EXFL_CPADONE
"""
pointer arithmetic correction done
"""
EXFL_LVALUE = _ida_hexrays.EXFL_LVALUE
"""
expression is lvalue even if it doesn't look like it
"""
EXFL_FPOP = _ida_hexrays.EXFL_FPOP
"""
floating point operation
"""
EXFL_ALONE = _ida_hexrays.EXFL_ALONE
"""
standalone helper
"""
EXFL_CSTR = _ida_hexrays.EXFL_CSTR
"""
string literal
"""
EXFL_PARTIAL = _ida_hexrays.EXFL_PARTIAL
"""
type of the expression is considered partial
"""
EXFL_UNDEF = _ida_hexrays.EXFL_UNDEF
"""
expression uses undefined value
"""
EXFL_JUMPOUT = _ida_hexrays.EXFL_JUMPOUT
"""
jump out-of-function
"""
EXFL_VFTABLE = _ida_hexrays.EXFL_VFTABLE
"""
is ptr to vftable (used for cot_memptr, cot_memref)
"""
EXFL_ALL = _ida_hexrays.EXFL_ALL
"""
all currently defined bits
"""

class ceinsn_t(object):
    """
    Proxy of C++ ceinsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    expr = _swig_property(_ida_hexrays.ceinsn_t_expr_get, _ida_hexrays.ceinsn_t_expr_set)
    def __init__(self, *args):
        """
        __init__(self) -> ceinsn_t
        """
        this = _ida_hexrays.new_ceinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ceinsn_t
    __del__ = lambda self : None;
ceinsn_t_swigregister = _ida_hexrays.ceinsn_t_swigregister
ceinsn_t_swigregister(ceinsn_t)

CALC_CURLY_BRACES = _ida_hexrays.CALC_CURLY_BRACES
NO_CURLY_BRACES = _ida_hexrays.NO_CURLY_BRACES
USE_CURLY_BRACES = _ida_hexrays.USE_CURLY_BRACES
class cif_t(ceinsn_t):
    """
    Proxy of C++ cif_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ithen = _swig_property(_ida_hexrays.cif_t_ithen_get, _ida_hexrays.cif_t_ithen_set)
    ielse = _swig_property(_ida_hexrays.cif_t_ielse_get, _ida_hexrays.cif_t_ielse_set)
    def __init__(self, *args):
        """
        __init__(self) -> cif_t
        __init__(self, r) -> cif_t
        """
        this = _ida_hexrays.new_cif_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, r) -> cif_t
        """
        return _ida_hexrays.cif_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cif_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cif_t
    __del__ = lambda self : None;
    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cif_t_cleanup(self, *args)

cif_t_swigregister = _ida_hexrays.cif_t_swigregister
cif_t_swigregister(cif_t)

class cloop_t(ceinsn_t):
    """
    Proxy of C++ cloop_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    body = _swig_property(_ida_hexrays.cloop_t_body_get, _ida_hexrays.cloop_t_body_set)
    def __init__(self, *args):
        """
        __init__(self) -> cloop_t
        __init__(self, b) -> cloop_t
        __init__(self, r) -> cloop_t
        """
        this = _ida_hexrays.new_cloop_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, r) -> cloop_t
        """
        return _ida_hexrays.cloop_t_assign(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cloop_t
    __del__ = lambda self : None;
    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cloop_t_cleanup(self, *args)

cloop_t_swigregister = _ida_hexrays.cloop_t_swigregister
cloop_t_swigregister(cloop_t)

class cfor_t(cloop_t):
    """
    Proxy of C++ cfor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    init = _swig_property(_ida_hexrays.cfor_t_init_get, _ida_hexrays.cfor_t_init_set)
    step = _swig_property(_ida_hexrays.cfor_t_step_get, _ida_hexrays.cfor_t_step_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cfor_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cfor_t
        """
        this = _ida_hexrays.new_cfor_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cfor_t
    __del__ = lambda self : None;
cfor_t_swigregister = _ida_hexrays.cfor_t_swigregister
cfor_t_swigregister(cfor_t)

class cwhile_t(cloop_t):
    """
    Proxy of C++ cwhile_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cwhile_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cwhile_t
        """
        this = _ida_hexrays.new_cwhile_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cwhile_t
    __del__ = lambda self : None;
cwhile_t_swigregister = _ida_hexrays.cwhile_t_swigregister
cwhile_t_swigregister(cwhile_t)

class cdo_t(cloop_t):
    """
    Proxy of C++ cdo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cdo_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cdo_t
        """
        this = _ida_hexrays.new_cdo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cdo_t
    __del__ = lambda self : None;
cdo_t_swigregister = _ida_hexrays.cdo_t_swigregister
cdo_t_swigregister(cdo_t)

class creturn_t(ceinsn_t):
    """
    Proxy of C++ creturn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.creturn_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> creturn_t
        """
        this = _ida_hexrays.new_creturn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_creturn_t
    __del__ = lambda self : None;
creturn_t_swigregister = _ida_hexrays.creturn_t_swigregister
creturn_t_swigregister(creturn_t)

class cgoto_t(object):
    """
    Proxy of C++ cgoto_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    label_num = _swig_property(_ida_hexrays.cgoto_t_label_num_get, _ida_hexrays.cgoto_t_label_num_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cgoto_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cgoto_t
        """
        this = _ida_hexrays.new_cgoto_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cgoto_t
    __del__ = lambda self : None;
cgoto_t_swigregister = _ida_hexrays.cgoto_t_swigregister
cgoto_t_swigregister(cgoto_t)

class casm_t(ida_pro.eavec_t):
    """
    Proxy of C++ casm_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, ea) -> casm_t
        __init__(self, r) -> casm_t
        """
        this = _ida_hexrays.new_casm_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.casm_t_compare(self, *args)

    def one_insn(self, *args):
        """
        one_insn(self) -> bool
        """
        return _ida_hexrays.casm_t_one_insn(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_casm_t
    __del__ = lambda self : None;
casm_t_swigregister = _ida_hexrays.casm_t_swigregister
casm_t_swigregister(casm_t)

class cinsn_t(citem_t):
    """
    Proxy of C++ cinsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> cinsn_t
        __init__(self, r) -> cinsn_t
        """
        this = _ida_hexrays.new_cinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cinsn_t_swap(self, *args)

    def assign(self, *args):
        """
        assign(self, r) -> cinsn_t
        """
        return _ida_hexrays.cinsn_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cinsn_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cinsn_t
    __del__ = lambda self : None;
    def _replace_by(self, *args):
        """
        _replace_by(self, r)
        """
        return _ida_hexrays.cinsn_t__replace_by(self, *args)

    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cinsn_t_cleanup(self, *args)

    def zero(self, *args):
        """
        zero(self)
        """
        return _ida_hexrays.cinsn_t_zero(self, *args)

    def new_insn(self, *args):
        """
        new_insn(self, insn_ea) -> cinsn_t
        """
        return _ida_hexrays.cinsn_t_new_insn(self, *args)

    def create_if(self, *args):
        """
        create_if(self, cnd) -> cif_t
        """
        return _ida_hexrays.cinsn_t_create_if(self, *args)

    def _print(self, *args):
        """
        _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
        """
        return _ida_hexrays.cinsn_t__print(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.cinsn_t_print1(self, *args)

    def is_ordinary_flow(self, *args):
        """
        is_ordinary_flow(self) -> bool
        """
        return _ida_hexrays.cinsn_t_is_ordinary_flow(self, *args)

    def contains_insn(self, *args):
        """
        contains_insn(self, type, times=1) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_insn(self, *args)

    def collect_free_breaks(self, *args):
        """
        collect_free_breaks(self, breaks) -> bool
        """
        return _ida_hexrays.cinsn_t_collect_free_breaks(self, *args)

    def collect_free_continues(self, *args):
        """
        collect_free_continues(self, continues) -> bool
        """
        return _ida_hexrays.cinsn_t_collect_free_continues(self, *args)

    def contains_free_break(self, *args):
        """
        contains_free_break(self) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_free_break(self, *args)

    def contains_free_continue(self, *args):
        """
        contains_free_continue(self) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_free_continue(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.cinsn_t__register(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cinsn_t__deregister(self, *args)

    def _get_cblock(self, *args):
        """
        _get_cblock(self) -> cblock_t
        """
        return _ida_hexrays.cinsn_t__get_cblock(self, *args)

    def _set_cblock(self, *args):
        """
        _set_cblock(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cblock(self, *args)

    cblock = property(                                                                lambda self: self._get_cblock() if self.op == cit_block else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_block,"self.op == cit_block")                                           and self._ensure_no_obj(self._get_cblock(),"cblock", True)                  and self._acquire_ownership(v, True)                                  and self._set_cblock(v))
    def _get_cexpr(self, *args):
        """
        _get_cexpr(self) -> cexpr_t
        """
        return _ida_hexrays.cinsn_t__get_cexpr(self, *args)

    def _set_cexpr(self, *args):
        """
        _set_cexpr(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cexpr(self, *args)

    cexpr = property(                                                                lambda self: self._get_cexpr() if self.op == cit_expr else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_expr,"self.op == cit_expr")                                           and self._ensure_no_obj(self._get_cexpr(),"cexpr", True)                  and self._acquire_ownership(v, True)                                  and self._set_cexpr(v))
    def _get_cif(self, *args):
        """
        _get_cif(self) -> cif_t
        """
        return _ida_hexrays.cinsn_t__get_cif(self, *args)

    def _set_cif(self, *args):
        """
        _set_cif(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cif(self, *args)

    cif = property(                                                                lambda self: self._get_cif() if self.op == cit_if else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_if,"self.op == cit_if")                                           and self._ensure_no_obj(self._get_cif(),"cif", True)                  and self._acquire_ownership(v, True)                                  and self._set_cif(v))
    def _get_cfor(self, *args):
        """
        _get_cfor(self) -> cfor_t
        """
        return _ida_hexrays.cinsn_t__get_cfor(self, *args)

    def _set_cfor(self, *args):
        """
        _set_cfor(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cfor(self, *args)

    cfor = property(                                                                lambda self: self._get_cfor() if self.op == cit_for else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_for,"self.op == cit_for")                                           and self._ensure_no_obj(self._get_cfor(),"cfor", True)                  and self._acquire_ownership(v, True)                                  and self._set_cfor(v))
    def _get_cwhile(self, *args):
        """
        _get_cwhile(self) -> cwhile_t
        """
        return _ida_hexrays.cinsn_t__get_cwhile(self, *args)

    def _set_cwhile(self, *args):
        """
        _set_cwhile(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cwhile(self, *args)

    cwhile = property(                                                                lambda self: self._get_cwhile() if self.op == cit_while else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_while,"self.op == cit_while")                                           and self._ensure_no_obj(self._get_cwhile(),"cwhile", True)                  and self._acquire_ownership(v, True)                                  and self._set_cwhile(v))
    def _get_cdo(self, *args):
        """
        _get_cdo(self) -> cdo_t
        """
        return _ida_hexrays.cinsn_t__get_cdo(self, *args)

    def _set_cdo(self, *args):
        """
        _set_cdo(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cdo(self, *args)

    cdo = property(                                                                lambda self: self._get_cdo() if self.op == cit_do else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_do,"self.op == cit_do")                                           and self._ensure_no_obj(self._get_cdo(),"cdo", True)                  and self._acquire_ownership(v, True)                                  and self._set_cdo(v))
    def _get_cswitch(self, *args):
        """
        _get_cswitch(self) -> cswitch_t
        """
        return _ida_hexrays.cinsn_t__get_cswitch(self, *args)

    def _set_cswitch(self, *args):
        """
        _set_cswitch(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cswitch(self, *args)

    cswitch = property(                                                                lambda self: self._get_cswitch() if self.op == cit_switch else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_switch,"self.op == cit_switch")                                           and self._ensure_no_obj(self._get_cswitch(),"cswitch", True)                  and self._acquire_ownership(v, True)                                  and self._set_cswitch(v))
    def _get_creturn(self, *args):
        """
        _get_creturn(self) -> creturn_t
        """
        return _ida_hexrays.cinsn_t__get_creturn(self, *args)

    def _set_creturn(self, *args):
        """
        _set_creturn(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_creturn(self, *args)

    creturn = property(                                                                lambda self: self._get_creturn() if self.op == cit_return else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_return,"self.op == cit_return")                                           and self._ensure_no_obj(self._get_creturn(),"creturn", True)                  and self._acquire_ownership(v, True)                                  and self._set_creturn(v))
    def _get_cgoto(self, *args):
        """
        _get_cgoto(self) -> cgoto_t
        """
        return _ida_hexrays.cinsn_t__get_cgoto(self, *args)

    def _set_cgoto(self, *args):
        """
        _set_cgoto(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cgoto(self, *args)

    cgoto = property(                                                                lambda self: self._get_cgoto() if self.op == cit_goto else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_goto,"self.op == cit_goto")                                           and self._ensure_no_obj(self._get_cgoto(),"cgoto", True)                  and self._acquire_ownership(v, True)                                  and self._set_cgoto(v))
    def _get_casm(self, *args):
        """
        _get_casm(self) -> casm_t
        """
        return _ida_hexrays.cinsn_t__get_casm(self, *args)

    def _set_casm(self, *args):
        """
        _set_casm(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_casm(self, *args)

    casm = property(                                                                lambda self: self._get_casm() if self.op == cit_asm else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_asm,"self.op == cit_asm")                                           and self._ensure_no_obj(self._get_casm(),"casm", True)                  and self._acquire_ownership(v, True)                                  and self._set_casm(v))
    def insn_is_epilog(*args):
        """
        insn_is_epilog(insn) -> bool
        """
        return _ida_hexrays.cinsn_t_insn_is_epilog(*args)

    insn_is_epilog = staticmethod(insn_is_epilog)
    def is_epilog(self):
        return cinsn_t.insn_is_epilog(self)

cinsn_t_swigregister = _ida_hexrays.cinsn_t_swigregister
cinsn_t_swigregister(cinsn_t)

def cinsn_t_insn_is_epilog(*args):
  """
  cinsn_t_insn_is_epilog(insn) -> bool
  """
  return _ida_hexrays.cinsn_t_insn_is_epilog(*args)

class cblock_t(qlist_cinsn_t):
    """
    Proxy of C++ cblock_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cblock_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cblock_t
        """
        this = _ida_hexrays.new_cblock_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cblock_t
    __del__ = lambda self : None;
    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cblock_t__deregister(self, *args)

cblock_t_swigregister = _ida_hexrays.cblock_t_swigregister
cblock_t_swigregister(cblock_t)

class carg_t(cexpr_t):
    """
    Proxy of C++ carg_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    is_vararg = _swig_property(_ida_hexrays.carg_t_is_vararg_get, _ida_hexrays.carg_t_is_vararg_set)
    formal_type = _swig_property(_ida_hexrays.carg_t_formal_type_get, _ida_hexrays.carg_t_formal_type_set)
    def consume_cexpr(self, *args):
        """
        consume_cexpr(self, e)
        """
        return _ida_hexrays.carg_t_consume_cexpr(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> carg_t
        """
        this = _ida_hexrays.new_carg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.carg_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_carg_t
    __del__ = lambda self : None;
carg_t_swigregister = _ida_hexrays.carg_t_swigregister
carg_t_swigregister(carg_t)

class carglist_t(qvector_carg_t):
    """
    Proxy of C++ carglist_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    functype = _swig_property(_ida_hexrays.carglist_t_functype_get, _ida_hexrays.carglist_t_functype_set)
    flags = _swig_property(_ida_hexrays.carglist_t_flags_get, _ida_hexrays.carglist_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> carglist_t
        __init__(self, ftype, fl=0) -> carglist_t
        """
        this = _ida_hexrays.new_carglist_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.carglist_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_carglist_t
    __del__ = lambda self : None;
carglist_t_swigregister = _ida_hexrays.carglist_t_swigregister
carglist_t_swigregister(carglist_t)
CFL_FINAL = _ida_hexrays.CFL_FINAL
"""
call type is final, should not be changed
"""
CFL_HELPER = _ida_hexrays.CFL_HELPER
"""
created from a decompiler helper function
"""

class ccase_t(cinsn_t):
    """
    Proxy of C++ ccase_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    values = _swig_property(_ida_hexrays.ccase_t_values_get, _ida_hexrays.ccase_t_values_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ccase_t_compare(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.ccase_t_size(self, *args)

    def value(self, *args):
        """
        value(self, i) -> uint64 const &
        """
        return _ida_hexrays.ccase_t_value(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ccase_t
        """
        this = _ida_hexrays.new_ccase_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ccase_t
    __del__ = lambda self : None;
ccase_t_swigregister = _ida_hexrays.ccase_t_swigregister
ccase_t_swigregister(ccase_t)

class ccases_t(qvector_ccase_t):
    """
    Proxy of C++ ccases_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ccases_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ccases_t
        """
        this = _ida_hexrays.new_ccases_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ccases_t
    __del__ = lambda self : None;
ccases_t_swigregister = _ida_hexrays.ccases_t_swigregister
ccases_t_swigregister(ccases_t)

class cswitch_t(ceinsn_t):
    """
    Proxy of C++ cswitch_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mvnf = _swig_property(_ida_hexrays.cswitch_t_mvnf_get, _ida_hexrays.cswitch_t_mvnf_set)
    cases = _swig_property(_ida_hexrays.cswitch_t_cases_get, _ida_hexrays.cswitch_t_cases_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cswitch_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cswitch_t
        """
        this = _ida_hexrays.new_cswitch_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cswitch_t
    __del__ = lambda self : None;
cswitch_t_swigregister = _ida_hexrays.cswitch_t_swigregister
cswitch_t_swigregister(cswitch_t)

class ctree_anchor_t(object):
    """
    Proxy of C++ ctree_anchor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    value = _swig_property(_ida_hexrays.ctree_anchor_t_value_get, _ida_hexrays.ctree_anchor_t_value_set)
    def __init__(self, *args):
        """
        __init__(self) -> ctree_anchor_t
        """
        this = _ida_hexrays.new_ctree_anchor_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_index(self, *args):
        """
        get_index(self) -> int
        """
        return _ida_hexrays.ctree_anchor_t_get_index(self, *args)

    def get_itp(self, *args):
        """
        get_itp(self) -> item_preciser_t
        """
        return _ida_hexrays.ctree_anchor_t_get_itp(self, *args)

    def is_valid_anchor(self, *args):
        """
        is_valid_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_valid_anchor(self, *args)

    def is_citem_anchor(self, *args):
        """
        is_citem_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_citem_anchor(self, *args)

    def is_lvar_anchor(self, *args):
        """
        is_lvar_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_lvar_anchor(self, *args)

    def is_itp_anchor(self, *args):
        """
        is_itp_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_itp_anchor(self, *args)

    def is_blkcmt_anchor(self, *args):
        """
        is_blkcmt_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_blkcmt_anchor(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_anchor_t
    __del__ = lambda self : None;
ctree_anchor_t_swigregister = _ida_hexrays.ctree_anchor_t_swigregister
ctree_anchor_t_swigregister(ctree_anchor_t)
ANCHOR_INDEX = _ida_hexrays.ANCHOR_INDEX
ANCHOR_MASK = _ida_hexrays.ANCHOR_MASK
ANCHOR_CITEM = _ida_hexrays.ANCHOR_CITEM
"""
c-tree item
"""
ANCHOR_LVAR = _ida_hexrays.ANCHOR_LVAR
"""
declaration of local variable
"""
ANCHOR_ITP = _ida_hexrays.ANCHOR_ITP
"""
item type preciser
"""
ANCHOR_BLKCMT = _ida_hexrays.ANCHOR_BLKCMT
"""
block comment (for ctree items)
"""

VDI_NONE = _ida_hexrays.VDI_NONE
VDI_EXPR = _ida_hexrays.VDI_EXPR
VDI_LVAR = _ida_hexrays.VDI_LVAR
VDI_FUNC = _ida_hexrays.VDI_FUNC
VDI_TAIL = _ida_hexrays.VDI_TAIL
class ctree_item_t(object):
    """
    Proxy of C++ ctree_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    citype = _swig_property(_ida_hexrays.ctree_item_t_citype_get, _ida_hexrays.ctree_item_t_citype_set)
    def __init__(self, *args):
        """
        __init__(self) -> ctree_item_t
        """
        this = _ida_hexrays.new_ctree_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_memptr(self, *args):
        """
        get_memptr(self, p_sptr=None) -> member_t *
        """
        return _ida_hexrays.ctree_item_t_get_memptr(self, *args)

    def get_lvar(self, *args):
        """
        get_lvar(self) -> lvar_t
        """
        return _ida_hexrays.ctree_item_t_get_lvar(self, *args)

    def get_ea(self, *args):
        """
        get_ea(self) -> ea_t
        """
        return _ida_hexrays.ctree_item_t_get_ea(self, *args)

    def get_label_num(self, *args):
        """
        get_label_num(self, gln_flags) -> int
        """
        return _ida_hexrays.ctree_item_t_get_label_num(self, *args)

    def is_citem(self, *args):
        """
        is_citem(self) -> bool
        """
        return _ida_hexrays.ctree_item_t_is_citem(self, *args)

    def _get_it(self, *args):
        """
        _get_it(self) -> citem_t
        """
        return _ida_hexrays.ctree_item_t__get_it(self, *args)

    it = property(lambda self: self._get_it())
    def _get_e(self, *args):
        """
        _get_e(self) -> cexpr_t
        """
        return _ida_hexrays.ctree_item_t__get_e(self, *args)

    e = property(lambda self: self._get_e())
    def _get_i(self, *args):
        """
        _get_i(self) -> cinsn_t
        """
        return _ida_hexrays.ctree_item_t__get_i(self, *args)

    i = property(lambda self: self._get_i())
    def _get_l(self, *args):
        """
        _get_l(self) -> lvar_t
        """
        return _ida_hexrays.ctree_item_t__get_l(self, *args)

    l = property(lambda self: self._get_l())
    def _get_f(self, *args):
        """
        _get_f(self) -> cfunc_t
        """
        return _ida_hexrays.ctree_item_t__get_f(self, *args)

    f = property(lambda self: self._get_f())
    loc = _swig_property(_ida_hexrays.ctree_item_t_loc_get)
    __swig_destroy__ = _ida_hexrays.delete_ctree_item_t
    __del__ = lambda self : None;
ctree_item_t_swigregister = _ida_hexrays.ctree_item_t_swigregister
ctree_item_t_swigregister(ctree_item_t)
GLN_CURRENT = _ida_hexrays.GLN_CURRENT
"""
get label of the current item
"""
GLN_GOTO_TARGET = _ida_hexrays.GLN_GOTO_TARGET
"""
get goto target
"""
GLN_ALL = _ida_hexrays.GLN_ALL
"""
get both
"""

FORBID_UNUSED_LABELS = _ida_hexrays.FORBID_UNUSED_LABELS
ALLOW_UNUSED_LABELS = _ida_hexrays.ALLOW_UNUSED_LABELS

def _ll_lnot(*args):
  """
  _ll_lnot(e) -> cexpr_t
  """
  return _ida_hexrays._ll_lnot(*args)

def _ll_new_block(*args):
  """
  _ll_new_block() -> cinsn_t
  """
  return _ida_hexrays._ll_new_block(*args)

def _ll_create_helper(*args):
  """
  _ll_create_helper(standalone, type, format) -> cexpr_t
  """
  return _ida_hexrays._ll_create_helper(*args)

def _ll_call_helper(*args):
  """
  _ll_call_helper(rettype, args, format) -> cexpr_t
  """
  return _ida_hexrays._ll_call_helper(*args)

def _ll_make_num(*args):
  """
  _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t
  """
  return _ida_hexrays._ll_make_num(*args)

def _ll_make_ref(*args):
  """
  _ll_make_ref(e) -> cexpr_t
  """
  return _ida_hexrays._ll_make_ref(*args)

def _ll_dereference(*args):
  """
  _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t
  """
  return _ida_hexrays._ll_dereference(*args)

def save_user_labels(*args):
  """
  save_user_labels(func_ea, user_labels)


  Save user defined labels into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param user_labels: collection of user defined labels (C++: const
                      user_labels_t *)
  """
  return _ida_hexrays.save_user_labels(*args)

def save_user_cmts(*args):
  """
  save_user_cmts(func_ea, user_cmts)


  Save user defined comments into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param user_cmts: collection of user defined comments (C++: const
                    user_cmts_t *)
  """
  return _ida_hexrays.save_user_cmts(*args)

def save_user_numforms(*args):
  """
  save_user_numforms(func_ea, numforms)


  Save user defined number formats into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param numforms: collection of user defined comments (C++: const
                   user_numforms_t *)
  """
  return _ida_hexrays.save_user_numforms(*args)

def save_user_iflags(*args):
  """
  save_user_iflags(func_ea, iflags)


  Save user defined citem iflags into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param iflags: collection of user defined citem iflags (C++: const
                 user_iflags_t *)
  """
  return _ida_hexrays.save_user_iflags(*args)

def save_user_unions(*args):
  """
  save_user_unions(func_ea, unions)


  Save user defined union field selections into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param unions: collection of union field selections (C++: const
                 user_unions_t *)
  """
  return _ida_hexrays.save_user_unions(*args)

def restore_user_labels(*args):
  """
  restore_user_labels(func_ea) -> user_labels_t


  Restore user defined labels from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined labels. The returned object must
           be deleted by the caller using delete_user_labels()
  """
  return _ida_hexrays.restore_user_labels(*args)

def restore_user_cmts(*args):
  """
  restore_user_cmts(func_ea) -> user_cmts_t


  Restore user defined comments from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined comments. The returned object must
           be deleted by the caller using delete_user_cmts()
  """
  return _ida_hexrays.restore_user_cmts(*args)

def restore_user_numforms(*args):
  """
  restore_user_numforms(func_ea) -> user_numforms_t


  Restore user defined number formats from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined number formats. The returned
           object must be deleted by the caller using
           delete_user_numforms()
  """
  return _ida_hexrays.restore_user_numforms(*args)

def restore_user_iflags(*args):
  """
  restore_user_iflags(func_ea) -> user_iflags_t


  Restore user defined citem iflags from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined iflags. The returned object must
           be deleted by the caller using delete_user_iflags()
  """
  return _ida_hexrays.restore_user_iflags(*args)

def restore_user_unions(*args):
  """
  restore_user_unions(func_ea) -> user_unions_t


  Restore user defined union field selections from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of union field selections The returned object must
           be deleted by the caller using delete_user_unions()
  """
  return _ida_hexrays.restore_user_unions(*args)
class cfunc_t(object):
    """
    Proxy of C++ cfunc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    entry_ea = _swig_property(_ida_hexrays.cfunc_t_entry_ea_get, _ida_hexrays.cfunc_t_entry_ea_set)
    mba = _swig_property(_ida_hexrays.cfunc_t_mba_get, _ida_hexrays.cfunc_t_mba_set)
    body = _swig_property(_ida_hexrays.cfunc_t_body_get, _ida_hexrays.cfunc_t_body_set)
    argidx = _swig_property(_ida_hexrays.cfunc_t_argidx_get)
    maturity = _swig_property(_ida_hexrays.cfunc_t_maturity_get, _ida_hexrays.cfunc_t_maturity_set)
    user_labels = _swig_property(_ida_hexrays.cfunc_t_user_labels_get, _ida_hexrays.cfunc_t_user_labels_set)
    user_cmts = _swig_property(_ida_hexrays.cfunc_t_user_cmts_get, _ida_hexrays.cfunc_t_user_cmts_set)
    numforms = _swig_property(_ida_hexrays.cfunc_t_numforms_get, _ida_hexrays.cfunc_t_numforms_set)
    user_iflags = _swig_property(_ida_hexrays.cfunc_t_user_iflags_get, _ida_hexrays.cfunc_t_user_iflags_set)
    user_unions = _swig_property(_ida_hexrays.cfunc_t_user_unions_get, _ida_hexrays.cfunc_t_user_unions_set)
    refcnt = _swig_property(_ida_hexrays.cfunc_t_refcnt_get, _ida_hexrays.cfunc_t_refcnt_set)
    statebits = _swig_property(_ida_hexrays.cfunc_t_statebits_get, _ida_hexrays.cfunc_t_statebits_set)
    hdrlines = _swig_property(_ida_hexrays.cfunc_t_hdrlines_get, _ida_hexrays.cfunc_t_hdrlines_set)
    treeitems = _swig_property(_ida_hexrays.cfunc_t_treeitems_get, _ida_hexrays.cfunc_t_treeitems_set)
    __swig_destroy__ = _ida_hexrays.delete_cfunc_t
    __del__ = lambda self : None;
    def release(self, *args):
        """
        release(self)
        """
        return _ida_hexrays.cfunc_t_release(self, *args)

    def build_c_tree(self, *args):
        """
        build_c_tree(self)
        """
        return _ida_hexrays.cfunc_t_build_c_tree(self, *args)

    def verify(self, *args):
        """
        verify(self, aul, even_without_debugger)
        """
        return _ida_hexrays.cfunc_t_verify(self, *args)

    def print_dcl(self, *args):
        """
        print_dcl(self)
        """
        return _ida_hexrays.cfunc_t_print_dcl(self, *args)

    def print_func(self, *args):
        """
        print_func(self, vp)
        """
        return _ida_hexrays.cfunc_t_print_func(self, *args)

    def get_func_type(self, *args):
        """
        get_func_type(self, type) -> bool
        """
        return _ida_hexrays.cfunc_t_get_func_type(self, *args)

    def get_lvars(self, *args):
        """
        get_lvars(self) -> lvars_t
        """
        return _ida_hexrays.cfunc_t_get_lvars(self, *args)

    def get_stkoff_delta(self, *args):
        """
        get_stkoff_delta(self) -> sval_t
        """
        return _ida_hexrays.cfunc_t_get_stkoff_delta(self, *args)

    def find_label(self, *args):
        """
        find_label(self, label) -> citem_t
        """
        return _ida_hexrays.cfunc_t_find_label(self, *args)

    def remove_unused_labels(self, *args):
        """
        remove_unused_labels(self)
        """
        return _ida_hexrays.cfunc_t_remove_unused_labels(self, *args)

    def get_user_cmt(self, *args):
        """
        get_user_cmt(self, loc, rt) -> char const *
        """
        return _ida_hexrays.cfunc_t_get_user_cmt(self, *args)

    def set_user_cmt(self, *args):
        """
        set_user_cmt(self, loc, cmt)
        """
        return _ida_hexrays.cfunc_t_set_user_cmt(self, *args)

    def get_user_iflags(self, *args):
        """
        get_user_iflags(self, loc) -> int32
        """
        return _ida_hexrays.cfunc_t_get_user_iflags(self, *args)

    def set_user_iflags(self, *args):
        """
        set_user_iflags(self, loc, iflags)
        """
        return _ida_hexrays.cfunc_t_set_user_iflags(self, *args)

    def has_orphan_cmts(self, *args):
        """
        has_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.cfunc_t_has_orphan_cmts(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> int
        """
        return _ida_hexrays.cfunc_t_del_orphan_cmts(self, *args)

    def get_user_union_selection(self, *args):
        """
        get_user_union_selection(self, ea, path) -> bool
        """
        return _ida_hexrays.cfunc_t_get_user_union_selection(self, *args)

    def set_user_union_selection(self, *args):
        """
        set_user_union_selection(self, ea, path)
        """
        return _ida_hexrays.cfunc_t_set_user_union_selection(self, *args)

    def save_user_labels(self, *args):
        """
        save_user_labels(self)
        """
        return _ida_hexrays.cfunc_t_save_user_labels(self, *args)

    def save_user_cmts(self, *args):
        """
        save_user_cmts(self)
        """
        return _ida_hexrays.cfunc_t_save_user_cmts(self, *args)

    def save_user_numforms(self, *args):
        """
        save_user_numforms(self)
        """
        return _ida_hexrays.cfunc_t_save_user_numforms(self, *args)

    def save_user_iflags(self, *args):
        """
        save_user_iflags(self)
        """
        return _ida_hexrays.cfunc_t_save_user_iflags(self, *args)

    def save_user_unions(self, *args):
        """
        save_user_unions(self)
        """
        return _ida_hexrays.cfunc_t_save_user_unions(self, *args)

    def get_line_item(self, *args):
        """
        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
        """
        return _ida_hexrays.cfunc_t_get_line_item(self, *args)

    def get_warnings(self, *args):
        """
        get_warnings(self) -> hexwarns_t
        """
        return _ida_hexrays.cfunc_t_get_warnings(self, *args)

    def get_eamap(self, *args):
        """
        get_eamap(self) -> eamap_t
        """
        return _ida_hexrays.cfunc_t_get_eamap(self, *args)

    def get_boundaries(self, *args):
        """
        get_boundaries(self) -> boundaries_t
        """
        return _ida_hexrays.cfunc_t_get_boundaries(self, *args)

    def get_pseudocode(self, *args):
        """
        get_pseudocode(self) -> strvec_t
        """
        return _ida_hexrays.cfunc_t_get_pseudocode(self, *args)

    def refresh_func_ctext(self, *args):
        """
        refresh_func_ctext(self)
        """
        return _ida_hexrays.cfunc_t_refresh_func_ctext(self, *args)

    def gather_derefs(self, *args):
        """
        gather_derefs(self, ci, udm=None) -> bool
        """
        return _ida_hexrays.cfunc_t_gather_derefs(self, *args)

    def find_item_coords(self, *args):
        """
        find_item_coords(self, item, px, py) -> bool
        find_item_coords(self, item) -> PyObject *
        """
        return _ida_hexrays.cfunc_t_find_item_coords(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> qstring
        """
        return _ida_hexrays.cfunc_t___str__(self, *args)

cfunc_t_swigregister = _ida_hexrays.cfunc_t_swigregister
cfunc_t_swigregister(cfunc_t)
CIT_COLLAPSED = _ida_hexrays.CIT_COLLAPSED
"""
display element in collapsed form
"""
CFS_BOUNDS = _ida_hexrays.CFS_BOUNDS
"""
'eamap' and 'boundaries' are ready
"""
CFS_TEXT = _ida_hexrays.CFS_TEXT
"""
'sv' is ready (and hdrlines)
"""
CFS_LVARS_HIDDEN = _ida_hexrays.CFS_LVARS_HIDDEN
"""
local variable definitions are collapsed
"""

DECOMP_NO_WAIT = _ida_hexrays.DECOMP_NO_WAIT
"""
do not display waitbox
"""
DECOMP_NO_CACHE = _ida_hexrays.DECOMP_NO_CACHE
"""
do not use decompilation cache
"""
DECOMP_NO_FRAME = _ida_hexrays.DECOMP_NO_FRAME
"""
do not use function frame info (only snippet mode)
"""
DECOMP_WARNINGS = _ida_hexrays.DECOMP_WARNINGS
"""
display warnings in the output window
"""

def decompile(*args):
  """
  decompile(mbr, hf, flags=0) -> cfuncptr_t


  Decompile a snippet or a function.
  
  @param mbr: what to decompile (C++: const  mba_ranges_t  &)
  @param hf: extended error information (if failed) (C++:
             hexrays_failure_t  *)
  @param flags: bitwise combination of  decompile() flags ... bits (C++:
                int)
  @return: pointer to the decompilation result (a reference counted
           pointer). NULL if failed.
  """
  return _ida_hexrays.decompile(*args)

def decompile_func(*args):
  """
  decompile_func(pfn, hf, flags=0) -> cfuncptr_t


  Decompile a function. Multiple decompilations of the same function
  return the same object.
  
  @param pfn: pointer to function to decompile (C++: func_t  *)
  @param hf: extended error information (if failed) (C++:
             hexrays_failure_t  *)
  @param flags: bitwise combination of  decompile() flags ... bits (C++:
                int)
  @return: pointer to the decompilation result (a reference counted
           pointer). NULL if failed.
  """
  return _ida_hexrays.decompile_func(*args)

def gen_microcode(*args):
  """
  gen_microcode(mbr, hf, retlist=None, flags=0, reqmat=MMAT_GLBOPT3) -> mbl_array_t


  Generate microcode of an arbitrary code snippet
  
  @param mbr: snippet ranges (C++: const  mba_ranges_t  &)
  @param hf: extended error information (if failed) (C++:
             hexrays_failure_t  *)
  @param retlist: list of registers the snippet returns (C++: const
                  mlist_t  *)
  @param flags: bitwise combination of  decompile() flags ... bits (C++:
                int)
  @param reqmat: required microcode maturity (C++: mba_maturity_t)
  @return: pointer to the microcode, NULL if failed.
  """
  return _ida_hexrays.gen_microcode(*args)

def mark_cfunc_dirty(*args):
  """
  mark_cfunc_dirty(ea, close_views=False) -> bool


  Flush the cached decompilation results. Erases a cache entry for the
  specified function.
  
  @param ea: function to erase from the cache (C++: ea_t)
  @param close_views: close pseudocode windows that show the function
                      (C++: bool)
  @return: if a cache entry existed.
  """
  return _ida_hexrays.mark_cfunc_dirty(*args)

def clear_cached_cfuncs(*args):
  """
  clear_cached_cfuncs()


  Flush all cached decompilation results.
  """
  return _ida_hexrays.clear_cached_cfuncs(*args)

def has_cached_cfunc(*args):
  """
  has_cached_cfunc(ea) -> bool


  Do we have a cached decompilation result for 'ea'?
  
  
  @param ea (C++: ea_t)
  """
  return _ida_hexrays.has_cached_cfunc(*args)

def get_ctype_name(*args):
  """
  get_ctype_name(op) -> char const *
  """
  return _ida_hexrays.get_ctype_name(*args)

def create_field_name(*args):
  """
  create_field_name(type, offset=BADADDR) -> qstring
  """
  return _ida_hexrays.create_field_name(*args)
hxe_flowchart = _ida_hexrays.hxe_flowchart
hxe_stkpnts = _ida_hexrays.hxe_stkpnts
hxe_prolog = _ida_hexrays.hxe_prolog
hxe_microcode = _ida_hexrays.hxe_microcode
hxe_preoptimized = _ida_hexrays.hxe_preoptimized
hxe_locopt = _ida_hexrays.hxe_locopt
hxe_prealloc = _ida_hexrays.hxe_prealloc
hxe_glbopt = _ida_hexrays.hxe_glbopt
hxe_structural = _ida_hexrays.hxe_structural
hxe_maturity = _ida_hexrays.hxe_maturity
hxe_interr = _ida_hexrays.hxe_interr
hxe_combine = _ida_hexrays.hxe_combine
hxe_print_func = _ida_hexrays.hxe_print_func
hxe_func_printed = _ida_hexrays.hxe_func_printed
hxe_resolve_stkaddrs = _ida_hexrays.hxe_resolve_stkaddrs
hxe_open_pseudocode = _ida_hexrays.hxe_open_pseudocode
hxe_switch_pseudocode = _ida_hexrays.hxe_switch_pseudocode
hxe_refresh_pseudocode = _ida_hexrays.hxe_refresh_pseudocode
hxe_close_pseudocode = _ida_hexrays.hxe_close_pseudocode
hxe_keyboard = _ida_hexrays.hxe_keyboard
hxe_right_click = _ida_hexrays.hxe_right_click
hxe_double_click = _ida_hexrays.hxe_double_click
hxe_curpos = _ida_hexrays.hxe_curpos
hxe_create_hint = _ida_hexrays.hxe_create_hint
hxe_text_ready = _ida_hexrays.hxe_text_ready
hxe_populating_popup = _ida_hexrays.hxe_populating_popup
lxe_lvar_name_changed = _ida_hexrays.lxe_lvar_name_changed
lxe_lvar_type_changed = _ida_hexrays.lxe_lvar_type_changed
lxe_lvar_cmt_changed = _ida_hexrays.lxe_lvar_cmt_changed
lxe_lvar_mapping_changed = _ida_hexrays.lxe_lvar_mapping_changed
hxe_cmt_changed = _ida_hexrays.hxe_cmt_changed
USE_KEYBOARD = _ida_hexrays.USE_KEYBOARD
USE_MOUSE = _ida_hexrays.USE_MOUSE
class ctext_position_t(object):
    """
    Proxy of C++ ctext_position_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lnnum = _swig_property(_ida_hexrays.ctext_position_t_lnnum_get, _ida_hexrays.ctext_position_t_lnnum_set)
    x = _swig_property(_ida_hexrays.ctext_position_t_x_get, _ida_hexrays.ctext_position_t_x_set)
    y = _swig_property(_ida_hexrays.ctext_position_t_y_get, _ida_hexrays.ctext_position_t_y_set)
    def in_ctree(self, *args):
        """
        in_ctree(self, hdrlines) -> bool
        """
        return _ida_hexrays.ctext_position_t_in_ctree(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ctext_position_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
        """
        this = _ida_hexrays.new_ctext_position_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ctext_position_t
    __del__ = lambda self : None;
ctext_position_t_swigregister = _ida_hexrays.ctext_position_t_swigregister
ctext_position_t_swigregister(ctext_position_t)
HEXRAYS_API_MAGIC = cvar.HEXRAYS_API_MAGIC

class history_item_t(ctext_position_t):
    """
    Proxy of C++ history_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.history_item_t_ea_get, _ida_hexrays.history_item_t_ea_set)
    end = _swig_property(_ida_hexrays.history_item_t_end_get, _ida_hexrays.history_item_t_end_set)
    def __init__(self, *args):
        """
        __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
        __init__(self, _ea, p) -> history_item_t
        """
        this = _ida_hexrays.new_history_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_history_item_t
    __del__ = lambda self : None;
history_item_t_swigregister = _ida_hexrays.history_item_t_swigregister
history_item_t_swigregister(history_item_t)

class vdui_t(object):
    """
    Proxy of C++ vdui_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    flags = _swig_property(_ida_hexrays.vdui_t_flags_get, _ida_hexrays.vdui_t_flags_set)
    def visible(self, *args):
        """
        visible(self) -> bool
        """
        return _ida_hexrays.vdui_t_visible(self, *args)

    def valid(self, *args):
        """
        valid(self) -> bool
        """
        return _ida_hexrays.vdui_t_valid(self, *args)

    def locked(self, *args):
        """
        locked(self) -> bool
        """
        return _ida_hexrays.vdui_t_locked(self, *args)

    def set_visible(self, *args):
        """
        set_visible(self, v)
        """
        return _ida_hexrays.vdui_t_set_visible(self, *args)

    def set_valid(self, *args):
        """
        set_valid(self, v)
        """
        return _ida_hexrays.vdui_t_set_valid(self, *args)

    def set_locked(self, *args):
        """
        set_locked(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_set_locked(self, *args)

    view_idx = _swig_property(_ida_hexrays.vdui_t_view_idx_get, _ida_hexrays.vdui_t_view_idx_set)
    ct = _swig_property(_ida_hexrays.vdui_t_ct_get, _ida_hexrays.vdui_t_ct_set)
    toplevel = _swig_property(_ida_hexrays.vdui_t_toplevel_get, _ida_hexrays.vdui_t_toplevel_set)
    mba = _swig_property(_ida_hexrays.vdui_t_mba_get, _ida_hexrays.vdui_t_mba_set)
    cfunc = _swig_property(_ida_hexrays.vdui_t_cfunc_get, _ida_hexrays.vdui_t_cfunc_set)
    last_code = _swig_property(_ida_hexrays.vdui_t_last_code_get, _ida_hexrays.vdui_t_last_code_set)
    cpos = _swig_property(_ida_hexrays.vdui_t_cpos_get, _ida_hexrays.vdui_t_cpos_set)
    head = _swig_property(_ida_hexrays.vdui_t_head_get, _ida_hexrays.vdui_t_head_set)
    item = _swig_property(_ida_hexrays.vdui_t_item_get, _ida_hexrays.vdui_t_item_set)
    tail = _swig_property(_ida_hexrays.vdui_t_tail_get, _ida_hexrays.vdui_t_tail_set)
    def refresh_view(self, *args):
        """
        refresh_view(self, redo_mba)
        """
        return _ida_hexrays.vdui_t_refresh_view(self, *args)

    def refresh_ctext(self, *args):
        """
        refresh_ctext(self, activate=True)
        """
        return _ida_hexrays.vdui_t_refresh_ctext(self, *args)

    def switch_to(self, *args):
        """
        switch_to(self, f, activate)
        """
        return _ida_hexrays.vdui_t_switch_to(self, *args)

    def in_ctree(self, *args):
        """
        in_ctree(self) -> bool
        """
        return _ida_hexrays.vdui_t_in_ctree(self, *args)

    def get_number(self, *args):
        """
        get_number(self) -> cnumber_t
        """
        return _ida_hexrays.vdui_t_get_number(self, *args)

    def get_current_label(self, *args):
        """
        get_current_label(self) -> int
        """
        return _ida_hexrays.vdui_t_get_current_label(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.vdui_t_clear(self, *args)

    def refresh_cpos(self, *args):
        """
        refresh_cpos(self, idv) -> bool
        """
        return _ida_hexrays.vdui_t_refresh_cpos(self, *args)

    def get_current_item(self, *args):
        """
        get_current_item(self, idv) -> bool
        """
        return _ida_hexrays.vdui_t_get_current_item(self, *args)

    def ui_rename_lvar(self, *args):
        """
        ui_rename_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_rename_lvar(self, *args)

    def rename_lvar(self, *args):
        """
        rename_lvar(self, v, name, is_user_name) -> bool
        """
        return _ida_hexrays.vdui_t_rename_lvar(self, *args)

    def ui_set_call_type(self, *args):
        """
        ui_set_call_type(self, e) -> bool
        """
        return _ida_hexrays.vdui_t_ui_set_call_type(self, *args)

    def ui_set_lvar_type(self, *args):
        """
        ui_set_lvar_type(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_set_lvar_type(self, *args)

    def set_lvar_type(self, *args):
        """
        set_lvar_type(self, v, type) -> bool
        """
        return _ida_hexrays.vdui_t_set_lvar_type(self, *args)

    def set_noptr_lvar(self, *args):
        """
        set_noptr_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_set_noptr_lvar(self, *args)

    def ui_edit_lvar_cmt(self, *args):
        """
        ui_edit_lvar_cmt(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_edit_lvar_cmt(self, *args)

    def set_lvar_cmt(self, *args):
        """
        set_lvar_cmt(self, v, cmt) -> bool
        """
        return _ida_hexrays.vdui_t_set_lvar_cmt(self, *args)

    def ui_map_lvar(self, *args):
        """
        ui_map_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_map_lvar(self, *args)

    def ui_unmap_lvar(self, *args):
        """
        ui_unmap_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_unmap_lvar(self, *args)

    def map_lvar(self, *args):
        """
        map_lvar(self, frm, to) -> bool
        """
        return _ida_hexrays.vdui_t_map_lvar(self, *args)

    def set_strmem_type(self, *args):
        """
        set_strmem_type(self, sptr, mptr) -> bool
        """
        return _ida_hexrays.vdui_t_set_strmem_type(self, *args)

    def rename_strmem(self, *args):
        """
        rename_strmem(self, sptr, mptr) -> bool
        """
        return _ida_hexrays.vdui_t_rename_strmem(self, *args)

    def set_global_type(self, *args):
        """
        set_global_type(self, ea) -> bool
        """
        return _ida_hexrays.vdui_t_set_global_type(self, *args)

    def rename_global(self, *args):
        """
        rename_global(self, ea) -> bool
        """
        return _ida_hexrays.vdui_t_rename_global(self, *args)

    def rename_label(self, *args):
        """
        rename_label(self, label) -> bool
        """
        return _ida_hexrays.vdui_t_rename_label(self, *args)

    def jump_enter(self, *args):
        """
        jump_enter(self, idv, omflags) -> bool
        """
        return _ida_hexrays.vdui_t_jump_enter(self, *args)

    def ctree_to_disasm(self, *args):
        """
        ctree_to_disasm(self) -> bool
        """
        return _ida_hexrays.vdui_t_ctree_to_disasm(self, *args)

    def calc_cmt_type(self, *args):
        """
        calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
        """
        return _ida_hexrays.vdui_t_calc_cmt_type(self, *args)

    def edit_cmt(self, *args):
        """
        edit_cmt(self, loc) -> bool
        """
        return _ida_hexrays.vdui_t_edit_cmt(self, *args)

    def edit_func_cmt(self, *args):
        """
        edit_func_cmt(self) -> bool
        """
        return _ida_hexrays.vdui_t_edit_func_cmt(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.vdui_t_del_orphan_cmts(self, *args)

    def set_num_radix(self, *args):
        """
        set_num_radix(self, base) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_radix(self, *args)

    def set_num_enum(self, *args):
        """
        set_num_enum(self) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_enum(self, *args)

    def set_num_stroff(self, *args):
        """
        set_num_stroff(self) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_stroff(self, *args)

    def invert_sign(self, *args):
        """
        invert_sign(self) -> bool
        """
        return _ida_hexrays.vdui_t_invert_sign(self, *args)

    def invert_bits(self, *args):
        """
        invert_bits(self) -> bool
        """
        return _ida_hexrays.vdui_t_invert_bits(self, *args)

    def collapse_item(self, *args):
        """
        collapse_item(self, hide) -> bool
        """
        return _ida_hexrays.vdui_t_collapse_item(self, *args)

    def collapse_lvars(self, *args):
        """
        collapse_lvars(self, hide) -> bool
        """
        return _ida_hexrays.vdui_t_collapse_lvars(self, *args)

    def split_item(self, *args):
        """
        split_item(self, split) -> bool
        """
        return _ida_hexrays.vdui_t_split_item(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vdui_t
    __del__ = lambda self : None;
vdui_t_swigregister = _ida_hexrays.vdui_t_swigregister
vdui_t_swigregister(vdui_t)
CMT_NONE = cvar.CMT_NONE
CMT_TAIL = cvar.CMT_TAIL
CMT_BLOCK1 = cvar.CMT_BLOCK1
CMT_BLOCK2 = cvar.CMT_BLOCK2
CMT_LVAR = cvar.CMT_LVAR
CMT_FUNC = cvar.CMT_FUNC
CMT_ALL = cvar.CMT_ALL
VDUI_VISIBLE = _ida_hexrays.VDUI_VISIBLE
"""
is visible?
"""
VDUI_VALID = _ida_hexrays.VDUI_VALID
"""
is valid?
"""
VDUI_LOCKED = _ida_hexrays.VDUI_LOCKED
"""
is locked?
"""

class ui_stroff_op_t(object):
    """
    Proxy of C++ ui_stroff_op_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_ida_hexrays.ui_stroff_op_t_text_get, _ida_hexrays.ui_stroff_op_t_text_set)
    offset = _swig_property(_ida_hexrays.ui_stroff_op_t_offset_get, _ida_hexrays.ui_stroff_op_t_offset_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ui_stroff_op_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ui_stroff_op_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ui_stroff_op_t
        """
        this = _ida_hexrays.new_ui_stroff_op_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ui_stroff_op_t
    __del__ = lambda self : None;
ui_stroff_op_t_swigregister = _ida_hexrays.ui_stroff_op_t_swigregister
ui_stroff_op_t_swigregister(ui_stroff_op_t)

class ui_stroff_applicator_t(object):
    """
    Proxy of C++ ui_stroff_applicator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def apply(self, *args):
        """
        apply(self, opnum, path) -> bool
        """
        return _ida_hexrays.ui_stroff_applicator_t_apply(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ui_stroff_applicator_t
        """
        if self.__class__ == ui_stroff_applicator_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_ui_stroff_applicator_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ui_stroff_applicator_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_ui_stroff_applicator_t(self)
        return weakref_proxy(self)
ui_stroff_applicator_t_swigregister = _ida_hexrays.ui_stroff_applicator_t_swigregister
ui_stroff_applicator_t_swigregister(ui_stroff_applicator_t)


def select_udt_by_offset(*args):
  """
  select_udt_by_offset(udts, ops, applicator) -> int


  Select UDT
  
  @param udts: list of UDT  tinfo_t  for the selection, if NULL or empty
               then UDTs from the "Local types" will be used (C++: const
               qvector <  tinfo_t  > *)
  @param ops: operands (C++: const  ui_stroff_ops_t  &)
  @param applicator (C++: ui_stroff_applicator_t  &)
  """
  return _ida_hexrays.select_udt_by_offset(*args)
hx_user_numforms_begin = _ida_hexrays.hx_user_numforms_begin
hx_user_numforms_end = _ida_hexrays.hx_user_numforms_end
hx_user_numforms_next = _ida_hexrays.hx_user_numforms_next
hx_user_numforms_prev = _ida_hexrays.hx_user_numforms_prev
hx_user_numforms_first = _ida_hexrays.hx_user_numforms_first
hx_user_numforms_second = _ida_hexrays.hx_user_numforms_second
hx_user_numforms_find = _ida_hexrays.hx_user_numforms_find
hx_user_numforms_insert = _ida_hexrays.hx_user_numforms_insert
hx_user_numforms_erase = _ida_hexrays.hx_user_numforms_erase
hx_user_numforms_clear = _ida_hexrays.hx_user_numforms_clear
hx_user_numforms_size = _ida_hexrays.hx_user_numforms_size
hx_user_numforms_free = _ida_hexrays.hx_user_numforms_free
hx_user_numforms_new = _ida_hexrays.hx_user_numforms_new
hx_lvar_mapping_begin = _ida_hexrays.hx_lvar_mapping_begin
hx_lvar_mapping_end = _ida_hexrays.hx_lvar_mapping_end
hx_lvar_mapping_next = _ida_hexrays.hx_lvar_mapping_next
hx_lvar_mapping_prev = _ida_hexrays.hx_lvar_mapping_prev
hx_lvar_mapping_first = _ida_hexrays.hx_lvar_mapping_first
hx_lvar_mapping_second = _ida_hexrays.hx_lvar_mapping_second
hx_lvar_mapping_find = _ida_hexrays.hx_lvar_mapping_find
hx_lvar_mapping_insert = _ida_hexrays.hx_lvar_mapping_insert
hx_lvar_mapping_erase = _ida_hexrays.hx_lvar_mapping_erase
hx_lvar_mapping_clear = _ida_hexrays.hx_lvar_mapping_clear
hx_lvar_mapping_size = _ida_hexrays.hx_lvar_mapping_size
hx_lvar_mapping_free = _ida_hexrays.hx_lvar_mapping_free
hx_lvar_mapping_new = _ida_hexrays.hx_lvar_mapping_new
hx_udcall_map_begin = _ida_hexrays.hx_udcall_map_begin
hx_udcall_map_end = _ida_hexrays.hx_udcall_map_end
hx_udcall_map_next = _ida_hexrays.hx_udcall_map_next
hx_udcall_map_prev = _ida_hexrays.hx_udcall_map_prev
hx_udcall_map_first = _ida_hexrays.hx_udcall_map_first
hx_udcall_map_second = _ida_hexrays.hx_udcall_map_second
hx_udcall_map_find = _ida_hexrays.hx_udcall_map_find
hx_udcall_map_insert = _ida_hexrays.hx_udcall_map_insert
hx_udcall_map_erase = _ida_hexrays.hx_udcall_map_erase
hx_udcall_map_clear = _ida_hexrays.hx_udcall_map_clear
hx_udcall_map_size = _ida_hexrays.hx_udcall_map_size
hx_udcall_map_free = _ida_hexrays.hx_udcall_map_free
hx_udcall_map_new = _ida_hexrays.hx_udcall_map_new
hx_user_cmts_begin = _ida_hexrays.hx_user_cmts_begin
hx_user_cmts_end = _ida_hexrays.hx_user_cmts_end
hx_user_cmts_next = _ida_hexrays.hx_user_cmts_next
hx_user_cmts_prev = _ida_hexrays.hx_user_cmts_prev
hx_user_cmts_first = _ida_hexrays.hx_user_cmts_first
hx_user_cmts_second = _ida_hexrays.hx_user_cmts_second
hx_user_cmts_find = _ida_hexrays.hx_user_cmts_find
hx_user_cmts_insert = _ida_hexrays.hx_user_cmts_insert
hx_user_cmts_erase = _ida_hexrays.hx_user_cmts_erase
hx_user_cmts_clear = _ida_hexrays.hx_user_cmts_clear
hx_user_cmts_size = _ida_hexrays.hx_user_cmts_size
hx_user_cmts_free = _ida_hexrays.hx_user_cmts_free
hx_user_cmts_new = _ida_hexrays.hx_user_cmts_new
hx_user_iflags_begin = _ida_hexrays.hx_user_iflags_begin
hx_user_iflags_end = _ida_hexrays.hx_user_iflags_end
hx_user_iflags_next = _ida_hexrays.hx_user_iflags_next
hx_user_iflags_prev = _ida_hexrays.hx_user_iflags_prev
hx_user_iflags_first = _ida_hexrays.hx_user_iflags_first
hx_user_iflags_second = _ida_hexrays.hx_user_iflags_second
hx_user_iflags_find = _ida_hexrays.hx_user_iflags_find
hx_user_iflags_insert = _ida_hexrays.hx_user_iflags_insert
hx_user_iflags_erase = _ida_hexrays.hx_user_iflags_erase
hx_user_iflags_clear = _ida_hexrays.hx_user_iflags_clear
hx_user_iflags_size = _ida_hexrays.hx_user_iflags_size
hx_user_iflags_free = _ida_hexrays.hx_user_iflags_free
hx_user_iflags_new = _ida_hexrays.hx_user_iflags_new
hx_user_unions_begin = _ida_hexrays.hx_user_unions_begin
hx_user_unions_end = _ida_hexrays.hx_user_unions_end
hx_user_unions_next = _ida_hexrays.hx_user_unions_next
hx_user_unions_prev = _ida_hexrays.hx_user_unions_prev
hx_user_unions_first = _ida_hexrays.hx_user_unions_first
hx_user_unions_second = _ida_hexrays.hx_user_unions_second
hx_user_unions_find = _ida_hexrays.hx_user_unions_find
hx_user_unions_insert = _ida_hexrays.hx_user_unions_insert
hx_user_unions_erase = _ida_hexrays.hx_user_unions_erase
hx_user_unions_clear = _ida_hexrays.hx_user_unions_clear
hx_user_unions_size = _ida_hexrays.hx_user_unions_size
hx_user_unions_free = _ida_hexrays.hx_user_unions_free
hx_user_unions_new = _ida_hexrays.hx_user_unions_new
hx_user_labels_begin = _ida_hexrays.hx_user_labels_begin
hx_user_labels_end = _ida_hexrays.hx_user_labels_end
hx_user_labels_next = _ida_hexrays.hx_user_labels_next
hx_user_labels_prev = _ida_hexrays.hx_user_labels_prev
hx_user_labels_first = _ida_hexrays.hx_user_labels_first
hx_user_labels_second = _ida_hexrays.hx_user_labels_second
hx_user_labels_find = _ida_hexrays.hx_user_labels_find
hx_user_labels_insert = _ida_hexrays.hx_user_labels_insert
hx_user_labels_erase = _ida_hexrays.hx_user_labels_erase
hx_user_labels_clear = _ida_hexrays.hx_user_labels_clear
hx_user_labels_size = _ida_hexrays.hx_user_labels_size
hx_user_labels_free = _ida_hexrays.hx_user_labels_free
hx_user_labels_new = _ida_hexrays.hx_user_labels_new
hx_eamap_begin = _ida_hexrays.hx_eamap_begin
hx_eamap_end = _ida_hexrays.hx_eamap_end
hx_eamap_next = _ida_hexrays.hx_eamap_next
hx_eamap_prev = _ida_hexrays.hx_eamap_prev
hx_eamap_first = _ida_hexrays.hx_eamap_first
hx_eamap_second = _ida_hexrays.hx_eamap_second
hx_eamap_find = _ida_hexrays.hx_eamap_find
hx_eamap_insert = _ida_hexrays.hx_eamap_insert
hx_eamap_erase = _ida_hexrays.hx_eamap_erase
hx_eamap_clear = _ida_hexrays.hx_eamap_clear
hx_eamap_size = _ida_hexrays.hx_eamap_size
hx_eamap_free = _ida_hexrays.hx_eamap_free
hx_eamap_new = _ida_hexrays.hx_eamap_new
hx_boundaries_begin = _ida_hexrays.hx_boundaries_begin
hx_boundaries_end = _ida_hexrays.hx_boundaries_end
hx_boundaries_next = _ida_hexrays.hx_boundaries_next
hx_boundaries_prev = _ida_hexrays.hx_boundaries_prev
hx_boundaries_first = _ida_hexrays.hx_boundaries_first
hx_boundaries_second = _ida_hexrays.hx_boundaries_second
hx_boundaries_find = _ida_hexrays.hx_boundaries_find
hx_boundaries_insert = _ida_hexrays.hx_boundaries_insert
hx_boundaries_erase = _ida_hexrays.hx_boundaries_erase
hx_boundaries_clear = _ida_hexrays.hx_boundaries_clear
hx_boundaries_size = _ida_hexrays.hx_boundaries_size
hx_boundaries_free = _ida_hexrays.hx_boundaries_free
hx_boundaries_new = _ida_hexrays.hx_boundaries_new
hx_block_chains_begin = _ida_hexrays.hx_block_chains_begin
hx_block_chains_end = _ida_hexrays.hx_block_chains_end
hx_block_chains_next = _ida_hexrays.hx_block_chains_next
hx_block_chains_prev = _ida_hexrays.hx_block_chains_prev
hx_block_chains_get = _ida_hexrays.hx_block_chains_get
hx_block_chains_find = _ida_hexrays.hx_block_chains_find
hx_block_chains_insert = _ida_hexrays.hx_block_chains_insert
hx_block_chains_erase = _ida_hexrays.hx_block_chains_erase
hx_block_chains_clear = _ida_hexrays.hx_block_chains_clear
hx_block_chains_size = _ida_hexrays.hx_block_chains_size
hx_block_chains_free = _ida_hexrays.hx_block_chains_free
hx_block_chains_new = _ida_hexrays.hx_block_chains_new
hx_valrng_t_clear = _ida_hexrays.hx_valrng_t_clear
hx_valrng_t_copy = _ida_hexrays.hx_valrng_t_copy
hx_valrng_t_assign = _ida_hexrays.hx_valrng_t_assign
hx_valrng_t_compare = _ida_hexrays.hx_valrng_t_compare
hx_valrng_t_set_eq = _ida_hexrays.hx_valrng_t_set_eq
hx_valrng_t_set_cmp = _ida_hexrays.hx_valrng_t_set_cmp
hx_valrng_t_reduce_size = _ida_hexrays.hx_valrng_t_reduce_size
hx_valrng_t_intersect_with = _ida_hexrays.hx_valrng_t_intersect_with
hx_valrng_t_unite_with = _ida_hexrays.hx_valrng_t_unite_with
hx_valrng_t_inverse = _ida_hexrays.hx_valrng_t_inverse
hx_valrng_t_has = _ida_hexrays.hx_valrng_t_has
hx_valrng_t_print = _ida_hexrays.hx_valrng_t_print
hx_valrng_t_dstr = _ida_hexrays.hx_valrng_t_dstr
hx_valrng_t_cvt_to_single_value = _ida_hexrays.hx_valrng_t_cvt_to_single_value
hx_valrng_t_cvt_to_cmp = _ida_hexrays.hx_valrng_t_cvt_to_cmp
hx_get_merror_desc = _ida_hexrays.hx_get_merror_desc
hx_reg2mreg = _ida_hexrays.hx_reg2mreg
hx_mreg2reg = _ida_hexrays.hx_mreg2reg
hx_install_optinsn_handler = _ida_hexrays.hx_install_optinsn_handler
hx_remove_optinsn_handler = _ida_hexrays.hx_remove_optinsn_handler
hx_install_optblock_handler = _ida_hexrays.hx_install_optblock_handler
hx_remove_optblock_handler = _ida_hexrays.hx_remove_optblock_handler
hx_must_mcode_close_block = _ida_hexrays.hx_must_mcode_close_block
hx_is_mcode_propagatable = _ida_hexrays.hx_is_mcode_propagatable
hx_negate_mcode_relation = _ida_hexrays.hx_negate_mcode_relation
hx_swap_mcode_relation = _ida_hexrays.hx_swap_mcode_relation
hx_get_signed_mcode = _ida_hexrays.hx_get_signed_mcode
hx_get_unsigned_mcode = _ida_hexrays.hx_get_unsigned_mcode
hx_mcode_modifies_d = _ida_hexrays.hx_mcode_modifies_d
hx_operand_locator_t_compare = _ida_hexrays.hx_operand_locator_t_compare
hx_vd_printer_t_print = _ida_hexrays.hx_vd_printer_t_print
hx_file_printer_t_print = _ida_hexrays.hx_file_printer_t_print
hx_qstring_printer_t_print = _ida_hexrays.hx_qstring_printer_t_print
hx_dstr = _ida_hexrays.hx_dstr
hx_is_type_correct = _ida_hexrays.hx_is_type_correct
hx_is_small_udt = _ida_hexrays.hx_is_small_udt
hx_is_nonbool_type = _ida_hexrays.hx_is_nonbool_type
hx_is_bool_type = _ida_hexrays.hx_is_bool_type
hx_partial_type_num = _ida_hexrays.hx_partial_type_num
hx_get_float_type = _ida_hexrays.hx_get_float_type
hx_get_int_type_by_width_and_sign = _ida_hexrays.hx_get_int_type_by_width_and_sign
hx_get_unk_type = _ida_hexrays.hx_get_unk_type
hx_dummy_ptrtype = _ida_hexrays.hx_dummy_ptrtype
hx_get_member_type = _ida_hexrays.hx_get_member_type
hx_make_pointer = _ida_hexrays.hx_make_pointer
hx_create_typedef = _ida_hexrays.hx_create_typedef
hx_get_type = _ida_hexrays.hx_get_type
hx_set_type = _ida_hexrays.hx_set_type
hx_vdloc_t_dstr = _ida_hexrays.hx_vdloc_t_dstr
hx_vdloc_t_compare = _ida_hexrays.hx_vdloc_t_compare
hx_vdloc_t_is_aliasable = _ida_hexrays.hx_vdloc_t_is_aliasable
hx_print_vdloc = _ida_hexrays.hx_print_vdloc
hx_arglocs_overlap = _ida_hexrays.hx_arglocs_overlap
hx_lvar_locator_t_compare = _ida_hexrays.hx_lvar_locator_t_compare
hx_lvar_locator_t_dstr = _ida_hexrays.hx_lvar_locator_t_dstr
hx_lvar_t_dstr = _ida_hexrays.hx_lvar_t_dstr
hx_lvar_t_is_promoted_arg = _ida_hexrays.hx_lvar_t_is_promoted_arg
hx_lvar_t_accepts_type = _ida_hexrays.hx_lvar_t_accepts_type
hx_lvar_t_set_lvar_type = _ida_hexrays.hx_lvar_t_set_lvar_type
hx_lvar_t_set_width = _ida_hexrays.hx_lvar_t_set_width
hx_lvar_t_append_list = _ida_hexrays.hx_lvar_t_append_list
hx_lvars_t_find_stkvar = _ida_hexrays.hx_lvars_t_find_stkvar
hx_lvars_t_find = _ida_hexrays.hx_lvars_t_find
hx_lvars_t_find_lvar = _ida_hexrays.hx_lvars_t_find_lvar
hx_restore_user_lvar_settings = _ida_hexrays.hx_restore_user_lvar_settings
hx_save_user_lvar_settings = _ida_hexrays.hx_save_user_lvar_settings
hx_modify_user_lvars = _ida_hexrays.hx_modify_user_lvars
hx_restore_user_defined_calls = _ida_hexrays.hx_restore_user_defined_calls
hx_save_user_defined_calls = _ida_hexrays.hx_save_user_defined_calls
hx_parse_user_call = _ida_hexrays.hx_parse_user_call
hx_convert_to_user_call = _ida_hexrays.hx_convert_to_user_call
hx_install_microcode_filter = _ida_hexrays.hx_install_microcode_filter
hx_udc_filter_t_init = _ida_hexrays.hx_udc_filter_t_init
hx_udc_filter_t_apply = _ida_hexrays.hx_udc_filter_t_apply
hx_bitset_t_bitset_t = _ida_hexrays.hx_bitset_t_bitset_t
hx_bitset_t_copy = _ida_hexrays.hx_bitset_t_copy
hx_bitset_t_add = _ida_hexrays.hx_bitset_t_add
hx_bitset_t_add_ = _ida_hexrays.hx_bitset_t_add_
hx_bitset_t_add__ = _ida_hexrays.hx_bitset_t_add__
hx_bitset_t_sub = _ida_hexrays.hx_bitset_t_sub
hx_bitset_t_sub_ = _ida_hexrays.hx_bitset_t_sub_
hx_bitset_t_sub__ = _ida_hexrays.hx_bitset_t_sub__
hx_bitset_t_cut_at = _ida_hexrays.hx_bitset_t_cut_at
hx_bitset_t_shift_down = _ida_hexrays.hx_bitset_t_shift_down
hx_bitset_t_has = _ida_hexrays.hx_bitset_t_has
hx_bitset_t_has_all = _ida_hexrays.hx_bitset_t_has_all
hx_bitset_t_has_any = _ida_hexrays.hx_bitset_t_has_any
hx_bitset_t_dstr = _ida_hexrays.hx_bitset_t_dstr
hx_bitset_t_empty = _ida_hexrays.hx_bitset_t_empty
hx_bitset_t_count = _ida_hexrays.hx_bitset_t_count
hx_bitset_t_count_ = _ida_hexrays.hx_bitset_t_count_
hx_bitset_t_last = _ida_hexrays.hx_bitset_t_last
hx_bitset_t_fill_with_ones = _ida_hexrays.hx_bitset_t_fill_with_ones
hx_bitset_t_has_common = _ida_hexrays.hx_bitset_t_has_common
hx_bitset_t_intersect = _ida_hexrays.hx_bitset_t_intersect
hx_bitset_t_is_subset_of = _ida_hexrays.hx_bitset_t_is_subset_of
hx_bitset_t_compare = _ida_hexrays.hx_bitset_t_compare
hx_bitset_t_goup = _ida_hexrays.hx_bitset_t_goup
hx_ivl_t_dstr = _ida_hexrays.hx_ivl_t_dstr
hx_ivl_t_compare = _ida_hexrays.hx_ivl_t_compare
hx_ivlset_t_add = _ida_hexrays.hx_ivlset_t_add
hx_ivlset_t_add_ = _ida_hexrays.hx_ivlset_t_add_
hx_ivlset_t_addmasked = _ida_hexrays.hx_ivlset_t_addmasked
hx_ivlset_t_sub = _ida_hexrays.hx_ivlset_t_sub
hx_ivlset_t_sub_ = _ida_hexrays.hx_ivlset_t_sub_
hx_ivlset_t_has_common = _ida_hexrays.hx_ivlset_t_has_common
hx_ivlset_t_print = _ida_hexrays.hx_ivlset_t_print
hx_ivlset_t_dstr = _ida_hexrays.hx_ivlset_t_dstr
hx_ivlset_t_count = _ida_hexrays.hx_ivlset_t_count
hx_ivlset_t_has_common_ = _ida_hexrays.hx_ivlset_t_has_common_
hx_ivlset_t_contains = _ida_hexrays.hx_ivlset_t_contains
hx_ivlset_t_includes = _ida_hexrays.hx_ivlset_t_includes
hx_ivlset_t_intersect = _ida_hexrays.hx_ivlset_t_intersect
hx_ivlset_t_compare = _ida_hexrays.hx_ivlset_t_compare
hx_get_mreg_name = _ida_hexrays.hx_get_mreg_name
hx_rlist_t_print = _ida_hexrays.hx_rlist_t_print
hx_rlist_t_dstr = _ida_hexrays.hx_rlist_t_dstr
hx_mlist_t_addmem = _ida_hexrays.hx_mlist_t_addmem
hx_mlist_t_print = _ida_hexrays.hx_mlist_t_print
hx_mlist_t_dstr = _ida_hexrays.hx_mlist_t_dstr
hx_mlist_t_compare = _ida_hexrays.hx_mlist_t_compare
hx_lvar_ref_t_compare = _ida_hexrays.hx_lvar_ref_t_compare
hx_lvar_ref_t_var = _ida_hexrays.hx_lvar_ref_t_var
hx_stkvar_ref_t_compare = _ida_hexrays.hx_stkvar_ref_t_compare
hx_stkvar_ref_t_get_stkvar = _ida_hexrays.hx_stkvar_ref_t_get_stkvar
hx_fnumber_t_print = _ida_hexrays.hx_fnumber_t_print
hx_fnumber_t_dstr = _ida_hexrays.hx_fnumber_t_dstr
hx_mop_t_copy = _ida_hexrays.hx_mop_t_copy
hx_mop_t_assign = _ida_hexrays.hx_mop_t_assign
hx_mop_t_swap = _ida_hexrays.hx_mop_t_swap
hx_mop_t_erase = _ida_hexrays.hx_mop_t_erase
hx_mop_t_print = _ida_hexrays.hx_mop_t_print
hx_mop_t_dstr = _ida_hexrays.hx_mop_t_dstr
hx_mop_t_create_from_mlist = _ida_hexrays.hx_mop_t_create_from_mlist
hx_mop_t_create_from_ivlset = _ida_hexrays.hx_mop_t_create_from_ivlset
hx_mop_t_create_from_vdloc = _ida_hexrays.hx_mop_t_create_from_vdloc
hx_mop_t_create_from_scattered_vdloc = _ida_hexrays.hx_mop_t_create_from_scattered_vdloc
hx_mop_t_create_from_insn = _ida_hexrays.hx_mop_t_create_from_insn
hx_mop_t_make_number = _ida_hexrays.hx_mop_t_make_number
hx_mop_t_make_fpnum = _ida_hexrays.hx_mop_t_make_fpnum
hx_mop_t_make_reg_pair = _ida_hexrays.hx_mop_t_make_reg_pair
hx_mop_t_make_helper = _ida_hexrays.hx_mop_t_make_helper
hx_mop_t_is_bit_reg = _ida_hexrays.hx_mop_t_is_bit_reg
hx_mop_t_may_use_aliased_memory = _ida_hexrays.hx_mop_t_may_use_aliased_memory
hx_mop_t_is01 = _ida_hexrays.hx_mop_t_is01
hx_mop_t_is_sign_extended_from = _ida_hexrays.hx_mop_t_is_sign_extended_from
hx_mop_t_is_zero_extended_from = _ida_hexrays.hx_mop_t_is_zero_extended_from
hx_mop_t_equal_mops = _ida_hexrays.hx_mop_t_equal_mops
hx_mop_t_lexcompare = _ida_hexrays.hx_mop_t_lexcompare
hx_mop_t_for_all_ops = _ida_hexrays.hx_mop_t_for_all_ops
hx_mop_t_for_all_scattered_submops = _ida_hexrays.hx_mop_t_for_all_scattered_submops
hx_mop_t_is_constant = _ida_hexrays.hx_mop_t_is_constant
hx_mop_t_get_stkoff = _ida_hexrays.hx_mop_t_get_stkoff
hx_mop_t_make_low_half = _ida_hexrays.hx_mop_t_make_low_half
hx_mop_t_make_high_half = _ida_hexrays.hx_mop_t_make_high_half
hx_mop_t_make_first_half = _ida_hexrays.hx_mop_t_make_first_half
hx_mop_t_make_second_half = _ida_hexrays.hx_mop_t_make_second_half
hx_mop_t_shift_mop = _ida_hexrays.hx_mop_t_shift_mop
hx_mop_t_change_size = _ida_hexrays.hx_mop_t_change_size
hx_mop_t_preserve_side_effects = _ida_hexrays.hx_mop_t_preserve_side_effects
hx_mop_t_apply_ld_mcode = _ida_hexrays.hx_mop_t_apply_ld_mcode
hx_mcallarg_t_print = _ida_hexrays.hx_mcallarg_t_print
hx_mcallarg_t_dstr = _ida_hexrays.hx_mcallarg_t_dstr
hx_mcallarg_t_set_regarg = _ida_hexrays.hx_mcallarg_t_set_regarg
hx_mcallinfo_t_lexcompare = _ida_hexrays.hx_mcallinfo_t_lexcompare
hx_mcallinfo_t_set_type = _ida_hexrays.hx_mcallinfo_t_set_type
hx_mcallinfo_t_get_type = _ida_hexrays.hx_mcallinfo_t_get_type
hx_mcallinfo_t_print = _ida_hexrays.hx_mcallinfo_t_print
hx_mcallinfo_t_dstr = _ida_hexrays.hx_mcallinfo_t_dstr
hx_mcases_t_compare = _ida_hexrays.hx_mcases_t_compare
hx_mcases_t_print = _ida_hexrays.hx_mcases_t_print
hx_mcases_t_dstr = _ida_hexrays.hx_mcases_t_dstr
hx_vivl_t_extend_to_cover = _ida_hexrays.hx_vivl_t_extend_to_cover
hx_vivl_t_intersect = _ida_hexrays.hx_vivl_t_intersect
hx_vivl_t_print = _ida_hexrays.hx_vivl_t_print
hx_vivl_t_dstr = _ida_hexrays.hx_vivl_t_dstr
hx_chain_t_print = _ida_hexrays.hx_chain_t_print
hx_chain_t_dstr = _ida_hexrays.hx_chain_t_dstr
hx_chain_t_append_list = _ida_hexrays.hx_chain_t_append_list
hx_block_chains_t_get_chain = _ida_hexrays.hx_block_chains_t_get_chain
hx_block_chains_t_print = _ida_hexrays.hx_block_chains_t_print
hx_block_chains_t_dstr = _ida_hexrays.hx_block_chains_t_dstr
hx_graph_chains_t_for_all_chains = _ida_hexrays.hx_graph_chains_t_for_all_chains
hx_graph_chains_t_release = _ida_hexrays.hx_graph_chains_t_release
hx_minsn_t_init = _ida_hexrays.hx_minsn_t_init
hx_minsn_t_copy = _ida_hexrays.hx_minsn_t_copy
hx_minsn_t_swap = _ida_hexrays.hx_minsn_t_swap
hx_minsn_t_print = _ida_hexrays.hx_minsn_t_print
hx_minsn_t_dstr = _ida_hexrays.hx_minsn_t_dstr
hx_minsn_t_setaddr = _ida_hexrays.hx_minsn_t_setaddr
hx_minsn_t_optimize_subtree = _ida_hexrays.hx_minsn_t_optimize_subtree
hx_minsn_t_for_all_ops = _ida_hexrays.hx_minsn_t_for_all_ops
hx_minsn_t_for_all_insns = _ida_hexrays.hx_minsn_t_for_all_insns
hx_minsn_t__make_nop = _ida_hexrays.hx_minsn_t__make_nop
hx_minsn_t_equal_insns = _ida_hexrays.hx_minsn_t_equal_insns
hx_minsn_t_lexcompare = _ida_hexrays.hx_minsn_t_lexcompare
hx_minsn_t_is_noret_call = _ida_hexrays.hx_minsn_t_is_noret_call
hx_minsn_t_is_helper = _ida_hexrays.hx_minsn_t_is_helper
hx_minsn_t_find_call = _ida_hexrays.hx_minsn_t_find_call
hx_minsn_t_has_side_effects = _ida_hexrays.hx_minsn_t_has_side_effects
hx_minsn_t_find_opcode = _ida_hexrays.hx_minsn_t_find_opcode
hx_minsn_t_find_ins_op = _ida_hexrays.hx_minsn_t_find_ins_op
hx_minsn_t_find_num_op = _ida_hexrays.hx_minsn_t_find_num_op
hx_minsn_t_modifes_d = _ida_hexrays.hx_minsn_t_modifes_d
hx_minsn_t_is_between = _ida_hexrays.hx_minsn_t_is_between
hx_minsn_t_may_use_aliased_memory = _ida_hexrays.hx_minsn_t_may_use_aliased_memory
hx_getf_reginsn = _ida_hexrays.hx_getf_reginsn
hx_getb_reginsn = _ida_hexrays.hx_getb_reginsn
hx_mblock_t_init = _ida_hexrays.hx_mblock_t_init
hx_mblock_t_print = _ida_hexrays.hx_mblock_t_print
hx_mblock_t_dump = _ida_hexrays.hx_mblock_t_dump
hx_mblock_t_vdump_block = _ida_hexrays.hx_mblock_t_vdump_block
hx_mblock_t_insert_into_block = _ida_hexrays.hx_mblock_t_insert_into_block
hx_mblock_t_remove_from_block = _ida_hexrays.hx_mblock_t_remove_from_block
hx_mblock_t_for_all_insns = _ida_hexrays.hx_mblock_t_for_all_insns
hx_mblock_t_for_all_ops = _ida_hexrays.hx_mblock_t_for_all_ops
hx_mblock_t_for_all_uses = _ida_hexrays.hx_mblock_t_for_all_uses
hx_mblock_t_optimize_insn = _ida_hexrays.hx_mblock_t_optimize_insn
hx_mblock_t_optimize_block = _ida_hexrays.hx_mblock_t_optimize_block
hx_mblock_t_build_lists = _ida_hexrays.hx_mblock_t_build_lists
hx_mblock_t_append_use_list = _ida_hexrays.hx_mblock_t_append_use_list
hx_mblock_t_append_def_list = _ida_hexrays.hx_mblock_t_append_def_list
hx_mblock_t_build_use_list = _ida_hexrays.hx_mblock_t_build_use_list
hx_mblock_t_build_def_list = _ida_hexrays.hx_mblock_t_build_def_list
hx_mblock_t_find_first_use = _ida_hexrays.hx_mblock_t_find_first_use
hx_mblock_t_find_redefinition = _ida_hexrays.hx_mblock_t_find_redefinition
hx_mblock_t_is_rhs_redefined = _ida_hexrays.hx_mblock_t_is_rhs_redefined
hx_mblock_t_find_access = _ida_hexrays.hx_mblock_t_find_access
hx_mblock_t_get_valranges = _ida_hexrays.hx_mblock_t_get_valranges
hx_mbl_array_t_idaloc2vd = _ida_hexrays.hx_mbl_array_t_idaloc2vd
hx_mbl_array_t_vd2idaloc = _ida_hexrays.hx_mbl_array_t_vd2idaloc
hx_mbl_array_t_term = _ida_hexrays.hx_mbl_array_t_term
hx_mbl_array_t_optimize_local = _ida_hexrays.hx_mbl_array_t_optimize_local
hx_mbl_array_t_build_graph = _ida_hexrays.hx_mbl_array_t_build_graph
hx_mbl_array_t_get_graph = _ida_hexrays.hx_mbl_array_t_get_graph
hx_mbl_array_t_analyze_calls = _ida_hexrays.hx_mbl_array_t_analyze_calls
hx_mbl_array_t_optimize_global = _ida_hexrays.hx_mbl_array_t_optimize_global
hx_mbl_array_t_alloc_lvars = _ida_hexrays.hx_mbl_array_t_alloc_lvars
hx_mbl_array_t_dump = _ida_hexrays.hx_mbl_array_t_dump
hx_mbl_array_t_vdump_mba = _ida_hexrays.hx_mbl_array_t_vdump_mba
hx_mbl_array_t_print = _ida_hexrays.hx_mbl_array_t_print
hx_mbl_array_t_verify = _ida_hexrays.hx_mbl_array_t_verify
hx_mbl_array_t_mark_chains_dirty = _ida_hexrays.hx_mbl_array_t_mark_chains_dirty
hx_mbl_array_t_insert_block = _ida_hexrays.hx_mbl_array_t_insert_block
hx_mbl_array_t_remove_block = _ida_hexrays.hx_mbl_array_t_remove_block
hx_mbl_array_t_remove_empty_blocks = _ida_hexrays.hx_mbl_array_t_remove_empty_blocks
hx_mbl_array_t_combine_blocks = _ida_hexrays.hx_mbl_array_t_combine_blocks
hx_mbl_array_t_for_all_ops = _ida_hexrays.hx_mbl_array_t_for_all_ops
hx_mbl_array_t_for_all_insns = _ida_hexrays.hx_mbl_array_t_for_all_insns
hx_mbl_array_t_for_all_topinsns = _ida_hexrays.hx_mbl_array_t_for_all_topinsns
hx_mbl_array_t_find_mop = _ida_hexrays.hx_mbl_array_t_find_mop
hx_mbl_array_t_arg = _ida_hexrays.hx_mbl_array_t_arg
hx_mbl_array_t_serialize = _ida_hexrays.hx_mbl_array_t_serialize
hx_mbl_array_t_deserialize = _ida_hexrays.hx_mbl_array_t_deserialize
hx_mbl_graph_t_is_accessed_globally = _ida_hexrays.hx_mbl_graph_t_is_accessed_globally
hx_mbl_graph_t_get_ud = _ida_hexrays.hx_mbl_graph_t_get_ud
hx_mbl_graph_t_get_du = _ida_hexrays.hx_mbl_graph_t_get_du
hx_codegen_t_emit = _ida_hexrays.hx_codegen_t_emit
hx_codegen_t_emit_ = _ida_hexrays.hx_codegen_t_emit_
hx_is_kreg = _ida_hexrays.hx_is_kreg
hx_get_temp_regs = _ida_hexrays.hx_get_temp_regs
hx_get_hexrays_version = _ida_hexrays.hx_get_hexrays_version
hx_open_pseudocode = _ida_hexrays.hx_open_pseudocode
hx_close_pseudocode = _ida_hexrays.hx_close_pseudocode
hx_get_widget_vdui = _ida_hexrays.hx_get_widget_vdui
hx_decompile_many = _ida_hexrays.hx_decompile_many
hx_hexrays_failure_t_desc = _ida_hexrays.hx_hexrays_failure_t_desc
hx_send_database = _ida_hexrays.hx_send_database
hx_gco_info_t_append_to_list = _ida_hexrays.hx_gco_info_t_append_to_list
hx_get_current_operand = _ida_hexrays.hx_get_current_operand
hx_remitem = _ida_hexrays.hx_remitem
hx_negated_relation = _ida_hexrays.hx_negated_relation
hx_swapped_relation = _ida_hexrays.hx_swapped_relation
hx_get_op_signness = _ida_hexrays.hx_get_op_signness
hx_asgop = _ida_hexrays.hx_asgop
hx_asgop_revert = _ida_hexrays.hx_asgop_revert
hx_cnumber_t_print = _ida_hexrays.hx_cnumber_t_print
hx_cnumber_t_value = _ida_hexrays.hx_cnumber_t_value
hx_cnumber_t_assign = _ida_hexrays.hx_cnumber_t_assign
hx_cnumber_t_compare = _ida_hexrays.hx_cnumber_t_compare
hx_var_ref_t_compare = _ida_hexrays.hx_var_ref_t_compare
hx_ctree_visitor_t_apply_to = _ida_hexrays.hx_ctree_visitor_t_apply_to
hx_ctree_visitor_t_apply_to_exprs = _ida_hexrays.hx_ctree_visitor_t_apply_to_exprs
hx_ctree_parentee_t_recalc_parent_types = _ida_hexrays.hx_ctree_parentee_t_recalc_parent_types
hx_cfunc_parentee_t_calc_rvalue_type = _ida_hexrays.hx_cfunc_parentee_t_calc_rvalue_type
hx_citem_locator_t_compare = _ida_hexrays.hx_citem_locator_t_compare
hx_citem_t_contains_expr = _ida_hexrays.hx_citem_t_contains_expr
hx_citem_t_contains_label = _ida_hexrays.hx_citem_t_contains_label
hx_citem_t_find_parent_of = _ida_hexrays.hx_citem_t_find_parent_of
hx_citem_t_find_closest_addr = _ida_hexrays.hx_citem_t_find_closest_addr
hx_cexpr_t_assign = _ida_hexrays.hx_cexpr_t_assign
hx_cexpr_t_compare = _ida_hexrays.hx_cexpr_t_compare
hx_cexpr_t_replace_by = _ida_hexrays.hx_cexpr_t_replace_by
hx_cexpr_t_cleanup = _ida_hexrays.hx_cexpr_t_cleanup
hx_cexpr_t_put_number = _ida_hexrays.hx_cexpr_t_put_number
hx_cexpr_t_print1 = _ida_hexrays.hx_cexpr_t_print1
hx_cexpr_t_calc_type = _ida_hexrays.hx_cexpr_t_calc_type
hx_cexpr_t_equal_effect = _ida_hexrays.hx_cexpr_t_equal_effect
hx_cexpr_t_is_child_of = _ida_hexrays.hx_cexpr_t_is_child_of
hx_cexpr_t_contains_operator = _ida_hexrays.hx_cexpr_t_contains_operator
hx_cexpr_t_get_high_nbit_bound = _ida_hexrays.hx_cexpr_t_get_high_nbit_bound
hx_cexpr_t_get_low_nbit_bound = _ida_hexrays.hx_cexpr_t_get_low_nbit_bound
hx_cexpr_t_requires_lvalue = _ida_hexrays.hx_cexpr_t_requires_lvalue
hx_cexpr_t_has_side_effects = _ida_hexrays.hx_cexpr_t_has_side_effects
hx_cif_t_assign = _ida_hexrays.hx_cif_t_assign
hx_cif_t_compare = _ida_hexrays.hx_cif_t_compare
hx_cloop_t_assign = _ida_hexrays.hx_cloop_t_assign
hx_cfor_t_compare = _ida_hexrays.hx_cfor_t_compare
hx_cwhile_t_compare = _ida_hexrays.hx_cwhile_t_compare
hx_cdo_t_compare = _ida_hexrays.hx_cdo_t_compare
hx_creturn_t_compare = _ida_hexrays.hx_creturn_t_compare
hx_cgoto_t_compare = _ida_hexrays.hx_cgoto_t_compare
hx_casm_t_compare = _ida_hexrays.hx_casm_t_compare
hx_cinsn_t_assign = _ida_hexrays.hx_cinsn_t_assign
hx_cinsn_t_compare = _ida_hexrays.hx_cinsn_t_compare
hx_cinsn_t_replace_by = _ida_hexrays.hx_cinsn_t_replace_by
hx_cinsn_t_cleanup = _ida_hexrays.hx_cinsn_t_cleanup
hx_cinsn_t_new_insn = _ida_hexrays.hx_cinsn_t_new_insn
hx_cinsn_t_create_if = _ida_hexrays.hx_cinsn_t_create_if
hx_cinsn_t_print = _ida_hexrays.hx_cinsn_t_print
hx_cinsn_t_print1 = _ida_hexrays.hx_cinsn_t_print1
hx_cinsn_t_is_ordinary_flow = _ida_hexrays.hx_cinsn_t_is_ordinary_flow
hx_cinsn_t_contains_insn = _ida_hexrays.hx_cinsn_t_contains_insn
hx_cinsn_t_collect_free_breaks = _ida_hexrays.hx_cinsn_t_collect_free_breaks
hx_cinsn_t_collect_free_continues = _ida_hexrays.hx_cinsn_t_collect_free_continues
hx_cblock_t_compare = _ida_hexrays.hx_cblock_t_compare
hx_carglist_t_compare = _ida_hexrays.hx_carglist_t_compare
hx_ccase_t_compare = _ida_hexrays.hx_ccase_t_compare
hx_ccases_t_compare = _ida_hexrays.hx_ccases_t_compare
hx_cswitch_t_compare = _ida_hexrays.hx_cswitch_t_compare
hx_ctree_item_t_get_memptr = _ida_hexrays.hx_ctree_item_t_get_memptr
hx_ctree_item_t_get_lvar = _ida_hexrays.hx_ctree_item_t_get_lvar
hx_ctree_item_t_get_ea = _ida_hexrays.hx_ctree_item_t_get_ea
hx_ctree_item_t_get_label_num = _ida_hexrays.hx_ctree_item_t_get_label_num
hx_lnot = _ida_hexrays.hx_lnot
hx_new_block = _ida_hexrays.hx_new_block
hx_vcreate_helper = _ida_hexrays.hx_vcreate_helper
hx_vcall_helper = _ida_hexrays.hx_vcall_helper
hx_make_num = _ida_hexrays.hx_make_num
hx_make_ref = _ida_hexrays.hx_make_ref
hx_dereference = _ida_hexrays.hx_dereference
hx_save_user_labels = _ida_hexrays.hx_save_user_labels
hx_save_user_cmts = _ida_hexrays.hx_save_user_cmts
hx_save_user_numforms = _ida_hexrays.hx_save_user_numforms
hx_save_user_iflags = _ida_hexrays.hx_save_user_iflags
hx_save_user_unions = _ida_hexrays.hx_save_user_unions
hx_restore_user_labels = _ida_hexrays.hx_restore_user_labels
hx_restore_user_cmts = _ida_hexrays.hx_restore_user_cmts
hx_restore_user_numforms = _ida_hexrays.hx_restore_user_numforms
hx_restore_user_iflags = _ida_hexrays.hx_restore_user_iflags
hx_restore_user_unions = _ida_hexrays.hx_restore_user_unions
hx_cfunc_t_build_c_tree = _ida_hexrays.hx_cfunc_t_build_c_tree
hx_cfunc_t_verify = _ida_hexrays.hx_cfunc_t_verify
hx_cfunc_t_print_dcl = _ida_hexrays.hx_cfunc_t_print_dcl
hx_cfunc_t_print_func = _ida_hexrays.hx_cfunc_t_print_func
hx_cfunc_t_get_func_type = _ida_hexrays.hx_cfunc_t_get_func_type
hx_cfunc_t_get_lvars = _ida_hexrays.hx_cfunc_t_get_lvars
hx_cfunc_t_get_stkoff_delta = _ida_hexrays.hx_cfunc_t_get_stkoff_delta
hx_cfunc_t_find_label = _ida_hexrays.hx_cfunc_t_find_label
hx_cfunc_t_remove_unused_labels = _ida_hexrays.hx_cfunc_t_remove_unused_labels
hx_cfunc_t_get_user_cmt = _ida_hexrays.hx_cfunc_t_get_user_cmt
hx_cfunc_t_set_user_cmt = _ida_hexrays.hx_cfunc_t_set_user_cmt
hx_cfunc_t_get_user_iflags = _ida_hexrays.hx_cfunc_t_get_user_iflags
hx_cfunc_t_set_user_iflags = _ida_hexrays.hx_cfunc_t_set_user_iflags
hx_cfunc_t_has_orphan_cmts = _ida_hexrays.hx_cfunc_t_has_orphan_cmts
hx_cfunc_t_del_orphan_cmts = _ida_hexrays.hx_cfunc_t_del_orphan_cmts
hx_cfunc_t_get_user_union_selection = _ida_hexrays.hx_cfunc_t_get_user_union_selection
hx_cfunc_t_set_user_union_selection = _ida_hexrays.hx_cfunc_t_set_user_union_selection
hx_cfunc_t_get_line_item = _ida_hexrays.hx_cfunc_t_get_line_item
hx_cfunc_t_get_warnings = _ida_hexrays.hx_cfunc_t_get_warnings
hx_cfunc_t_get_eamap = _ida_hexrays.hx_cfunc_t_get_eamap
hx_cfunc_t_get_boundaries = _ida_hexrays.hx_cfunc_t_get_boundaries
hx_cfunc_t_get_pseudocode = _ida_hexrays.hx_cfunc_t_get_pseudocode
hx_cfunc_t_gather_derefs = _ida_hexrays.hx_cfunc_t_gather_derefs
hx_cfunc_t_find_item_coords = _ida_hexrays.hx_cfunc_t_find_item_coords
hx_cfunc_t_cleanup = _ida_hexrays.hx_cfunc_t_cleanup
hx_decompile = _ida_hexrays.hx_decompile
hx_gen_microcode = _ida_hexrays.hx_gen_microcode
hx_mark_cfunc_dirty = _ida_hexrays.hx_mark_cfunc_dirty
hx_clear_cached_cfuncs = _ida_hexrays.hx_clear_cached_cfuncs
hx_has_cached_cfunc = _ida_hexrays.hx_has_cached_cfunc
hx_get_ctype_name = _ida_hexrays.hx_get_ctype_name
hx_create_field_name = _ida_hexrays.hx_create_field_name
hx_install_hexrays_callback = _ida_hexrays.hx_install_hexrays_callback
hx_remove_hexrays_callback = _ida_hexrays.hx_remove_hexrays_callback
hx_vdui_t_set_locked = _ida_hexrays.hx_vdui_t_set_locked
hx_vdui_t_refresh_view = _ida_hexrays.hx_vdui_t_refresh_view
hx_vdui_t_refresh_ctext = _ida_hexrays.hx_vdui_t_refresh_ctext
hx_vdui_t_switch_to = _ida_hexrays.hx_vdui_t_switch_to
hx_vdui_t_get_number = _ida_hexrays.hx_vdui_t_get_number
hx_vdui_t_get_current_label = _ida_hexrays.hx_vdui_t_get_current_label
hx_vdui_t_clear = _ida_hexrays.hx_vdui_t_clear
hx_vdui_t_refresh_cpos = _ida_hexrays.hx_vdui_t_refresh_cpos
hx_vdui_t_get_current_item = _ida_hexrays.hx_vdui_t_get_current_item
hx_vdui_t_ui_rename_lvar = _ida_hexrays.hx_vdui_t_ui_rename_lvar
hx_vdui_t_rename_lvar = _ida_hexrays.hx_vdui_t_rename_lvar
hx_vdui_t_ui_set_call_type = _ida_hexrays.hx_vdui_t_ui_set_call_type
hx_vdui_t_ui_set_lvar_type = _ida_hexrays.hx_vdui_t_ui_set_lvar_type
hx_vdui_t_set_lvar_type = _ida_hexrays.hx_vdui_t_set_lvar_type
hx_vdui_t_ui_edit_lvar_cmt = _ida_hexrays.hx_vdui_t_ui_edit_lvar_cmt
hx_vdui_t_set_lvar_cmt = _ida_hexrays.hx_vdui_t_set_lvar_cmt
hx_vdui_t_ui_map_lvar = _ida_hexrays.hx_vdui_t_ui_map_lvar
hx_vdui_t_ui_unmap_lvar = _ida_hexrays.hx_vdui_t_ui_unmap_lvar
hx_vdui_t_map_lvar = _ida_hexrays.hx_vdui_t_map_lvar
hx_vdui_t_set_strmem_type = _ida_hexrays.hx_vdui_t_set_strmem_type
hx_vdui_t_rename_strmem = _ida_hexrays.hx_vdui_t_rename_strmem
hx_vdui_t_set_global_type = _ida_hexrays.hx_vdui_t_set_global_type
hx_vdui_t_rename_global = _ida_hexrays.hx_vdui_t_rename_global
hx_vdui_t_rename_label = _ida_hexrays.hx_vdui_t_rename_label
hx_vdui_t_jump_enter = _ida_hexrays.hx_vdui_t_jump_enter
hx_vdui_t_ctree_to_disasm = _ida_hexrays.hx_vdui_t_ctree_to_disasm
hx_vdui_t_calc_cmt_type = _ida_hexrays.hx_vdui_t_calc_cmt_type
hx_vdui_t_edit_cmt = _ida_hexrays.hx_vdui_t_edit_cmt
hx_vdui_t_edit_func_cmt = _ida_hexrays.hx_vdui_t_edit_func_cmt
hx_vdui_t_del_orphan_cmts = _ida_hexrays.hx_vdui_t_del_orphan_cmts
hx_vdui_t_set_num_radix = _ida_hexrays.hx_vdui_t_set_num_radix
hx_vdui_t_set_num_enum = _ida_hexrays.hx_vdui_t_set_num_enum
hx_vdui_t_set_num_stroff = _ida_hexrays.hx_vdui_t_set_num_stroff
hx_vdui_t_invert_sign = _ida_hexrays.hx_vdui_t_invert_sign
hx_vdui_t_invert_bits = _ida_hexrays.hx_vdui_t_invert_bits
hx_vdui_t_collapse_item = _ida_hexrays.hx_vdui_t_collapse_item
hx_vdui_t_collapse_lvars = _ida_hexrays.hx_vdui_t_collapse_lvars
hx_vdui_t_split_item = _ida_hexrays.hx_vdui_t_split_item
hx_hexrays_alloc = _ida_hexrays.hx_hexrays_alloc
hx_hexrays_free = _ida_hexrays.hx_hexrays_free
hx_vdui_t_set_noptr_lvar = _ida_hexrays.hx_vdui_t_set_noptr_lvar
hx_select_udt_by_offset = _ida_hexrays.hx_select_udt_by_offset
hx_mblock_t_get_valranges_ = _ida_hexrays.hx_mblock_t_get_valranges_
hx_cfunc_t_refresh_func_ctext = _ida_hexrays.hx_cfunc_t_refresh_func_ctext
hx_checkout_hexrays_license = _ida_hexrays.hx_checkout_hexrays_license
hx_mbl_array_t_copy_block = _ida_hexrays.hx_mbl_array_t_copy_block
hx_mblock_t_optimize_useless_jump = _ida_hexrays.hx_mblock_t_optimize_useless_jump
hx_mblock_t_get_reginsn_qty = _ida_hexrays.hx_mblock_t_get_reginsn_qty
class user_numforms_iterator_t(object):
    """
    Proxy of C++ user_numforms_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_numforms_iterator_t_x_get, _ida_hexrays.user_numforms_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_numforms_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_numforms_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_numforms_iterator_t
        """
        this = _ida_hexrays.new_user_numforms_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_numforms_iterator_t
    __del__ = lambda self : None;
user_numforms_iterator_t_swigregister = _ida_hexrays.user_numforms_iterator_t_swigregister
user_numforms_iterator_t_swigregister(user_numforms_iterator_t)


def user_numforms_begin(*args):
  """
  user_numforms_begin(map) -> user_numforms_iterator_t


  Get iterator pointing to the beginning of user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_begin(*args)

def user_numforms_end(*args):
  """
  user_numforms_end(map) -> user_numforms_iterator_t


  Get iterator pointing to the end of user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_end(*args)

def user_numforms_next(*args):
  """
  user_numforms_next(p) -> user_numforms_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_next(*args)

def user_numforms_prev(*args):
  """
  user_numforms_prev(p) -> user_numforms_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_prev(*args)

def user_numforms_first(*args):
  """
  user_numforms_first(p) -> operand_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_first(*args)

def user_numforms_second(*args):
  """
  user_numforms_second(p) -> number_format_t


  Get reference to the current map value.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_second(*args)

def user_numforms_find(*args):
  """
  user_numforms_find(map, key) -> user_numforms_iterator_t


  Find the specified key in user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  @param key (C++: const  operand_locator_t  &)
  """
  return _ida_hexrays.user_numforms_find(*args)

def user_numforms_insert(*args):
  """
  user_numforms_insert(map, key, val) -> user_numforms_iterator_t


  Insert new ( 'operand_locator_t' , 'number_format_t' ) pair into
  user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  @param key (C++: const  operand_locator_t  &)
  @param val (C++: const  number_format_t  &)
  """
  return _ida_hexrays.user_numforms_insert(*args)

def user_numforms_erase(*args):
  """
  user_numforms_erase(map, p)


  Erase current element from user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_erase(*args)

def user_numforms_clear(*args):
  """
  user_numforms_clear(map)


  Clear user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_clear(*args)

def user_numforms_size(*args):
  """
  user_numforms_size(map) -> size_t


  Get size of user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_size(*args)

def user_numforms_free(*args):
  """
  user_numforms_free(map)


  Delete user_numforms_t instance.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_free(*args)

def user_numforms_new(*args):
  """
  user_numforms_new() -> user_numforms_t


  Create a new user_numforms_t instance.
  """
  return _ida_hexrays.user_numforms_new(*args)
class lvar_mapping_iterator_t(object):
    """
    Proxy of C++ lvar_mapping_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.lvar_mapping_iterator_t_x_get, _ida_hexrays.lvar_mapping_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.lvar_mapping_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.lvar_mapping_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvar_mapping_iterator_t
        """
        this = _ida_hexrays.new_lvar_mapping_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_mapping_iterator_t
    __del__ = lambda self : None;
lvar_mapping_iterator_t_swigregister = _ida_hexrays.lvar_mapping_iterator_t_swigregister
lvar_mapping_iterator_t_swigregister(lvar_mapping_iterator_t)


def lvar_mapping_begin(*args):
  """
  lvar_mapping_begin(map) -> lvar_mapping_iterator_t


  Get iterator pointing to the beginning of lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_begin(*args)

def lvar_mapping_end(*args):
  """
  lvar_mapping_end(map) -> lvar_mapping_iterator_t


  Get iterator pointing to the end of lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_end(*args)

def lvar_mapping_next(*args):
  """
  lvar_mapping_next(p) -> lvar_mapping_iterator_t


  Move to the next element.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_next(*args)

def lvar_mapping_prev(*args):
  """
  lvar_mapping_prev(p) -> lvar_mapping_iterator_t


  Move to the previous element.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_prev(*args)

def lvar_mapping_first(*args):
  """
  lvar_mapping_first(p) -> lvar_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_first(*args)

def lvar_mapping_second(*args):
  """
  lvar_mapping_second(p) -> lvar_locator_t


  Get reference to the current map value.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_second(*args)

def lvar_mapping_find(*args):
  """
  lvar_mapping_find(map, key) -> lvar_mapping_iterator_t


  Find the specified key in lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  @param key (C++: const  lvar_locator_t  &)
  """
  return _ida_hexrays.lvar_mapping_find(*args)

def lvar_mapping_insert(*args):
  """
  lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t


  Insert new ( 'lvar_locator_t' , 'lvar_locator_t' ) pair into
  lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  @param key (C++: const  lvar_locator_t  &)
  @param val (C++: const  lvar_locator_t  &)
  """
  return _ida_hexrays.lvar_mapping_insert(*args)

def lvar_mapping_erase(*args):
  """
  lvar_mapping_erase(map, p)


  Erase current element from lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_erase(*args)

def lvar_mapping_clear(*args):
  """
  lvar_mapping_clear(map)


  Clear lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_clear(*args)

def lvar_mapping_size(*args):
  """
  lvar_mapping_size(map) -> size_t


  Get size of lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_size(*args)

def lvar_mapping_free(*args):
  """
  lvar_mapping_free(map)


  Delete lvar_mapping_t instance.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_free(*args)

def lvar_mapping_new(*args):
  """
  lvar_mapping_new() -> lvar_mapping_t


  Create a new lvar_mapping_t instance.
  """
  return _ida_hexrays.lvar_mapping_new(*args)
class udcall_map_iterator_t(object):
    """
    Proxy of C++ udcall_map_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.udcall_map_iterator_t_x_get, _ida_hexrays.udcall_map_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.udcall_map_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.udcall_map_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> udcall_map_iterator_t
        """
        this = _ida_hexrays.new_udcall_map_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udcall_map_iterator_t
    __del__ = lambda self : None;
udcall_map_iterator_t_swigregister = _ida_hexrays.udcall_map_iterator_t_swigregister
udcall_map_iterator_t_swigregister(udcall_map_iterator_t)


def udcall_map_begin(*args):
  """
  udcall_map_begin(map) -> udcall_map_iterator_t


  Get iterator pointing to the beginning of udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_begin(*args)

def udcall_map_end(*args):
  """
  udcall_map_end(map) -> udcall_map_iterator_t


  Get iterator pointing to the end of udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_end(*args)

def udcall_map_next(*args):
  """
  udcall_map_next(p) -> udcall_map_iterator_t


  Move to the next element.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_next(*args)

def udcall_map_prev(*args):
  """
  udcall_map_prev(p) -> udcall_map_iterator_t


  Move to the previous element.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_prev(*args)

def udcall_map_first(*args):
  """
  udcall_map_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_first(*args)

def udcall_map_second(*args):
  """
  udcall_map_second(p) -> udcall_t


  Get reference to the current map value.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_second(*args)

def udcall_map_find(*args):
  """
  udcall_map_find(map, key) -> udcall_map_iterator_t


  Find the specified key in udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.udcall_map_find(*args)

def udcall_map_insert(*args):
  """
  udcall_map_insert(map, key, val) -> udcall_map_iterator_t


  Insert new (ea_t, 'udcall_t' ) pair into udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  udcall_t  &)
  """
  return _ida_hexrays.udcall_map_insert(*args)

def udcall_map_erase(*args):
  """
  udcall_map_erase(map, p)


  Erase current element from udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_erase(*args)

def udcall_map_clear(*args):
  """
  udcall_map_clear(map)


  Clear udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_clear(*args)

def udcall_map_size(*args):
  """
  udcall_map_size(map) -> size_t


  Get size of udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_size(*args)

def udcall_map_free(*args):
  """
  udcall_map_free(map)


  Delete udcall_map_t instance.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_free(*args)

def udcall_map_new(*args):
  """
  udcall_map_new() -> udcall_map_t *


  Create a new udcall_map_t instance.
  """
  return _ida_hexrays.udcall_map_new(*args)
class user_cmts_iterator_t(object):
    """
    Proxy of C++ user_cmts_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_cmts_iterator_t_x_get, _ida_hexrays.user_cmts_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_cmts_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_cmts_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_cmts_iterator_t
        """
        this = _ida_hexrays.new_user_cmts_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_cmts_iterator_t
    __del__ = lambda self : None;
user_cmts_iterator_t_swigregister = _ida_hexrays.user_cmts_iterator_t_swigregister
user_cmts_iterator_t_swigregister(user_cmts_iterator_t)


def user_cmts_begin(*args):
  """
  user_cmts_begin(map) -> user_cmts_iterator_t


  Get iterator pointing to the beginning of user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_begin(*args)

def user_cmts_end(*args):
  """
  user_cmts_end(map) -> user_cmts_iterator_t


  Get iterator pointing to the end of user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_end(*args)

def user_cmts_next(*args):
  """
  user_cmts_next(p) -> user_cmts_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_next(*args)

def user_cmts_prev(*args):
  """
  user_cmts_prev(p) -> user_cmts_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_prev(*args)

def user_cmts_first(*args):
  """
  user_cmts_first(p) -> treeloc_t


  Get reference to the current map key.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_first(*args)

def user_cmts_second(*args):
  """
  user_cmts_second(p) -> citem_cmt_t


  Get reference to the current map value.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_second(*args)

def user_cmts_find(*args):
  """
  user_cmts_find(map, key) -> user_cmts_iterator_t


  Find the specified key in user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  @param key (C++: const  treeloc_t  &)
  """
  return _ida_hexrays.user_cmts_find(*args)

def user_cmts_insert(*args):
  """
  user_cmts_insert(map, key, val) -> user_cmts_iterator_t


  Insert new ( 'treeloc_t' , 'citem_cmt_t' ) pair into user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  @param key (C++: const  treeloc_t  &)
  @param val (C++: const  citem_cmt_t  &)
  """
  return _ida_hexrays.user_cmts_insert(*args)

def user_cmts_erase(*args):
  """
  user_cmts_erase(map, p)


  Erase current element from user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_erase(*args)

def user_cmts_clear(*args):
  """
  user_cmts_clear(map)


  Clear user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_clear(*args)

def user_cmts_size(*args):
  """
  user_cmts_size(map) -> size_t


  Get size of user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_size(*args)

def user_cmts_free(*args):
  """
  user_cmts_free(map)


  Delete user_cmts_t instance.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_free(*args)

def user_cmts_new(*args):
  """
  user_cmts_new() -> user_cmts_t


  Create a new user_cmts_t instance.
  """
  return _ida_hexrays.user_cmts_new(*args)
class user_iflags_iterator_t(object):
    """
    Proxy of C++ user_iflags_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_iflags_iterator_t_x_get, _ida_hexrays.user_iflags_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_iflags_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_iflags_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_iflags_iterator_t
        """
        this = _ida_hexrays.new_user_iflags_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_iflags_iterator_t
    __del__ = lambda self : None;
user_iflags_iterator_t_swigregister = _ida_hexrays.user_iflags_iterator_t_swigregister
user_iflags_iterator_t_swigregister(user_iflags_iterator_t)


def user_iflags_begin(*args):
  """
  user_iflags_begin(map) -> user_iflags_iterator_t


  Get iterator pointing to the beginning of user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_begin(*args)

def user_iflags_end(*args):
  """
  user_iflags_end(map) -> user_iflags_iterator_t


  Get iterator pointing to the end of user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_end(*args)

def user_iflags_next(*args):
  """
  user_iflags_next(p) -> user_iflags_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_next(*args)

def user_iflags_prev(*args):
  """
  user_iflags_prev(p) -> user_iflags_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_prev(*args)

def user_iflags_first(*args):
  """
  user_iflags_first(p) -> citem_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_first(*args)

def user_iflags_find(*args):
  """
  user_iflags_find(map, key) -> user_iflags_iterator_t


  Find the specified key in user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  @param key (C++: const  citem_locator_t  &)
  """
  return _ida_hexrays.user_iflags_find(*args)

def user_iflags_insert(*args):
  """
  user_iflags_insert(map, key, val) -> user_iflags_iterator_t


  Insert new ( 'citem_locator_t' , int32) pair into user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  @param key (C++: const  citem_locator_t  &)
  @param val (C++: const  int32  &)
  """
  return _ida_hexrays.user_iflags_insert(*args)

def user_iflags_erase(*args):
  """
  user_iflags_erase(map, p)


  Erase current element from user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_erase(*args)

def user_iflags_clear(*args):
  """
  user_iflags_clear(map)


  Clear user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_clear(*args)

def user_iflags_size(*args):
  """
  user_iflags_size(map) -> size_t


  Get size of user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_size(*args)

def user_iflags_free(*args):
  """
  user_iflags_free(map)


  Delete user_iflags_t instance.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_free(*args)

def user_iflags_new(*args):
  """
  user_iflags_new() -> user_iflags_t


  Create a new user_iflags_t instance.
  """
  return _ida_hexrays.user_iflags_new(*args)
class user_unions_iterator_t(object):
    """
    Proxy of C++ user_unions_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_unions_iterator_t_x_get, _ida_hexrays.user_unions_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_unions_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_unions_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_unions_iterator_t
        """
        this = _ida_hexrays.new_user_unions_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_unions_iterator_t
    __del__ = lambda self : None;
user_unions_iterator_t_swigregister = _ida_hexrays.user_unions_iterator_t_swigregister
user_unions_iterator_t_swigregister(user_unions_iterator_t)


def user_unions_begin(*args):
  """
  user_unions_begin(map) -> user_unions_iterator_t


  Get iterator pointing to the beginning of user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  """
  return _ida_hexrays.user_unions_begin(*args)

def user_unions_end(*args):
  """
  user_unions_end(map) -> user_unions_iterator_t


  Get iterator pointing to the end of user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  """
  return _ida_hexrays.user_unions_end(*args)

def user_unions_next(*args):
  """
  user_unions_next(p) -> user_unions_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_next(*args)

def user_unions_prev(*args):
  """
  user_unions_prev(p) -> user_unions_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_prev(*args)

def user_unions_first(*args):
  """
  user_unions_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_first(*args)

def user_unions_second(*args):
  """
  user_unions_second(p) -> intvec_t


  Get reference to the current map value.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_second(*args)

def user_unions_find(*args):
  """
  user_unions_find(map, key) -> user_unions_iterator_t


  Find the specified key in user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.user_unions_find(*args)

def user_unions_insert(*args):
  """
  user_unions_insert(map, key, val) -> user_unions_iterator_t


  Insert new (ea_t, intvec_t) pair into user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  intvec_t  &)
  """
  return _ida_hexrays.user_unions_insert(*args)

def user_unions_erase(*args):
  """
  user_unions_erase(map, p)


  Erase current element from user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_erase(*args)

def user_unions_clear(*args):
  """
  user_unions_clear(map)


  Clear user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_clear(*args)

def user_unions_size(*args):
  """
  user_unions_size(map) -> size_t


  Get size of user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_size(*args)

def user_unions_free(*args):
  """
  user_unions_free(map)


  Delete user_unions_t instance.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_free(*args)

def user_unions_new(*args):
  """
  user_unions_new() -> user_unions_t


  Create a new user_unions_t instance.
  """
  return _ida_hexrays.user_unions_new(*args)
class user_labels_iterator_t(object):
    """
    Proxy of C++ user_labels_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_labels_iterator_t_x_get, _ida_hexrays.user_labels_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_labels_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_labels_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_labels_iterator_t
        """
        this = _ida_hexrays.new_user_labels_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_labels_iterator_t
    __del__ = lambda self : None;
user_labels_iterator_t_swigregister = _ida_hexrays.user_labels_iterator_t_swigregister
user_labels_iterator_t_swigregister(user_labels_iterator_t)


def user_labels_begin(*args):
  """
  user_labels_begin(map) -> user_labels_iterator_t


  Get iterator pointing to the beginning of user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  """
  return _ida_hexrays.user_labels_begin(*args)

def user_labels_end(*args):
  """
  user_labels_end(map) -> user_labels_iterator_t


  Get iterator pointing to the end of user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  """
  return _ida_hexrays.user_labels_end(*args)

def user_labels_next(*args):
  """
  user_labels_next(p) -> user_labels_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_next(*args)

def user_labels_prev(*args):
  """
  user_labels_prev(p) -> user_labels_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_prev(*args)

def user_labels_first(*args):
  """
  user_labels_first(p) -> int const &


  Get reference to the current map key.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_first(*args)

def user_labels_second(*args):
  """
  user_labels_second(p) -> qstring &


  Get reference to the current map value.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_second(*args)

def user_labels_find(*args):
  """
  user_labels_find(map, key) -> user_labels_iterator_t


  Find the specified key in user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  @param key (C++: const int &)
  """
  return _ida_hexrays.user_labels_find(*args)

def user_labels_insert(*args):
  """
  user_labels_insert(map, key, val) -> user_labels_iterator_t


  Insert new (int, qstring) pair into user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  @param key (C++: const int &)
  @param val (C++: const  qstring  &)
  """
  return _ida_hexrays.user_labels_insert(*args)

def user_labels_erase(*args):
  """
  user_labels_erase(map, p)


  Erase current element from user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_erase(*args)

def user_labels_clear(*args):
  """
  user_labels_clear(map)


  Clear user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_clear(*args)

def user_labels_size(*args):
  """
  user_labels_size(map) -> size_t


  Get size of user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_size(*args)

def user_labels_free(*args):
  """
  user_labels_free(map)


  Delete user_labels_t instance.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_free(*args)

def user_labels_new(*args):
  """
  user_labels_new() -> user_labels_t


  Create a new user_labels_t instance.
  """
  return _ida_hexrays.user_labels_new(*args)
class eamap_iterator_t(object):
    """
    Proxy of C++ eamap_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.eamap_iterator_t_x_get, _ida_hexrays.eamap_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.eamap_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.eamap_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> eamap_iterator_t
        """
        this = _ida_hexrays.new_eamap_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_eamap_iterator_t
    __del__ = lambda self : None;
eamap_iterator_t_swigregister = _ida_hexrays.eamap_iterator_t_swigregister
eamap_iterator_t_swigregister(eamap_iterator_t)


def eamap_begin(*args):
  """
  eamap_begin(map) -> eamap_iterator_t


  Get iterator pointing to the beginning of eamap_t.
  
  
  @param map (C++: const eamap_t *)
  """
  return _ida_hexrays.eamap_begin(*args)

def eamap_end(*args):
  """
  eamap_end(map) -> eamap_iterator_t


  Get iterator pointing to the end of eamap_t.
  
  
  @param map (C++: const eamap_t *)
  """
  return _ida_hexrays.eamap_end(*args)

def eamap_next(*args):
  """
  eamap_next(p) -> eamap_iterator_t


  Move to the next element.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_next(*args)

def eamap_prev(*args):
  """
  eamap_prev(p) -> eamap_iterator_t


  Move to the previous element.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_prev(*args)

def eamap_first(*args):
  """
  eamap_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_first(*args)

def eamap_second(*args):
  """
  eamap_second(p) -> cinsnptrvec_t


  Get reference to the current map value.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_second(*args)

def eamap_find(*args):
  """
  eamap_find(map, key) -> eamap_iterator_t


  Find the specified key in eamap_t.
  
  
  @param map (C++: const eamap_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.eamap_find(*args)

def eamap_insert(*args):
  """
  eamap_insert(map, key, val) -> eamap_iterator_t


  Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
  
  
  @param map (C++: eamap_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  cinsnptrvec_t  &)
  """
  return _ida_hexrays.eamap_insert(*args)

def eamap_erase(*args):
  """
  eamap_erase(map, p)


  Erase current element from eamap_t.
  
  
  @param map (C++: eamap_t *)
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_erase(*args)

def eamap_clear(*args):
  """
  eamap_clear(map)


  Clear eamap_t.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_clear(*args)

def eamap_size(*args):
  """
  eamap_size(map) -> size_t


  Get size of eamap_t.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_size(*args)

def eamap_free(*args):
  """
  eamap_free(map)


  Delete eamap_t instance.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_free(*args)

def eamap_new(*args):
  """
  eamap_new() -> eamap_t


  Create a new eamap_t instance.
  """
  return _ida_hexrays.eamap_new(*args)
class boundaries_iterator_t(object):
    """
    Proxy of C++ boundaries_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.boundaries_iterator_t_x_get, _ida_hexrays.boundaries_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.boundaries_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.boundaries_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> boundaries_iterator_t
        """
        this = _ida_hexrays.new_boundaries_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_boundaries_iterator_t
    __del__ = lambda self : None;
boundaries_iterator_t_swigregister = _ida_hexrays.boundaries_iterator_t_swigregister
boundaries_iterator_t_swigregister(boundaries_iterator_t)


def boundaries_begin(*args):
  """
  boundaries_begin(map) -> boundaries_iterator_t


  Get iterator pointing to the beginning of boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  """
  return _ida_hexrays.boundaries_begin(*args)

def boundaries_end(*args):
  """
  boundaries_end(map) -> boundaries_iterator_t


  Get iterator pointing to the end of boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  """
  return _ida_hexrays.boundaries_end(*args)

def boundaries_next(*args):
  """
  boundaries_next(p) -> boundaries_iterator_t


  Move to the next element.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_next(*args)

def boundaries_prev(*args):
  """
  boundaries_prev(p) -> boundaries_iterator_t


  Move to the previous element.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_prev(*args)

def boundaries_first(*args):
  """
  boundaries_first(p) -> cinsn_t


  Get reference to the current map key.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_first(*args)

def boundaries_second(*args):
  """
  boundaries_second(p) -> rangeset_t


  Get reference to the current map value.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_second(*args)

def boundaries_erase(*args):
  """
  boundaries_erase(map, p)


  Erase current element from boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_erase(*args)

def boundaries_clear(*args):
  """
  boundaries_clear(map)


  Clear boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_clear(*args)

def boundaries_size(*args):
  """
  boundaries_size(map) -> size_t


  Get size of boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_size(*args)

def boundaries_free(*args):
  """
  boundaries_free(map)


  Delete boundaries_t instance.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_free(*args)

def boundaries_new(*args):
  """
  boundaries_new() -> boundaries_t


  Create a new boundaries_t instance.
  """
  return _ida_hexrays.boundaries_new(*args)
class block_chains_iterator_t(object):
    """
    Proxy of C++ block_chains_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.block_chains_iterator_t_x_get, _ida_hexrays.block_chains_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.block_chains_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.block_chains_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> block_chains_iterator_t
        """
        this = _ida_hexrays.new_block_chains_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_block_chains_iterator_t
    __del__ = lambda self : None;
block_chains_iterator_t_swigregister = _ida_hexrays.block_chains_iterator_t_swigregister
block_chains_iterator_t_swigregister(block_chains_iterator_t)


def block_chains_begin(*args):
  """
  block_chains_begin(set) -> block_chains_iterator_t


  Get iterator pointing to the beginning of 'block_chains_t' .
  
  
  @param set (C++: const  block_chains_t  *)
  """
  return _ida_hexrays.block_chains_begin(*args)

def block_chains_end(*args):
  """
  block_chains_end(set) -> block_chains_iterator_t


  Get iterator pointing to the end of 'block_chains_t' .
  
  
  @param set (C++: const  block_chains_t  *)
  """
  return _ida_hexrays.block_chains_end(*args)

def block_chains_next(*args):
  """
  block_chains_next(p) -> block_chains_iterator_t


  Move to the next element.
  
  
  @param p (C++: block_chains_iterator_t)
  """
  return _ida_hexrays.block_chains_next(*args)

def block_chains_prev(*args):
  """
  block_chains_prev(p) -> block_chains_iterator_t


  Move to the previous element.
  
  
  @param p (C++: block_chains_iterator_t)
  """
  return _ida_hexrays.block_chains_prev(*args)

def block_chains_get(*args):
  """
  block_chains_get(p) -> chain_t


  Get reference to the current set value.
  
  
  @param p (C++: block_chains_iterator_t)
  """
  return _ida_hexrays.block_chains_get(*args)

def block_chains_find(*args):
  """
  block_chains_find(set, val) -> block_chains_iterator_t


  Find the specified key in set 'block_chains_t' .
  
  
  @param set (C++: const  block_chains_t  *)
  @param val (C++: const  chain_t  &)
  """
  return _ida_hexrays.block_chains_find(*args)

def block_chains_insert(*args):
  """
  block_chains_insert(set, val) -> block_chains_iterator_t


  Insert new ( 'chain_t' ) into set 'block_chains_t' .
  
  
  @param set (C++: block_chains_t  *)
  @param val (C++: const  chain_t  &)
  """
  return _ida_hexrays.block_chains_insert(*args)

def block_chains_erase(*args):
  """
  block_chains_erase(set, p)


  Erase current element from 'block_chains_t' .
  
  
  @param set (C++: block_chains_t  *)
  @param p (C++: block_chains_iterator_t)
  """
  return _ida_hexrays.block_chains_erase(*args)

def block_chains_clear(*args):
  """
  block_chains_clear(set)


  Clear 'block_chains_t' .
  
  
  @param set (C++: block_chains_t  *)
  """
  return _ida_hexrays.block_chains_clear(*args)

def block_chains_size(*args):
  """
  block_chains_size(set) -> size_t


  Get size of 'block_chains_t' .
  
  
  @param set (C++: block_chains_t  *)
  """
  return _ida_hexrays.block_chains_size(*args)

def block_chains_free(*args):
  """
  block_chains_free(set)


  Delete 'block_chains_t' instance.
  
  
  @param set (C++: block_chains_t  *)
  """
  return _ida_hexrays.block_chains_free(*args)

def block_chains_new(*args):
  """
  block_chains_new() -> block_chains_t


  Create a new 'block_chains_t' instance.
  """
  return _ida_hexrays.block_chains_new(*args)
#<pycode(py_hexrays)>
import ida_funcs

hexrays_failure_t.__str__ = lambda self: str("%x: %s" % (self.errea, self.desc()))

# ---------------------------------------------------------------------
# Renamings
is_allowed_on_small_struni = accepts_small_udts
is_small_struni = is_small_udt

# ---------------------------------------------------------------------
class DecompilationFailure(Exception):
    """
     Raised on a decompilation error.

    The associated hexrays_failure_t object is stored in the
    'info' member of this exception. 
"""

    def __init__(self, info):
        Exception.__init__(self, 'Decompilation failed: %s' % (str(info), ))
        self.info = info
        return

# ---------------------------------------------------------------------
def decompile(ea, hf=None, flags=0):
    if isinstance(ea, (int, long)):
        func = ida_funcs.get_func(ea)
        if not func: return
    elif type(ea) == ida_funcs.func_t:
        func = ea
    else:
        raise RuntimeError('arg 1 of decompile expects either ea_t or cfunc_t argument')

    if hf is None:
        hf = hexrays_failure_t()

    ptr = _ida_hexrays.decompile_func(func, hf, flags)

    if ptr.__deref__() is None:
        raise DecompilationFailure(hf)

    return ptr

# ---------------------------------------------------------------------
# stringify all string types
#qtype.__str__ = qtype.c_str
#qstring.__str__ = qstring.c_str
#citem_cmt_t.__str__ = citem_cmt_t.c_str

# ---------------------------------------------------------------------
# listify all list types
import ida_idaapi
ida_idaapi._listify_types(
        cinsnptrvec_t,
        ctree_items_t,
        qvector_lvar_t,
        qvector_carg_t,
        qvector_ccase_t,
        hexwarns_t,
        history_t,
        lvar_saved_infos_t,
        ui_stroff_ops_t)

def citem_to_specific_type(self):
    """
     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
    """

    if self.op >= cot_empty and self.op <= cot_last:
        return self.cexpr
    elif self.op >= cit_empty and self.op < cit_end:
        return self.cinsn

    raise RuntimeError('unknown op type %s' % (repr(self.op), ))
citem_t.to_specific_type = property(citem_to_specific_type)

"""
 array used for translating cinsn_t->op type to their names. 
"""
cinsn_t.op_to_typename = {}
for k in dir(_ida_hexrays):
    if k.startswith('cit_'):
        cinsn_t.op_to_typename[getattr(_ida_hexrays, k)] = k[4:]

"""
 array used for translating cexpr_t->op type to their names. 
"""
cexpr_t.op_to_typename = {}
for k in dir(_ida_hexrays):
    if k.startswith('cot_'):
        cexpr_t.op_to_typename[getattr(_ida_hexrays, k)] = k[4:]

def property_op_to_typename(self):
    return self.op_to_typename[self.op]
cinsn_t.opname = property(property_op_to_typename)
cexpr_t.opname = property(property_op_to_typename)

def cexpr_operands(self):
    """
     return a dictionary with the operands of a cexpr_t. 
    """

    if self.op >= cot_comma and self.op <= cot_asgumod or \
        self.op >= cot_lor and self.op <= cot_fdiv or \
        self.op == cot_idx:
        return {'x': self.x, 'y': self.y}

    elif self.op == cot_tern:
        return {'x': self.x, 'y': self.y, 'z': self.z}

    elif self.op in [cot_fneg, cot_neg, cot_sizeof] or \
        self.op >= cot_lnot and self.op <= cot_predec:
        return {'x': self.x}

    elif self.op == cot_cast:
        return {'type': self.type, 'x': self.x}

    elif self.op == cot_call:
        return {'x': self.x, 'a': self.a}

    elif self.op in [cot_memref, cot_memptr]:
        return {'x': self.x, 'm': self.m}

    elif self.op == cot_num:
        return {'n': self.n}

    elif self.op == cot_fnum:
        return {'fpc': self.fpc}

    elif self.op == cot_str:
        return {'string': self.string}

    elif self.op == cot_obj:
        return {'obj_ea': self.obj_ea}

    elif self.op == cot_var:
        return {'v': self.v}

    elif self.op == cot_helper:
        return {'helper': self.helper}

    raise RuntimeError('unknown op type %s' % self.opname)
cexpr_t.operands = property(cexpr_operands)

def cinsn_details(self):
    """
     return the details pointer for the cinsn_t object depending on the value of its op member. \
        this is one of the cblock_t, cif_t, etc. objects. 
"""

    if self.op not in self.op_to_typename:
        raise RuntimeError('unknown item->op type')

    opname = self.opname
    if opname == 'empty':
        return self

    if opname in ['break', 'continue']:
        return None

    return getattr(self, 'c' + opname)
cinsn_t.details = property(cinsn_details)

def cblock_iter(self):

    iter = self.begin()
    for i in range(self.size()):
        yield iter.cur
        next(iter)

    return
cblock_t.__iter__ = cblock_iter
cblock_t.__len__ = cblock_t.size

# cblock.find(cinsn_t) -> returns the iterator positioned at the given item
def cblock_find(self, item):

    iter = self.begin()
    for i in range(self.size()):
        if iter.cur == item:
            return iter
        next(iter)

    return
cblock_t.find = cblock_find

# cblock.index(cinsn_t) -> returns the index of the given item
def cblock_index(self, item):

    iter = self.begin()
    for i in range(self.size()):
        if iter.cur == item:
            return i
        next(iter)

    return
cblock_t.index = cblock_index

# cblock.at(int) -> returns the item at the given index index
def cblock_at(self, index):

    iter = self.begin()
    for i in range(self.size()):
        if i == index:
            return iter.cur
        next(iter)

    return
cblock_t.at = cblock_at

# cblock.remove(cinsn_t)
def cblock_remove(self, item):

    iter = self.find(item)
    self.erase(iter)

    return
cblock_t.remove = cblock_remove

# cblock.insert(index, cinsn_t)
def cblock_insert(self, index, item):

    pos = self.at(index)
    iter = self.find(pos)
    self.insert(iter, item)

    return
cblock_t.insert = cblock_insert

cfuncptr_t.__str__ = lambda self: str(self.__deref__())

import ida_typeinf
def cfunc_type(self):
    """
     Get the function's return type tinfo_t object. 
    """
    tif = ida_typeinf.tinfo_t()
    result = self.get_func_type(tif)
    if not result:
        return
    return tif
cfunc_t.type = property(cfunc_type)
cfuncptr_t.type = property(lambda self: self.__deref__().type)

cfunc_t.arguments = property(lambda self: [o for o in self.lvars if o.is_arg_var])
cfuncptr_t.arguments = property(lambda self: self.__deref__().arguments)

cfunc_t.lvars = property(cfunc_t.get_lvars)
cfuncptr_t.lvars = property(lambda self: self.__deref__().lvars)
cfunc_t.warnings = property(cfunc_t.get_warnings)
cfuncptr_t.warnings = property(lambda self: self.__deref__().warnings)
cfunc_t.pseudocode = property(cfunc_t.get_pseudocode)
cfuncptr_t.pseudocode = property(lambda self: self.__deref__().get_pseudocode())
cfunc_t.eamap = property(cfunc_t.get_eamap)
cfuncptr_t.eamap = property(lambda self: self.__deref__().get_eamap())
cfunc_t.boundaries = property(cfunc_t.get_boundaries)
cfuncptr_t.boundaries = property(lambda self: self.__deref__().get_boundaries())

#pragma SWIG nowarn=+503

lvar_t.used = property(lvar_t.used)
lvar_t.typed = property(lvar_t.typed)
lvar_t.mreg_done = property(lvar_t.mreg_done)
lvar_t.has_nice_name = property(lvar_t.has_nice_name)
lvar_t.is_unknown_width = property(lvar_t.is_unknown_width)
lvar_t.has_user_info = property(lvar_t.has_user_info)
lvar_t.has_user_name = property(lvar_t.has_user_name)
lvar_t.has_user_type = property(lvar_t.has_user_type)
lvar_t.is_result_var = property(lvar_t.is_result_var)
lvar_t.is_arg_var = property(lvar_t.is_arg_var)
lvar_t.is_fake_var = property(lvar_t.is_fake_var)
lvar_t.is_overlapped_var = property(lvar_t.is_overlapped_var)
lvar_t.is_floating_var = property(lvar_t.is_floating_var)
lvar_t.is_spoiled_var = property(lvar_t.is_spoiled_var)
lvar_t.is_mapdst_var = property(lvar_t.is_mapdst_var)

# dictify all dict-like types
def _map_as_dict(maptype, name, keytype, valuetype):

    maptype.keytype = keytype
    maptype.valuetype = valuetype

    for fctname in ['begin', 'end', 'first', 'second', 'next', \
                        'find', 'insert', 'erase', 'clear', 'size']:
        fct = getattr(_ida_hexrays, name + '_' + fctname)
        setattr(maptype, '__' + fctname, fct)

    maptype.__len__ = maptype.size
    maptype.__getitem__ = maptype.at

    maptype.begin = lambda self, *args: self.__begin(self, *args)
    maptype.end = lambda self, *args: self.__end(self, *args)
    maptype.first = lambda self, *args: self.__first(*args)
    maptype.second = lambda self, *args: self.__second(*args)
    maptype.next = lambda self, *args: self.__next(*args)
    maptype.find = lambda self, *args: self.__find(self, *args)
    maptype.insert = lambda self, *args: self.__insert(self, *args)
    maptype.erase = lambda self, *args: self.__erase(self, *args)
    maptype.clear = lambda self, *args: self.__clear(self, *args)
    maptype.size = lambda self, *args: self.__size(self, *args)

    def _map___iter__(self):
        """
         Iterate over dictionary keys. 
        """
        return self.iterkeys()
    maptype.__iter__ = _map___iter__

    def _map___getitem__(self, key):
        """
         Returns the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of key should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        return self.second(self.find(key))
    maptype.__getitem__ = _map___getitem__

    def _map___setitem__(self, key, value):
        """
         Returns the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if not isinstance(value, self.valuetype):
            raise KeyError('type of `value` should be ' + repr(self.valuetype) + ' but got ' + type(value))
        self.insert(key, value)
        return
    maptype.__setitem__ = _map___setitem__

    def _map___delitem__(self, key):
        """
         Removes the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        self.erase(self.find(key))
        return
    maptype.__delitem__ = _map___delitem__

    def _map___contains__(self, key):
        """
         Returns true if the specified key exists in the . 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if self.find(key) != self.end():
            return True
        return False
    maptype.__contains__ = _map___contains__

    def _map_clear(self):
        self.clear()
        return
    maptype.clear = _map_clear

    def _map_copy(self):
        ret = {}
        for k in self.iterkeys():
            ret[k] = self[k]
        return ret
    maptype.copy = _map_copy

    def _map_get(self, key, default=None):
        if key in self:
            return self[key]
        return default
    maptype.get = _map_get

    def _map_iterkeys(self):
        iter = self.begin()
        while iter != self.end():
            yield self.first(iter)
            iter = self.next(iter)
        return
    maptype.iterkeys = _map_iterkeys

    def _map_itervalues(self):
        iter = self.begin()
        while iter != self.end():
            yield self.second(iter)
            iter = self.next(iter)
        return
    maptype.itervalues = _map_itervalues

    def _map_iteritems(self):
        iter = self.begin()
        while iter != self.end():
            yield (self.first(iter), self.second(iter))
            iter = self.next(iter)
        return
    maptype.iteritems = _map_iteritems

    def _map_keys(self):
        return list(self.iterkeys())
    maptype.keys = _map_keys

    def _map_values(self):
        return list(self.itervalues())
    maptype.values = _map_values

    def _map_items(self):
        return list(self.iteritems())
    maptype.items = _map_items

    def _map_has_key(self, key):
        return key in self
    maptype.has_key = _map_has_key

    def _map_pop(self, key):
        """
         Sets the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        ret = self[key]
        del self[key]
        return ret
    maptype.pop = _map_pop

    def _map_popitem(self):
        """
         Sets the value associated with the provided key. 
        """
        if len(self) == 0:
            raise KeyError('key not found')
        key = self.keys()[0]
        return (key, self.pop(key))
    maptype.popitem = _map_popitem

    def _map_setdefault(self, key, default=None):
        """
         Sets the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key in self:
            return self[key]
        self[key] = default
        return default
    maptype.setdefault = _map_setdefault

#_map_as_dict(user_labels_t, 'user_labels', (int, long), qstring)
_map_as_dict(user_cmts_t, 'user_cmts', treeloc_t, citem_cmt_t)
_map_as_dict(user_numforms_t, 'user_numforms', operand_locator_t, number_format_t)
_map_as_dict(user_iflags_t, 'user_iflags', citem_locator_t, int)
import ida_pro
_map_as_dict(user_unions_t, 'user_unions', (int, long), ida_pro.intvec_t)
_map_as_dict(eamap_t, 'eamap', long, cinsnptrvec_t)
import ida_range
_map_as_dict(boundaries_t, 'boundaries', cinsn_t, ida_range.rangeset_t)

#
# Object ownership
#
def _call_with_transferrable_ownership(fun, *args):
    e = args[0]
    was_owned = e.thisown
    res = fun(e, *args[1:])
    # ATM, 'res' doesn't own the resulting cexpr_t.
    # In case 'fun'
    #   - created a new object: we want to own that one in case 'e' was owned
    #   - didn't create a new object: we will remove & re-gain ownership on
    #                                 the same underlying cexpr_t. No biggie.
    if was_owned:
        if res:
            e._maybe_disown_and_deregister()
            res._own_and_register()
    else:
        debug_hexrays_ctree("NOTE: call_with_transferrable_ownership() called with non-IDAPython-owned object. Is this intentional?")
    return res

def lnot(e):
    return _call_with_transferrable_ownership(_ll_lnot, e)

def make_ref(e):
    return _call_with_transferrable_ownership(_ll_make_ref, e)

def dereference(e, ptrsize, is_float=False):
    return _call_with_transferrable_ownership(_ll_dereference, e, ptrsize, is_float)

def call_helper(rettype, args, *rest):
    res = _ll_call_helper(rettype, args, *rest)
    if res:
        res._own_and_register()
        if type(args) == carglist_t:
            args.thisown = False
    return res

def new_block():
    res = _ll_new_block()
    if res:
        res._own_and_register()
    return res

def make_num(*args):
    res = _ll_make_num(*args)
    if res:
        res._own_and_register()
    return res

def create_helper(*args):
    res = _ll_create_helper(*args)
    if res:
        res._own_and_register()
    return res

# ----------------

class __cbhooks_t(Hexrays_Hooks):

    instances = []

    def __init__(self, callback):
        self.callback = callback
        self.instances.append(self)
        Hexrays_Hooks.__init__(self)

    def maturity(self, *args): return self.callback(hxe_maturity, *args)
    def interr(self, *args): return self.callback(hxe_interr, *args)
    def print_func(self, *args): return self.callback(hxe_print_func, *args)
    def func_printed(self, *args): return self.callback(hxe_func_printed, *args)
    def open_pseudocode(self, *args): return self.callback(hxe_open_pseudocode, *args)
    def switch_pseudocode(self, *args): return self.callback(hxe_switch_pseudocode, *args)
    def refresh_pseudocode(self, *args): return self.callback(hxe_refresh_pseudocode, *args)
    def close_pseudocode(self, *args): return self.callback(hxe_close_pseudocode, *args)
    def keyboard(self, *args): return self.callback(hxe_keyboard, *args)
    def right_click(self, *args): return self.callback(hxe_right_click, *args)
    def double_click(self, *args): return self.callback(hxe_double_click, *args)
    def curpos(self, *args): return self.callback(hxe_curpos, *args)
    def create_hint(self, *args): return self.callback(hxe_create_hint, *args)
    def text_ready(self, *args): return self.callback(hxe_text_ready, *args)
    def populating_popup(self, *args): return self.callback(hxe_populating_popup, *args)


def install_hexrays_callback(callback):
    "Deprecated. Please use Hexrays_Hooks instead"
    h = __cbhooks_t(callback)
    h.hook()
    return True

def remove_hexrays_callback(callback):
    "Deprecated. Please use Hexrays_Hooks instead"
    for inst in __cbhooks_t.instances:
        if inst.callback == callback:
            inst.unhook()
            __cbhooks_t.instances.remove(inst)
            return 1
    return 0

#</pycode(py_hexrays)>

if _BC695:
    get_tform_vdui=get_widget_vdui
    hx_get_tform_vdui=hx_get_widget_vdui
    HEXRAYS_API_MAGIC1=(HEXRAYS_API_MAGIC>>32)
    HEXRAYS_API_MAGIC2=(HEXRAYS_API_MAGIC&0xFFFFFFFF)


