# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: typeinf
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_typeinf', [dirname(__file__)])
        except ImportError:
            import _ida_typeinf
            return _ida_typeinf
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_typeinf', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_typeinf = swig_import_helper()
    del swig_import_helper
else:
    import _ida_typeinf
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_idp
class funcargvec_t(object):
    """
    Proxy of C++ qvector<(funcarg_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> funcargvec_t
        __init__(self, x) -> funcargvec_t
        """
        this = _ida_typeinf.new_funcargvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_funcargvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.funcargvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.funcargvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.funcargvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.funcargvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.funcargvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=funcarg_t())
        """
        return _ida_typeinf.funcargvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.funcargvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.funcargvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.funcargvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.funcargvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.funcargvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.funcargvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> funcarg_t
        begin(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> funcarg_t
        end(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> funcarg_t
        erase(self, first, last) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> funcarg_t
        find(self, x) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_typeinf.funcargvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_typeinf.funcargvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_typeinf.funcargvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.funcargvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

funcargvec_t_swigregister = _ida_typeinf.funcargvec_t_swigregister
funcargvec_t_swigregister(funcargvec_t)

class udtmembervec_t(object):
    """
    Proxy of C++ qvector<(udt_member_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> udtmembervec_t
        __init__(self, x) -> udtmembervec_t
        """
        this = _ida_typeinf.new_udtmembervec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_udtmembervec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.udtmembervec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.udtmembervec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.udtmembervec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.udtmembervec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.udtmembervec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=udt_member_t())
        """
        return _ida_typeinf.udtmembervec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.udtmembervec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.udtmembervec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.udtmembervec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.udtmembervec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.udtmembervec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.udtmembervec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> udt_member_t
        begin(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> udt_member_t
        end(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> udt_member_t
        erase(self, first, last) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> udt_member_t
        find(self, x) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_typeinf.udtmembervec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_typeinf.udtmembervec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_typeinf.udtmembervec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.udtmembervec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

udtmembervec_t_swigregister = _ida_typeinf.udtmembervec_t_swigregister
udtmembervec_t_swigregister(udtmembervec_t)

class reginfovec_t(object):
    """
    Proxy of C++ qvector<(reg_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> reginfovec_t
        __init__(self, x) -> reginfovec_t
        """
        this = _ida_typeinf.new_reginfovec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_reginfovec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.reginfovec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.reginfovec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.reginfovec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.reginfovec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.reginfovec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=reg_info_t())
        """
        return _ida_typeinf.reginfovec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.reginfovec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.reginfovec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.reginfovec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.reginfovec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.reginfovec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.reginfovec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> reg_info_t
        begin(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> reg_info_t
        end(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> reg_info_t
        erase(self, first, last) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> reg_info_t
        find(self, x) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_typeinf.reginfovec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_typeinf.reginfovec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_typeinf.reginfovec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.reginfovec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

reginfovec_t_swigregister = _ida_typeinf.reginfovec_t_swigregister
reginfovec_t_swigregister(reginfovec_t)

class enum_member_vec_t(object):
    """
    Proxy of C++ qvector<(enum_member_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> enum_member_vec_t
        __init__(self, x) -> enum_member_vec_t
        """
        this = _ida_typeinf.new_enum_member_vec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_enum_member_vec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.enum_member_vec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.enum_member_vec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.enum_member_vec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.enum_member_vec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.enum_member_vec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=enum_member_t())
        """
        return _ida_typeinf.enum_member_vec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.enum_member_vec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.enum_member_vec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.enum_member_vec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.enum_member_vec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.enum_member_vec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.enum_member_vec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> enum_member_t
        begin(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> enum_member_t
        end(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> enum_member_t
        erase(self, first, last) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> enum_member_t
        find(self, x) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_typeinf.enum_member_vec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_typeinf.enum_member_vec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_typeinf.enum_member_vec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.enum_member_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

enum_member_vec_t_swigregister = _ida_typeinf.enum_member_vec_t_swigregister
enum_member_vec_t_swigregister(enum_member_vec_t)

class argpartvec_t(object):
    """
    Proxy of C++ qvector<(argpart_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> argpartvec_t
        __init__(self, x) -> argpartvec_t
        """
        this = _ida_typeinf.new_argpartvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_argpartvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.argpartvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.argpartvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.argpartvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.argpartvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.argpartvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=argpart_t())
        """
        return _ida_typeinf.argpartvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.argpartvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.argpartvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.argpartvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.argpartvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.argpartvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.argpartvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> argpart_t
        begin(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> argpart_t
        end(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> argpart_t
        erase(self, first, last) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> argpart_t
        find(self, x) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_typeinf.argpartvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_typeinf.argpartvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_typeinf.argpartvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.argpartvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

argpartvec_t_swigregister = _ida_typeinf.argpartvec_t_swigregister
argpartvec_t_swigregister(argpartvec_t)

class valstrvec_t(object):
    """
    Proxy of C++ qvector<(valstr_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> valstrvec_t
        __init__(self, x) -> valstrvec_t
        """
        this = _ida_typeinf.new_valstrvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_valstrvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.valstrvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.valstrvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.valstrvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.valstrvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.valstrvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=valstr_t())
        """
        return _ida_typeinf.valstrvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.valstrvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.valstrvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.valstrvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.valstrvec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> valstr_t
        begin(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> valstr_t
        end(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> valstr_t
        erase(self, first, last) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.valstrvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

valstrvec_t_swigregister = _ida_typeinf.valstrvec_t_swigregister
valstrvec_t_swigregister(valstrvec_t)

class regobjvec_t(object):
    """
    Proxy of C++ qvector<(regobj_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> regobjvec_t
        __init__(self, x) -> regobjvec_t
        """
        this = _ida_typeinf.new_regobjvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_regobjvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.regobjvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.regobjvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.regobjvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.regobjvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.regobjvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=regobj_t())
        """
        return _ida_typeinf.regobjvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.regobjvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.regobjvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.regobjvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.regobjvec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> regobj_t
        begin(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> regobj_t
        end(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> regobj_t
        erase(self, first, last) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.regobjvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

regobjvec_t_swigregister = _ida_typeinf.regobjvec_t_swigregister
regobjvec_t_swigregister(regobjvec_t)

class type_attrs_t(object):
    """
    Proxy of C++ qvector<(type_attr_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> type_attrs_t
        __init__(self, x) -> type_attrs_t
        """
        this = _ida_typeinf.new_type_attrs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_type_attrs_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_typeinf.type_attrs_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.type_attrs_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_typeinf.type_attrs_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.type_attrs_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_typeinf.type_attrs_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=type_attr_t())
        """
        return _ida_typeinf.type_attrs_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_typeinf.type_attrs_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_typeinf.type_attrs_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.type_attrs_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_typeinf.type_attrs_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> type_attr_t
        begin(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> type_attr_t
        end(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> type_attr_t
        erase(self, first, last) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_typeinf.type_attrs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

type_attrs_t_swigregister = _ida_typeinf.type_attrs_t_swigregister
type_attrs_t_swigregister(type_attrs_t)

RESERVED_BYTE = _ida_typeinf.RESERVED_BYTE
"""
multifunctional purpose
"""

def is_type_const(*args):
  """
  is_type_const(t) -> bool


  See 'BTM_CONST' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_const(*args)

def is_type_volatile(*args):
  """
  is_type_volatile(t) -> bool


  See 'BTM_VOLATILE' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_volatile(*args)

def get_base_type(*args):
  """
  get_base_type(t) -> type_t


  Get get basic type bits ( 'TYPE_BASE_MASK' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.get_base_type(*args)

def get_type_flags(*args):
  """
  get_type_flags(t) -> type_t


  Get type flags ( 'TYPE_FLAGS_MASK' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.get_type_flags(*args)

def get_full_type(*args):
  """
  get_full_type(t) -> type_t


  Get basic type bits + type flags ( 'TYPE_FULL_MASK' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.get_full_type(*args)

def is_typeid_last(*args):
  """
  is_typeid_last(t) -> bool


  Is the type_t the last byte of type declaration? (there are no
  additional bytes after a basic type, see '_BT_LAST_BASIC' )
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_typeid_last(*args)

def is_type_partial(*args):
  """
  is_type_partial(t) -> bool


  Identifies an unknown or void type with a known size (see 'Basic type:
  unknown & void' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_partial(*args)

def is_type_void(*args):
  """
  is_type_void(t) -> bool


  See 'BTF_VOID' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_void(*args)

def is_type_unknown(*args):
  """
  is_type_unknown(t) -> bool


  See 'BT_UNKNOWN' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_unknown(*args)

def is_type_ptr(*args):
  """
  is_type_ptr(t) -> bool


  See 'BT_PTR' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_ptr(*args)

def is_type_complex(*args):
  """
  is_type_complex(t) -> bool


  See 'BT_COMPLEX' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_complex(*args)

def is_type_func(*args):
  """
  is_type_func(t) -> bool


  See 'BT_FUNC' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_func(*args)

def is_type_array(*args):
  """
  is_type_array(t) -> bool


  See 'BT_ARRAY' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_array(*args)

def is_type_typedef(*args):
  """
  is_type_typedef(t) -> bool


  See 'BTF_TYPEDEF' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_typedef(*args)

def is_type_sue(*args):
  """
  is_type_sue(t) -> bool


  Is the type a struct/union/enum?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_sue(*args)

def is_type_struct(*args):
  """
  is_type_struct(t) -> bool


  See 'BTF_STRUCT' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_struct(*args)

def is_type_union(*args):
  """
  is_type_union(t) -> bool


  See 'BTF_UNION' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_union(*args)

def is_type_struni(*args):
  """
  is_type_struni(t) -> bool


  Is the type a struct or union?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_struni(*args)

def is_type_enum(*args):
  """
  is_type_enum(t) -> bool


  See 'BTF_ENUM' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_enum(*args)

def is_type_bitfld(*args):
  """
  is_type_bitfld(t) -> bool


  See 'BT_BITFIELD' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_bitfld(*args)

def is_type_int(*args):
  """
  is_type_int(bt) -> bool


  Does the type_t specify one of the basic types in 'Basic type:
  integer' ?
  
  
  @param bt (C++: type_t)
  """
  return _ida_typeinf.is_type_int(*args)

def is_type_int128(*args):
  """
  is_type_int128(t) -> bool


  Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
  type: integer' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_int128(*args)

def is_type_int64(*args):
  """
  is_type_int64(t) -> bool


  Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
  type: integer' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_int64(*args)

def is_type_int32(*args):
  """
  is_type_int32(t) -> bool


  Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
  type: integer' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_int32(*args)

def is_type_int16(*args):
  """
  is_type_int16(t) -> bool


  Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
  type: integer' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_int16(*args)

def is_type_char(*args):
  """
  is_type_char(t) -> bool


  Does the type specify a char value? (signed or unsigned, see 'Basic
  type: integer' )
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_char(*args)

def is_type_paf(*args):
  """
  is_type_paf(t) -> bool


  Is the type a pointer, array, or function type?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_paf(*args)

def is_type_ptr_or_array(*args):
  """
  is_type_ptr_or_array(t) -> bool


  Is the type a pointer or array type?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_ptr_or_array(*args)

def is_type_floating(*args):
  """
  is_type_floating(t) -> bool


  Is the type a floating point type?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_floating(*args)

def is_type_integral(*args):
  """
  is_type_integral(t) -> bool


  Is the type an integral type (char/short/int/long/bool)?
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_integral(*args)

def is_type_ext_integral(*args):
  """
  is_type_ext_integral(t) -> bool


  Is the type an extended integral type? (integral or enum)
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_ext_integral(*args)

def is_type_arithmetic(*args):
  """
  is_type_arithmetic(t) -> bool


  Is the type an arithmetic type? (floating or integral)
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_arithmetic(*args)

def is_type_ext_arithmetic(*args):
  """
  is_type_ext_arithmetic(t) -> bool


  Is the type an extended arithmetic type? (arithmetic or enum)
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_ext_arithmetic(*args)

def is_type_uint(*args):
  """
  is_type_uint(t) -> bool


  See 'BTF_UINT' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uint(*args)

def is_type_uchar(*args):
  """
  is_type_uchar(t) -> bool


  See 'BTF_UCHAR' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uchar(*args)

def is_type_uint16(*args):
  """
  is_type_uint16(t) -> bool


  See 'BTF_UINT16' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uint16(*args)

def is_type_uint32(*args):
  """
  is_type_uint32(t) -> bool


  See 'BTF_UINT32' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uint32(*args)

def is_type_uint64(*args):
  """
  is_type_uint64(t) -> bool


  See 'BTF_UINT64' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uint64(*args)

def is_type_uint128(*args):
  """
  is_type_uint128(t) -> bool


  See 'BTF_UINT128' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_uint128(*args)

def is_type_ldouble(*args):
  """
  is_type_ldouble(t) -> bool


  See 'BTF_LDOUBLE' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_ldouble(*args)

def is_type_double(*args):
  """
  is_type_double(t) -> bool


  See 'BTF_DOUBLE' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_double(*args)

def is_type_float(*args):
  """
  is_type_float(t) -> bool


  See 'BTF_FLOAT' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_float(*args)

def is_type_tbyte(*args):
  """
  is_type_tbyte(t) -> bool


  See 'BTF_FLOAT' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_tbyte(*args)

def is_type_bool(*args):
  """
  is_type_bool(t) -> bool


  See 'BTF_BOOL' .
  
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_type_bool(*args)
TAH_BYTE = _ida_typeinf.TAH_BYTE
"""
type attribute header byte
"""
FAH_BYTE = _ida_typeinf.FAH_BYTE
"""
function argument attribute header byte
"""
MAX_DECL_ALIGN = _ida_typeinf.MAX_DECL_ALIGN
TAH_HASATTRS = _ida_typeinf.TAH_HASATTRS
"""
has extended attributes
"""
TAUDT_UNALIGNED = _ida_typeinf.TAUDT_UNALIGNED
"""
struct: unaligned struct
"""
TAUDT_MSSTRUCT = _ida_typeinf.TAUDT_MSSTRUCT
"""
struct: gcc msstruct attribute
"""
TAUDT_CPPOBJ = _ida_typeinf.TAUDT_CPPOBJ
"""
struct: a c++ object, not simple pod type
"""
TAUDT_VFTABLE = _ida_typeinf.TAUDT_VFTABLE
"""
struct: is virtual function table
"""
TAFLD_BASECLASS = _ida_typeinf.TAFLD_BASECLASS
"""
field: do not include but inherit from the current field
"""
TAFLD_UNALIGNED = _ida_typeinf.TAFLD_UNALIGNED
"""
field: unaligned field
"""
TAFLD_VIRTBASE = _ida_typeinf.TAFLD_VIRTBASE
"""
field: virtual base (not supported yet)
"""
TAFLD_VFTABLE = _ida_typeinf.TAFLD_VFTABLE
"""
field: ptr to virtual function table
"""
TAPTR_PTR32 = _ida_typeinf.TAPTR_PTR32
"""
ptr: __ptr32
"""
TAPTR_PTR64 = _ida_typeinf.TAPTR_PTR64
"""
ptr: __ptr64
"""
TAPTR_RESTRICT = _ida_typeinf.TAPTR_RESTRICT
"""
ptr: __restrict
"""
TAPTR_SHIFTED = _ida_typeinf.TAPTR_SHIFTED
"""
ptr: __shifted(parent_struct, delta)
"""
TAENUM_64BIT = _ida_typeinf.TAENUM_64BIT
"""
enum: store 64-bit values
"""
TAENUM_UNSIGNED = _ida_typeinf.TAENUM_UNSIGNED
"""
enum: unsigned
"""
TAENUM_SIGNED = _ida_typeinf.TAENUM_SIGNED
"""
enum: signed
"""
TAH_ALL = _ida_typeinf.TAH_ALL
"""
all defined bits
"""

def is_tah_byte(*args):
  """
  is_tah_byte(t) -> bool


  The TAH byte (type attribute header byte) denotes the start of type
  attributes. (see "tah-typeattrs" in the type bit definitions)
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_tah_byte(*args)

def is_sdacl_byte(*args):
  """
  is_sdacl_byte(t) -> bool


  Identify an sdacl byte. The first sdacl byte has the following format:
  11xx000x. The sdacl bytes are appended to udt fields. They indicate
  the start of type attributes (as the tah-bytes do). The sdacl bytes
  are used in the udt headers instead of the tah-byte. This is done for
  compatibility with old databases, they were already using sdacl bytes
  in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
  the type bit definitions)
  
  @param t (C++: type_t)
  """
  return _ida_typeinf.is_sdacl_byte(*args)
class type_attr_t(object):
    """
    Proxy of C++ type_attr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    key = _swig_property(_ida_typeinf.type_attr_t_key_get, _ida_typeinf.type_attr_t_key_set)
    value = _swig_property(_ida_typeinf.type_attr_t_value_get, _ida_typeinf.type_attr_t_value_set)
    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.type_attr_t___lt__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_typeinf.type_attr_t___ge__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> type_attr_t
        """
        this = _ida_typeinf.new_type_attr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_type_attr_t
    __del__ = lambda self : None;
type_attr_t_swigregister = _ida_typeinf.type_attr_t_swigregister
type_attr_t_swigregister(type_attr_t)
cvar = _ida_typeinf.cvar
TYPE_BASE_MASK = cvar.TYPE_BASE_MASK
TYPE_FLAGS_MASK = cvar.TYPE_FLAGS_MASK
TYPE_MODIF_MASK = cvar.TYPE_MODIF_MASK
TYPE_FULL_MASK = cvar.TYPE_FULL_MASK
BT_UNK = cvar.BT_UNK
BT_VOID = cvar.BT_VOID
BTMT_SIZE0 = cvar.BTMT_SIZE0
BTMT_SIZE12 = cvar.BTMT_SIZE12
BTMT_SIZE48 = cvar.BTMT_SIZE48
BTMT_SIZE128 = cvar.BTMT_SIZE128
BT_INT8 = cvar.BT_INT8
BT_INT16 = cvar.BT_INT16
BT_INT32 = cvar.BT_INT32
BT_INT64 = cvar.BT_INT64
BT_INT128 = cvar.BT_INT128
BT_INT = cvar.BT_INT
BTMT_UNKSIGN = cvar.BTMT_UNKSIGN
BTMT_SIGNED = cvar.BTMT_SIGNED
BTMT_USIGNED = cvar.BTMT_USIGNED
BTMT_UNSIGNED = cvar.BTMT_UNSIGNED
BTMT_CHAR = cvar.BTMT_CHAR
BT_BOOL = cvar.BT_BOOL
BTMT_DEFBOOL = cvar.BTMT_DEFBOOL
BTMT_BOOL1 = cvar.BTMT_BOOL1
BTMT_BOOL2 = cvar.BTMT_BOOL2
BTMT_BOOL8 = cvar.BTMT_BOOL8
BTMT_BOOL4 = cvar.BTMT_BOOL4
BT_FLOAT = cvar.BT_FLOAT
BTMT_FLOAT = cvar.BTMT_FLOAT
BTMT_DOUBLE = cvar.BTMT_DOUBLE
BTMT_LNGDBL = cvar.BTMT_LNGDBL
BTMT_SPECFLT = cvar.BTMT_SPECFLT
_BT_LAST_BASIC = cvar._BT_LAST_BASIC
BT_PTR = cvar.BT_PTR
BTMT_DEFPTR = cvar.BTMT_DEFPTR
BTMT_NEAR = cvar.BTMT_NEAR
BTMT_FAR = cvar.BTMT_FAR
BTMT_CLOSURE = cvar.BTMT_CLOSURE
BT_ARRAY = cvar.BT_ARRAY
BTMT_NONBASED = cvar.BTMT_NONBASED
BTMT_ARRESERV = cvar.BTMT_ARRESERV
BT_FUNC = cvar.BT_FUNC
BTMT_DEFCALL = cvar.BTMT_DEFCALL
BTMT_NEARCALL = cvar.BTMT_NEARCALL
BTMT_FARCALL = cvar.BTMT_FARCALL
BTMT_INTCALL = cvar.BTMT_INTCALL
BT_COMPLEX = cvar.BT_COMPLEX
BTMT_STRUCT = cvar.BTMT_STRUCT
BTMT_UNION = cvar.BTMT_UNION
BTMT_ENUM = cvar.BTMT_ENUM
BTMT_TYPEDEF = cvar.BTMT_TYPEDEF
BT_BITFIELD = cvar.BT_BITFIELD
BTMT_BFLDI8 = cvar.BTMT_BFLDI8
BTMT_BFLDI16 = cvar.BTMT_BFLDI16
BTMT_BFLDI32 = cvar.BTMT_BFLDI32
BTMT_BFLDI64 = cvar.BTMT_BFLDI64
BT_RESERVED = cvar.BT_RESERVED
BTM_CONST = cvar.BTM_CONST
BTM_VOLATILE = cvar.BTM_VOLATILE
BTE_SIZE_MASK = cvar.BTE_SIZE_MASK
BTE_RESERVED = cvar.BTE_RESERVED
BTE_BITFIELD = cvar.BTE_BITFIELD
BTE_OUT_MASK = cvar.BTE_OUT_MASK
BTE_HEX = cvar.BTE_HEX
BTE_CHAR = cvar.BTE_CHAR
BTE_SDEC = cvar.BTE_SDEC
BTE_UDEC = cvar.BTE_UDEC
BTE_ALWAYS = cvar.BTE_ALWAYS
BT_SEGREG = cvar.BT_SEGREG
BT_UNK_BYTE = cvar.BT_UNK_BYTE
BT_UNK_WORD = cvar.BT_UNK_WORD
BT_UNK_DWORD = cvar.BT_UNK_DWORD
BT_UNK_QWORD = cvar.BT_UNK_QWORD
BT_UNK_OWORD = cvar.BT_UNK_OWORD
BT_UNKNOWN = cvar.BT_UNKNOWN
BTF_BYTE = cvar.BTF_BYTE
BTF_UNK = cvar.BTF_UNK
BTF_VOID = cvar.BTF_VOID
BTF_INT8 = cvar.BTF_INT8
BTF_CHAR = cvar.BTF_CHAR
BTF_UCHAR = cvar.BTF_UCHAR
BTF_UINT8 = cvar.BTF_UINT8
BTF_INT16 = cvar.BTF_INT16
BTF_UINT16 = cvar.BTF_UINT16
BTF_INT32 = cvar.BTF_INT32
BTF_UINT32 = cvar.BTF_UINT32
BTF_INT64 = cvar.BTF_INT64
BTF_UINT64 = cvar.BTF_UINT64
BTF_INT128 = cvar.BTF_INT128
BTF_UINT128 = cvar.BTF_UINT128
BTF_INT = cvar.BTF_INT
BTF_UINT = cvar.BTF_UINT
BTF_SINT = cvar.BTF_SINT
BTF_BOOL = cvar.BTF_BOOL
BTF_FLOAT = cvar.BTF_FLOAT
BTF_DOUBLE = cvar.BTF_DOUBLE
BTF_LDOUBLE = cvar.BTF_LDOUBLE
BTF_TBYTE = cvar.BTF_TBYTE
BTF_STRUCT = cvar.BTF_STRUCT
BTF_UNION = cvar.BTF_UNION
BTF_ENUM = cvar.BTF_ENUM
BTF_TYPEDEF = cvar.BTF_TYPEDEF


def append_argloc(*args):
  """
  append_argloc(out, vloc) -> bool


  Serialize argument location.
  
  
  @param out (C++: qtype  *)
  @param vloc (C++: const  argloc_t  &)
  """
  return _ida_typeinf.append_argloc(*args)

def extract_argloc(*args):
  """
  extract_argloc(vloc, ptype, is_retval) -> bool


  Deserialize argument location.
  
  
  @param vloc (C++: argloc_t  *)
  @param ptype (C++: const  type_t  **)
  @param is_retval (C++: bool)
  """
  return _ida_typeinf.extract_argloc(*args)

def resolve_typedef(*args):
  """
  resolve_typedef(til, type) -> type_t const *
  """
  return _ida_typeinf.resolve_typedef(*args)

def is_restype_void(*args):
  """
  is_restype_void(til, type) -> bool
  """
  return _ida_typeinf.is_restype_void(*args)

def is_restype_enum(*args):
  """
  is_restype_enum(til, type) -> bool
  """
  return _ida_typeinf.is_restype_enum(*args)

def is_restype_struni(*args):
  """
  is_restype_struni(til, type) -> bool
  """
  return _ida_typeinf.is_restype_struni(*args)

def is_restype_struct(*args):
  """
  is_restype_struct(til, type) -> bool
  """
  return _ida_typeinf.is_restype_struct(*args)

def get_scalar_bt(*args):
  """
  get_scalar_bt(size) -> type_t
  """
  return _ida_typeinf.get_scalar_bt(*args)
class til_t(object):
    """
    Proxy of C++ til_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_typeinf.til_t_name_get, _ida_typeinf.til_t_name_set)
    desc = _swig_property(_ida_typeinf.til_t_desc_get, _ida_typeinf.til_t_desc_set)
    nbases = _swig_property(_ida_typeinf.til_t_nbases_get, _ida_typeinf.til_t_nbases_set)
    flags = _swig_property(_ida_typeinf.til_t_flags_get, _ida_typeinf.til_t_flags_set)
    def is_dirty(self, *args):
        """
        is_dirty(self) -> bool
        """
        return _ida_typeinf.til_t_is_dirty(self, *args)

    def set_dirty(self, *args):
        """
        set_dirty(self)
        """
        return _ida_typeinf.til_t_set_dirty(self, *args)

    cc = _swig_property(_ida_typeinf.til_t_cc_get, _ida_typeinf.til_t_cc_set)
    nrefs = _swig_property(_ida_typeinf.til_t_nrefs_get, _ida_typeinf.til_t_nrefs_set)
    nstreams = _swig_property(_ida_typeinf.til_t_nstreams_get, _ida_typeinf.til_t_nstreams_set)
    streams = _swig_property(_ida_typeinf.til_t_streams_get, _ida_typeinf.til_t_streams_set)
    def __init__(self, *args):
        """
        __init__(self) -> til_t
        """
        this = _ida_typeinf.new_til_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def base(self, *args):
        """
        base(self, n) -> til_t
        """
        return _ida_typeinf.til_t_base(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_til_t
    __del__ = lambda self : None;
til_t_swigregister = _ida_typeinf.til_t_swigregister
til_t_swigregister(til_t)
no_sign = cvar.no_sign
type_signed = cvar.type_signed
type_unsigned = cvar.type_unsigned
TIL_ZIP = _ida_typeinf.TIL_ZIP
"""
pack buckets using zip
"""
TIL_MAC = _ida_typeinf.TIL_MAC
"""
til has macro table
"""
TIL_ESI = _ida_typeinf.TIL_ESI
"""
extended sizeof info (short, long, longlong)
"""
TIL_UNI = _ida_typeinf.TIL_UNI
"""
universal til for any compiler
"""
TIL_ORD = _ida_typeinf.TIL_ORD
"""
type ordinal numbers are present
"""
TIL_ALI = _ida_typeinf.TIL_ALI
"""
type aliases are present (this bit is used only on the disk)
"""
TIL_MOD = _ida_typeinf.TIL_MOD
"""
til has been modified, should be saved
"""
TIL_STM = _ida_typeinf.TIL_STM
"""
til has extra streams
"""
TIL_SLD = _ida_typeinf.TIL_SLD
"""
sizeof(long double)
"""


def new_til(*args):
  """
  new_til(name, desc) -> til_t


  Initialize a til.
  
  
  @param name (C++: const char *)
  @param desc (C++: const char *)
  """
  return _ida_typeinf.new_til(*args)
TIL_ADD_FAILED = _ida_typeinf.TIL_ADD_FAILED
"""
see errbuf
"""
TIL_ADD_OK = _ida_typeinf.TIL_ADD_OK
"""
some tils were added
"""
TIL_ADD_ALREADY = _ida_typeinf.TIL_ADD_ALREADY
"""
the base til was already added
"""

def compact_til(*args):
  """
  compact_til(ti) -> bool


  Collect garbage in til. Must be called before storing the til.
  
  @param ti (C++: til_t  *)
  @return: true if any memory was freed
  """
  return _ida_typeinf.compact_til(*args)

def store_til(*args):
  """
  store_til(ti, tildir, name) -> bool


  Store til to a file. If the til contains garbage, it will be collected
  before storing the til. Your plugin should call 'compact_til()' before
  calling 'store_til()' .
  
  @param ti: type library to store (C++: til_t  *)
  @param tildir: directory where to store the til. NULL means current
                 directory. (C++: const char *)
  @param name: filename of the til. If it's an absolute path, tildir is
               ignored.   NB: the file extension is forced to .til (C++:
               const char *)
  @return: success
  """
  return _ida_typeinf.store_til(*args)

def free_til(*args):
  """
  free_til(ti)


  Free memory allocated by til.
  
  
  @param ti (C++: til_t  *)
  """
  return _ida_typeinf.free_til(*args)

def is_code_far(*args):
  """
  is_code_far(cm) -> bool


  Does the given model specify far code?.
  
  
  @param cm (C++: cm_t)
  """
  return _ida_typeinf.is_code_far(*args)

def is_data_far(*args):
  """
  is_data_far(cm) -> bool


  Does the given model specify far data?.
  
  
  @param cm (C++: cm_t)
  """
  return _ida_typeinf.is_data_far(*args)
class rrel_t(object):
    """
    Proxy of C++ rrel_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    off = _swig_property(_ida_typeinf.rrel_t_off_get, _ida_typeinf.rrel_t_off_set)
    reg = _swig_property(_ida_typeinf.rrel_t_reg_get, _ida_typeinf.rrel_t_reg_set)
    def __init__(self, *args):
        """
        __init__(self) -> rrel_t
        """
        this = _ida_typeinf.new_rrel_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_rrel_t
    __del__ = lambda self : None;
rrel_t_swigregister = _ida_typeinf.rrel_t_swigregister
rrel_t_swigregister(rrel_t)
CM_MASK = cvar.CM_MASK
CM_UNKNOWN = cvar.CM_UNKNOWN
CM_N8_F16 = cvar.CM_N8_F16
CM_N64 = cvar.CM_N64
CM_N16_F32 = cvar.CM_N16_F32
CM_N32_F48 = cvar.CM_N32_F48
CM_M_MASK = cvar.CM_M_MASK
CM_M_NN = cvar.CM_M_NN
CM_M_FF = cvar.CM_M_FF
CM_M_NF = cvar.CM_M_NF
CM_M_FN = cvar.CM_M_FN
CM_CC_MASK = cvar.CM_CC_MASK
CM_CC_INVALID = cvar.CM_CC_INVALID
CM_CC_UNKNOWN = cvar.CM_CC_UNKNOWN
CM_CC_VOIDARG = cvar.CM_CC_VOIDARG
CM_CC_CDECL = cvar.CM_CC_CDECL
CM_CC_ELLIPSIS = cvar.CM_CC_ELLIPSIS
CM_CC_STDCALL = cvar.CM_CC_STDCALL
CM_CC_PASCAL = cvar.CM_CC_PASCAL
CM_CC_FASTCALL = cvar.CM_CC_FASTCALL
CM_CC_THISCALL = cvar.CM_CC_THISCALL
CM_CC_MANUAL = cvar.CM_CC_MANUAL
CM_CC_SPOILED = cvar.CM_CC_SPOILED
CM_CC_RESERVE4 = cvar.CM_CC_RESERVE4
CM_CC_RESERVE3 = cvar.CM_CC_RESERVE3
CM_CC_SPECIALE = cvar.CM_CC_SPECIALE
CM_CC_SPECIALP = cvar.CM_CC_SPECIALP
CM_CC_SPECIAL = cvar.CM_CC_SPECIAL
BFA_NORET = cvar.BFA_NORET
BFA_PURE = cvar.BFA_PURE
BFA_HIGH = cvar.BFA_HIGH
BFA_STATIC = cvar.BFA_STATIC
BFA_VIRTUAL = cvar.BFA_VIRTUAL
BFA_FUNC_EXT_FORMAT = cvar.BFA_FUNC_EXT_FORMAT
ALOC_NONE = cvar.ALOC_NONE
ALOC_STACK = cvar.ALOC_STACK
ALOC_DIST = cvar.ALOC_DIST
ALOC_REG1 = cvar.ALOC_REG1
ALOC_REG2 = cvar.ALOC_REG2
ALOC_RREL = cvar.ALOC_RREL
ALOC_STATIC = cvar.ALOC_STATIC
ALOC_CUSTOM = cvar.ALOC_CUSTOM

class argloc_t(object):
    """
    Proxy of C++ argloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> argloc_t
        __init__(self, r) -> argloc_t
        """
        this = _ida_typeinf.new_argloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_argloc_t
    __del__ = lambda self : None;
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.argloc_t_swap(self, *args)

    def atype(self, *args):
        """
        atype(self) -> argloc_type_t
        """
        return _ida_typeinf.argloc_t_atype(self, *args)

    def is_reg1(self, *args):
        """
        is_reg1(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_reg1(self, *args)

    def is_reg2(self, *args):
        """
        is_reg2(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_reg2(self, *args)

    def is_reg(self, *args):
        """
        is_reg(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_reg(self, *args)

    def is_rrel(self, *args):
        """
        is_rrel(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_rrel(self, *args)

    def is_ea(self, *args):
        """
        is_ea(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_ea(self, *args)

    def is_stkoff(self, *args):
        """
        is_stkoff(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_stkoff(self, *args)

    def is_scattered(self, *args):
        """
        is_scattered(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_scattered(self, *args)

    def has_reg(self, *args):
        """
        has_reg(self) -> bool
        """
        return _ida_typeinf.argloc_t_has_reg(self, *args)

    def has_stkoff(self, *args):
        """
        has_stkoff(self) -> bool
        """
        return _ida_typeinf.argloc_t_has_stkoff(self, *args)

    def is_mixed_scattered(self, *args):
        """
        is_mixed_scattered(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_mixed_scattered(self, *args)

    def is_fragmented(self, *args):
        """
        is_fragmented(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_fragmented(self, *args)

    def is_custom(self, *args):
        """
        is_custom(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_custom(self, *args)

    def is_badloc(self, *args):
        """
        is_badloc(self) -> bool
        """
        return _ida_typeinf.argloc_t_is_badloc(self, *args)

    def reg1(self, *args):
        """
        reg1(self) -> int
        """
        return _ida_typeinf.argloc_t_reg1(self, *args)

    def regoff(self, *args):
        """
        regoff(self) -> int
        """
        return _ida_typeinf.argloc_t_regoff(self, *args)

    def reg2(self, *args):
        """
        reg2(self) -> int
        """
        return _ida_typeinf.argloc_t_reg2(self, *args)

    def get_reginfo(self, *args):
        """
        get_reginfo(self) -> uint32
        """
        return _ida_typeinf.argloc_t_get_reginfo(self, *args)

    def stkoff(self, *args):
        """
        stkoff(self) -> sval_t
        """
        return _ida_typeinf.argloc_t_stkoff(self, *args)

    def get_ea(self, *args):
        """
        get_ea(self) -> ea_t
        """
        return _ida_typeinf.argloc_t_get_ea(self, *args)

    def scattered(self, *args):
        """
        scattered(self) -> scattered_aloc_t
        scattered(self) -> scattered_aloc_t
        """
        return _ida_typeinf.argloc_t_scattered(self, *args)

    def get_rrel(self, *args):
        """
        get_rrel(self) -> rrel_t
        get_rrel(self) -> rrel_t
        """
        return _ida_typeinf.argloc_t_get_rrel(self, *args)

    def get_custom(self, *args):
        """
        get_custom(self) -> void *
        """
        return _ida_typeinf.argloc_t_get_custom(self, *args)

    def get_biggest(self, *args):
        """
        get_biggest(self) -> argloc_t::biggest_t
        """
        return _ida_typeinf.argloc_t_get_biggest(self, *args)

    def _set_badloc(self, *args):
        """
        _set_badloc(self)
        """
        return _ida_typeinf.argloc_t__set_badloc(self, *args)

    def _set_reg1(self, *args):
        """
        _set_reg1(self, reg, off=0)
        """
        return _ida_typeinf.argloc_t__set_reg1(self, *args)

    def _set_reg2(self, *args):
        """
        _set_reg2(self, _reg1, _reg2)
        """
        return _ida_typeinf.argloc_t__set_reg2(self, *args)

    def _set_stkoff(self, *args):
        """
        _set_stkoff(self, off)
        """
        return _ida_typeinf.argloc_t__set_stkoff(self, *args)

    def _set_ea(self, *args):
        """
        _set_ea(self, _ea)
        """
        return _ida_typeinf.argloc_t__set_ea(self, *args)

    def _consume_rrel(self, *args):
        """
        _consume_rrel(self, p) -> bool
        """
        return _ida_typeinf.argloc_t__consume_rrel(self, *args)

    def _consume_scattered(self, *args):
        """
        _consume_scattered(self, p) -> bool
        """
        return _ida_typeinf.argloc_t__consume_scattered(self, *args)

    def _set_custom(self, *args):
        """
        _set_custom(self, ct, pdata)
        """
        return _ida_typeinf.argloc_t__set_custom(self, *args)

    def _set_biggest(self, *args):
        """
        _set_biggest(self, ct, data)
        """
        return _ida_typeinf.argloc_t__set_biggest(self, *args)

    def set_reg1(self, *args):
        """
        set_reg1(self, reg, off=0)
        """
        return _ida_typeinf.argloc_t_set_reg1(self, *args)

    def set_reg2(self, *args):
        """
        set_reg2(self, _reg1, _reg2)
        """
        return _ida_typeinf.argloc_t_set_reg2(self, *args)

    def set_stkoff(self, *args):
        """
        set_stkoff(self, off)
        """
        return _ida_typeinf.argloc_t_set_stkoff(self, *args)

    def set_ea(self, *args):
        """
        set_ea(self, _ea)
        """
        return _ida_typeinf.argloc_t_set_ea(self, *args)

    def consume_rrel(self, *args):
        """
        consume_rrel(self, p)
        """
        return _ida_typeinf.argloc_t_consume_rrel(self, *args)

    def consume_scattered(self, *args):
        """
        consume_scattered(self, p)
        """
        return _ida_typeinf.argloc_t_consume_scattered(self, *args)

    def set_badloc(self, *args):
        """
        set_badloc(self)
        """
        return _ida_typeinf.argloc_t_set_badloc(self, *args)

    def calc_offset(self, *args):
        """
        calc_offset(self) -> sval_t
        """
        return _ida_typeinf.argloc_t_calc_offset(self, *args)

    def advance(self, *args):
        """
        advance(self, delta) -> bool
        """
        return _ida_typeinf.argloc_t_advance(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_typeinf.argloc_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_typeinf.argloc_t_compare(self, *args)

argloc_t_swigregister = _ida_typeinf.argloc_t_swigregister
argloc_t_swigregister(argloc_t)

class argpart_t(argloc_t):
    """
    Proxy of C++ argpart_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    off = _swig_property(_ida_typeinf.argpart_t_off_get, _ida_typeinf.argpart_t_off_set)
    size = _swig_property(_ida_typeinf.argpart_t_size_get, _ida_typeinf.argpart_t_size_set)
    def __init__(self, *args):
        """
        __init__(self, a) -> argpart_t
        __init__(self) -> argpart_t
        """
        this = _ida_typeinf.new_argpart_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def bad_offset(self, *args):
        """
        bad_offset(self) -> bool
        """
        return _ida_typeinf.argpart_t_bad_offset(self, *args)

    def bad_size(self, *args):
        """
        bad_size(self) -> bool
        """
        return _ida_typeinf.argpart_t_bad_size(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.argpart_t___lt__(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.argpart_t_swap(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_argpart_t
    __del__ = lambda self : None;
argpart_t_swigregister = _ida_typeinf.argpart_t_swigregister
argpart_t_swigregister(argpart_t)

class scattered_aloc_t(argpartvec_t):
    """
    Proxy of C++ scattered_aloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> scattered_aloc_t
        """
        this = _ida_typeinf.new_scattered_aloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_scattered_aloc_t
    __del__ = lambda self : None;
scattered_aloc_t_swigregister = _ida_typeinf.scattered_aloc_t_swigregister
scattered_aloc_t_swigregister(scattered_aloc_t)


def verify_argloc(*args):
  """
  verify_argloc(vloc, size, gaps) -> int


  Verify 'argloc_t' .
  
  @param vloc (C++: const  argloc_t  &)
  @param size: total size of the variable (C++: int)
  @param gaps: if not NULL, specifies gaps in structure definition.
               these gaps should not map to any argloc, but everything
               else must be covered (C++: const  rangeset_t  *)
  @return: 0 if ok, otherwise an interr code.
  """
  return _ida_typeinf.verify_argloc(*args)

def optimize_argloc(*args):
  """
  optimize_argloc(vloc, size, gaps) -> bool


  Verify and optimize scattered argloc into simple form. All new arglocs
  must be processed by this function.
  
  @param vloc (C++: argloc_t  *)
  @param size (C++: int)
  @param gaps (C++: const  rangeset_t  *)
  """
  return _ida_typeinf.optimize_argloc(*args)

def print_argloc(*args):
  """
  print_argloc(vloc, size=0, vflags=0) -> size_t


  Convert an argloc to human readable form.
  
  
  @param vloc (C++: const  argloc_t  &)
  @param size (C++: int)
  @param vflags (C++: int)
  """
  return _ida_typeinf.print_argloc(*args)
PRALOC_VERIFY = _ida_typeinf.PRALOC_VERIFY
"""
interr if illegal argloc
"""
PRALOC_STKOFF = _ida_typeinf.PRALOC_STKOFF
"""
print stack offsets
"""
class aloc_visitor_t(object):
    """
    Proxy of C++ aloc_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def visit_location(self, *args):
        """
        visit_location(self, v, off, size) -> int
        """
        return _ida_typeinf.aloc_visitor_t_visit_location(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> aloc_visitor_t
        """
        if self.__class__ == aloc_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_typeinf.new_aloc_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_aloc_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_aloc_visitor_t(self)
        return weakref_proxy(self)
aloc_visitor_t_swigregister = _ida_typeinf.aloc_visitor_t_swigregister
aloc_visitor_t_swigregister(aloc_visitor_t)


def for_all_arglocs(*args):
  """
  for_all_arglocs(vv, vloc, size, off=0) -> int


  Compress larger argloc types and initiate the aloc visitor.
  
  
  @param vv (C++: aloc_visitor_t  &)
  @param vloc (C++: argloc_t  &)
  @param size (C++: int)
  @param off (C++: int)
  """
  return _ida_typeinf.for_all_arglocs(*args)
class const_aloc_visitor_t(object):
    """
    Proxy of C++ const_aloc_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def visit_location(self, *args):
        """
        visit_location(self, v, off, size) -> int
        """
        return _ida_typeinf.const_aloc_visitor_t_visit_location(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> const_aloc_visitor_t
        """
        if self.__class__ == const_aloc_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_typeinf.new_const_aloc_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_const_aloc_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_const_aloc_visitor_t(self)
        return weakref_proxy(self)
const_aloc_visitor_t_swigregister = _ida_typeinf.const_aloc_visitor_t_swigregister
const_aloc_visitor_t_swigregister(const_aloc_visitor_t)


def for_all_const_arglocs(*args):
  """
  for_all_const_arglocs(vv, vloc, size, off=0) -> int


  See 'for_all_arglocs()'
  
  
  @param vv (C++: const_aloc_visitor_t  &)
  @param vloc (C++: const  argloc_t  &)
  @param size (C++: int)
  @param off (C++: int)
  """
  return _ida_typeinf.for_all_const_arglocs(*args)

def is_user_cc(*args):
  """
  is_user_cc(cm) -> bool


  Does the calling convention specify argument locations explicitly?
  
  
  @param cm (C++: cm_t)
  """
  return _ida_typeinf.is_user_cc(*args)

def is_vararg_cc(*args):
  """
  is_vararg_cc(cm) -> bool


  Does the calling convention use ellipsis?
  
  
  @param cm (C++: cm_t)
  """
  return _ida_typeinf.is_vararg_cc(*args)

def is_purging_cc(*args):
  """
  is_purging_cc(cm) -> bool


  Does the calling convention clean the stack arguments upon
  return?.this function is valid only for x86 code
  
  @param cm (C++: cm_t)
  """
  return _ida_typeinf.is_purging_cc(*args)
ARGREGS_POLICY_UNDEFINED = _ida_typeinf.ARGREGS_POLICY_UNDEFINED
ARGREGS_GP_ONLY = _ida_typeinf.ARGREGS_GP_ONLY
ARGREGS_INDEPENDENT = _ida_typeinf.ARGREGS_INDEPENDENT
ARGREGS_BY_SLOTS = _ida_typeinf.ARGREGS_BY_SLOTS
ARGREGS_FP_CONSUME_GP = _ida_typeinf.ARGREGS_FP_CONSUME_GP
class callregs_t(object):
    """
    Proxy of C++ callregs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    policy = _swig_property(_ida_typeinf.callregs_t_policy_get, _ida_typeinf.callregs_t_policy_set)
    nregs = _swig_property(_ida_typeinf.callregs_t_nregs_get, _ida_typeinf.callregs_t_nregs_set)
    gpregs = _swig_property(_ida_typeinf.callregs_t_gpregs_get, _ida_typeinf.callregs_t_gpregs_set)
    fpregs = _swig_property(_ida_typeinf.callregs_t_fpregs_get, _ida_typeinf.callregs_t_fpregs_set)
    def __init__(self, *args):
        """
        __init__(self) -> callregs_t
        __init__(self, cc) -> callregs_t
        """
        this = _ida_typeinf.new_callregs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def init_regs(self, *args):
        """
        init_regs(self, cc)
        """
        return _ida_typeinf.callregs_t_init_regs(self, *args)

    def set(self, *args):
        """
        set(self, _policy, gprs, fprs)
        """
        return _ida_typeinf.callregs_t_set(self, *args)

    def reset(self, *args):
        """
        reset(self)
        """
        return _ida_typeinf.callregs_t_reset(self, *args)

    def regcount(*args):
        """
        regcount(cc) -> int
        """
        return _ida_typeinf.callregs_t_regcount(*args)

    regcount = staticmethod(regcount)
    def reginds(self, *args):
        """
        reginds(self, gp_ind, fp_ind, r) -> bool
        """
        return _ida_typeinf.callregs_t_reginds(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_callregs_t
    __del__ = lambda self : None;
callregs_t_swigregister = _ida_typeinf.callregs_t_swigregister
callregs_t_swigregister(callregs_t)
C_PC_TINY = cvar.C_PC_TINY
C_PC_SMALL = cvar.C_PC_SMALL
C_PC_COMPACT = cvar.C_PC_COMPACT
C_PC_MEDIUM = cvar.C_PC_MEDIUM
C_PC_LARGE = cvar.C_PC_LARGE
C_PC_HUGE = cvar.C_PC_HUGE
C_PC_FLAT = cvar.C_PC_FLAT

def callregs_t_regcount(*args):
  """
  callregs_t_regcount(cc) -> int
  """
  return _ida_typeinf.callregs_t_regcount(*args)


def get_comp(*args):
  """
  get_comp(comp) -> comp_t


  Get compiler bits.
  
  
  @param comp (C++: comp_t)
  """
  return _ida_typeinf.get_comp(*args)

def get_compiler_name(*args):
  """
  get_compiler_name(id) -> char const *


  Get full compiler name.
  
  
  @param id (C++: comp_t)
  """
  return _ida_typeinf.get_compiler_name(*args)

def get_compiler_abbr(*args):
  """
  get_compiler_abbr(id) -> char const *


  Get abbreviated compiler name.
  
  
  @param id (C++: comp_t)
  """
  return _ida_typeinf.get_compiler_abbr(*args)

def get_compilers(*args):
  """
  get_compilers(ids, names, abbrs)


  Get names of all built-in compilers.
  
  
  @param ids (C++: compvec_t  *)
  @param names (C++: qstrvec_t  *)
  @param abbrs (C++: qstrvec_t  *)
  """
  return _ida_typeinf.get_compilers(*args)

def is_comp_unsure(*args):
  """
  is_comp_unsure(comp) -> comp_t


  See 'COMP_UNSURE' .
  
  
  @param comp (C++: comp_t)
  """
  return _ida_typeinf.is_comp_unsure(*args)

def default_compiler(*args):
  """
  default_compiler() -> comp_t


  Get compiler specified by \varmem{inf,idainfo,cc}.
  """
  return _ida_typeinf.default_compiler(*args)

def is_gcc(*args):
  """
  is_gcc() -> bool


  Is the target compiler 'COMP_GNU' ?
  """
  return _ida_typeinf.is_gcc(*args)

def is_gcc32(*args):
  """
  is_gcc32() -> bool


  Is the target compiler 32 bit gcc?
  """
  return _ida_typeinf.is_gcc32(*args)

def is_gcc64(*args):
  """
  is_gcc64() -> bool


  Is the target compiler 64 bit gcc?
  """
  return _ida_typeinf.is_gcc64(*args)

def gcc_layout(*args):
  """
  gcc_layout() -> bool


  Should use the struct/union layout as done by gcc?
  """
  return _ida_typeinf.gcc_layout(*args)

def set_compiler(*args):
  """
  set_compiler(cc, flags, abiname=None) -> bool


  Change current compiler.
  
  @param cc: compiler to switch to (C++: const  compiler_info_t  &)
  @param flags: Set compiler flags (C++: int)
  @param abiname: ABI name (C++: const char *)
  @return: success
  """
  return _ida_typeinf.set_compiler(*args)
SETCOMP_OVERRIDE = _ida_typeinf.SETCOMP_OVERRIDE
"""
may override old compiler info
"""
SETCOMP_ONLY_ID = _ida_typeinf.SETCOMP_ONLY_ID
"""
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness
"""
SETCOMP_ONLY_ABI = _ida_typeinf.SETCOMP_ONLY_ABI
"""
ignore cc field complete, use only abiname
"""
SETCOMP_BY_USER = _ida_typeinf.SETCOMP_BY_USER
"""
invoked by user, cannot be replaced by module/loader
"""

def set_compiler_id(*args):
  """
  set_compiler_id(id, abiname=None) -> bool


  Set the compiler id (see 'Compiler IDs' )
  
  
  @param id (C++: comp_t)
  @param abiname (C++: const char *)
  """
  return _ida_typeinf.set_compiler_id(*args)

def set_abi_name(*args):
  """
  set_abi_name(abiname, user_level=False) -> bool


  Set abi name (see 'Compiler IDs' )
  
  
  @param abiname (C++: const char *)
  @param user_level (C++: bool)
  """
  return _ida_typeinf.set_abi_name(*args)

def get_abi_name(*args):
  """
  get_abi_name() -> ssize_t


  Get ABI name.
  
  @return: length of the name (>=0)
  """
  return _ida_typeinf.get_abi_name(*args)

def append_abi_opts(*args):
  """
  append_abi_opts(abi_opts, user_level=False) -> bool


  Add/remove/check ABI option General form of full abi name: abiname-
  opt1-opt2-... or -opt1-opt2-...
  
  @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
                   (C++: const char *)
  @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
                     (C++: bool)
  @return: success
  """
  return _ida_typeinf.append_abi_opts(*args)

def remove_abi_opts(*args):
  """
  remove_abi_opts(abi_opts, user_level=False) -> bool
  """
  return _ida_typeinf.remove_abi_opts(*args)

def set_compiler_string(*args):
  """
  set_compiler_string(compstr, user_level) -> bool
  """
  return _ida_typeinf.set_compiler_string(*args)
MAX_FUNC_ARGS = _ida_typeinf.MAX_FUNC_ARGS
"""
max number of function arguments
"""
abs_unk = _ida_typeinf.abs_unk
abs_no = _ida_typeinf.abs_no
abs_yes = _ida_typeinf.abs_yes
sc_unk = _ida_typeinf.sc_unk
sc_type = _ida_typeinf.sc_type
sc_ext = _ida_typeinf.sc_ext
sc_stat = _ida_typeinf.sc_stat
sc_reg = _ida_typeinf.sc_reg
sc_auto = _ida_typeinf.sc_auto
sc_friend = _ida_typeinf.sc_friend
sc_virt = _ida_typeinf.sc_virt
HTI_CPP = _ida_typeinf.HTI_CPP
"""
C++ mode (not implemented)
"""
HTI_INT = _ida_typeinf.HTI_INT
"""
debug: print internal representation of types
"""
HTI_EXT = _ida_typeinf.HTI_EXT
"""
debug: print external representation of types
"""
HTI_LEX = _ida_typeinf.HTI_LEX
"""
debug: print tokens
"""
HTI_UNP = _ida_typeinf.HTI_UNP
"""
debug: check the result by unpacking it
"""
HTI_TST = _ida_typeinf.HTI_TST
"""
test mode: discard the result
"""
HTI_FIL = _ida_typeinf.HTI_FIL
"""
otherwise "input" contains a C declaration

"input" is file name,
"""
HTI_MAC = _ida_typeinf.HTI_MAC
"""
define macros from the base tils
"""
HTI_NWR = _ida_typeinf.HTI_NWR
"""
no warning messages
"""
HTI_NER = _ida_typeinf.HTI_NER
"""
ignore all errors but display them
"""
HTI_DCL = _ida_typeinf.HTI_DCL
"""
don't complain about redeclarations
"""
HTI_NDC = _ida_typeinf.HTI_NDC
"""
don't decorate names
"""
HTI_PAK = _ida_typeinf.HTI_PAK
"""
explicit structure pack value (#pragma pack)
"""
HTI_PAK_SHIFT = _ida_typeinf.HTI_PAK_SHIFT
"""
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions
"""
HTI_PAKDEF = _ida_typeinf.HTI_PAKDEF
"""
default pack value
"""
HTI_PAK1 = _ida_typeinf.HTI_PAK1
"""
#pragma pack(1)
"""
HTI_PAK2 = _ida_typeinf.HTI_PAK2
"""
#pragma pack(2)
"""
HTI_PAK4 = _ida_typeinf.HTI_PAK4
"""
#pragma pack(4)
"""
HTI_PAK8 = _ida_typeinf.HTI_PAK8
"""
#pragma pack(8)
"""
HTI_PAK16 = _ida_typeinf.HTI_PAK16
"""
#pragma pack(16)
"""
HTI_HIGH = _ida_typeinf.HTI_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""
HTI_LOWER = _ida_typeinf.HTI_LOWER
"""
lower the function prototypes
"""
HTI_RAWARGS = _ida_typeinf.HTI_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

def parse_decl(*args):
  """
  parse_decl(tif, til, decl, flags) -> bool


  Parse ONE declaration. If the input string contains more than one
  declaration, the first complete type declaration ( 'PT_TYP' ) or the
  last variable declaration ( 'PT_VAR' ) will be used.name & tif may be
  empty after the call!
  
  @param tif: type info (C++: tinfo_t  *)
  @param til: type library to use. may be NULL (C++: til_t  *)
  @param decl: C declaration to parse (C++: const char *)
  @param flags: combination of  Type parsing flags  bits (C++: int)
  """
  return _ida_typeinf.parse_decl(*args)
PT_SIL = _ida_typeinf.PT_SIL
"""
silent, no messages
"""
PT_NDC = _ida_typeinf.PT_NDC
"""
don't decorate names
"""
PT_TYP = _ida_typeinf.PT_TYP
"""
return declared type information
"""
PT_VAR = _ida_typeinf.PT_VAR
"""
return declared object information
"""
PT_PACKMASK = _ida_typeinf.PT_PACKMASK
"""
mask for pack alignment values
"""
PT_HIGH = _ida_typeinf.PT_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""
PT_LOWER = _ida_typeinf.PT_LOWER
"""
lower the function prototypes
"""
PT_REPLACE = _ida_typeinf.PT_REPLACE
"""
replace the old type (used in idc)
"""
PT_RAWARGS = _ida_typeinf.PT_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""

def convert_pt_flags_to_hti(*args):
  """
  convert_pt_flags_to_hti(pt_flags) -> int


  Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
  flags lesser than 0x10 don't have stable meaning and will be ignored
  (more on these flags can be seen in idc.idc)
  
  @param pt_flags (C++: int)
  """
  return _ida_typeinf.convert_pt_flags_to_hti(*args)

def parse_decls(*args):
  """
  parse_decls(til, input, printer, hti_flags) -> int


  Parse many declarations and store them in a til. If there are any
  errors, they will be printed using 'printer'. This function uses
  default include path and predefined macros from the database settings.
  It always uses the 'HTI_DCL' bit.
  
  @param til: type library to store the result (C++: til_t  *)
  @param input: input string or file name (see hti_flags) (C++: const
                char *)
  @param printer: function to output error messages (use msg or NULL or
                  your own callback) (C++: printer_t  *)
  @param hti_flags: combination of  Type formatting flags (C++: int)
  @return: number of errors, 0 means ok.
  """
  return _ida_typeinf.parse_decls(*args)

def print_type(*args):
  """
  print_type(ea, prtype_flags) -> bool


  Get type declaration for the specified address.
  
  @param ea: address (C++: ea_t)
  @param prtype_flags: combination of  Type printing flags (C++: int)
  @return: success
  """
  return _ida_typeinf.print_type(*args)
PRTYPE_1LINE = _ida_typeinf.PRTYPE_1LINE
"""
print to one line
"""
PRTYPE_MULTI = _ida_typeinf.PRTYPE_MULTI
"""
print to many lines
"""
PRTYPE_TYPE = _ida_typeinf.PRTYPE_TYPE
"""
print type declaration (not variable declaration)
"""
PRTYPE_PRAGMA = _ida_typeinf.PRTYPE_PRAGMA
"""
print pragmas for alignment
"""
PRTYPE_SEMI = _ida_typeinf.PRTYPE_SEMI
"""
append ; to the end
"""
PRTYPE_CPP = _ida_typeinf.PRTYPE_CPP
"""
use c++ name (only for 'print_type()' )
"""
PRTYPE_DEF = _ida_typeinf.PRTYPE_DEF
"""
 'tinfo_t' : print definition, if available
"""
PRTYPE_NOARGS = _ida_typeinf.PRTYPE_NOARGS
"""
 'tinfo_t' : do not print function argument names
"""
PRTYPE_NOARRS = _ida_typeinf.PRTYPE_NOARRS
"""
 'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers
"""
PRTYPE_NORES = _ida_typeinf.PRTYPE_NORES
"""
 'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)
"""
PRTYPE_RESTORE = _ida_typeinf.PRTYPE_RESTORE
"""
 'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'
"""
NTF_TYPE = _ida_typeinf.NTF_TYPE
"""
type name
"""
NTF_SYMU = _ida_typeinf.NTF_SYMU
"""
symbol, name is unmangled ('func')
"""
NTF_SYMM = _ida_typeinf.NTF_SYMM
"""
only one of 'NTF_TYPE' and 'NTF_SYMU' , 'NTF_SYMM' can be used

symbol, name is mangled ('_func')
"""
NTF_NOBASE = _ida_typeinf.NTF_NOBASE
"""
don't inspect base tils (for get_named_type)
"""
NTF_REPLACE = _ida_typeinf.NTF_REPLACE
"""
replace original type (for set_named_type)
"""
NTF_UMANGLED = _ida_typeinf.NTF_UMANGLED
"""
name is unmangled (don't use this flag)
"""
NTF_NOCUR = _ida_typeinf.NTF_NOCUR
"""
don't inspect current til file (for get_named_type)
"""
NTF_64BIT = _ida_typeinf.NTF_64BIT
"""
value is 64bit
"""
NTF_FIXNAME = _ida_typeinf.NTF_FIXNAME
"""
(set_named_type, set_numbered_type only)

force-validate the name of the type when setting
"""
NTF_IDBENC = _ida_typeinf.NTF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)
"""
NTF_CHKSYNC = _ida_typeinf.NTF_CHKSYNC
"""
(set_numbered_type, set_named_type)

check that synchronization to IDB passed OK
"""
TERR_OK = _ida_typeinf.TERR_OK
TERR_SAVE = _ida_typeinf.TERR_SAVE
TERR_SERIALIZE = _ida_typeinf.TERR_SERIALIZE
TERR_WRONGNAME = _ida_typeinf.TERR_WRONGNAME
TERR_BADSYNC = _ida_typeinf.TERR_BADSYNC

def del_named_type(*args):
  """
  del_named_type(ti, name, ntf_flags) -> bool


  Delete information about a symbol.
  
  @param ti: type library (C++: til_t  *)
  @param name: name of symbol (C++: const char *)
  @param ntf_flags: combination of  Flags for named types (C++: int)
  @return: success
  """
  return _ida_typeinf.del_named_type(*args)

def first_named_type(*args):
  """
  first_named_type(ti, ntf_flags) -> char const *


  Enumerate types. Returns mangled names. Never returns anonymous types.
  To include it, enumerate types by ordinals.
  
  @param ti (C++: const  til_t  *)
  @param ntf_flags (C++: int)
  """
  return _ida_typeinf.first_named_type(*args)

def next_named_type(*args):
  """
  next_named_type(ti, name, ntf_flags) -> char const *


  Enumerate types. Returns mangled names. Never returns anonymous types.
  To include it, enumerate types by ordinals.
  
  @param ti (C++: const  til_t  *)
  @param name (C++: const char *)
  @param ntf_flags (C++: int)
  """
  return _ida_typeinf.next_named_type(*args)

def copy_named_type(*args):
  """
  copy_named_type(dsttil, srctil, name) -> uint32


  Copy a named type from one til to another. This function will copy the
  specified type and all dependent types from the source type library to
  the destination library.
  
  @param dsttil: Destination til. It must have orginal types enabled
                 (C++: til_t  *)
  @param srctil: Source til. (C++: const  til_t  *)
  @param name: name of the type to copy (C++: const char *)
  @return: ordinal number of the copied type. 0 means error
  """
  return _ida_typeinf.copy_named_type(*args)

def gen_decorate_name(*args):
  """
  gen_decorate_name(name, mangle, cc, type) -> bool


  Generic function for 'decorate_name()' (may be used in IDP modules)
  
  
  @param name (C++: const char *)
  @param mangle (C++: bool)
  @param cc (C++: cm_t)
  @param type (C++: const  tinfo_t  *)
  """
  return _ida_typeinf.gen_decorate_name(*args)

def calc_c_cpp_name(*args):
  """
  calc_c_cpp_name(name, type, ccn_flags) -> ssize_t


  Get C or C++ form of the name.
  
  @param name: original (mangled or decorated) name (C++: const char *)
  @param type: name type if known, otherwise NULL (C++: const  tinfo_t
               *)
  @param ccn_flags: one of  C/C++ naming flags (C++: int)
  """
  return _ida_typeinf.calc_c_cpp_name(*args)
CCN_C = _ida_typeinf.CCN_C
CCN_CPP = _ida_typeinf.CCN_CPP

def alloc_type_ordinals(*args):
  """
  alloc_type_ordinals(ti, qty) -> uint32


  Allocate a range of ordinal numbers for new types.
  
  @param ti: type library (C++: til_t  *)
  @param qty: number of ordinals to allocate (C++: int)
  @return: the first ordinal. 0 means failure.
  """
  return _ida_typeinf.alloc_type_ordinals(*args)

def alloc_type_ordinal(*args):
  """
  alloc_type_ordinal(ti) -> uint32


  \call2{alloc_type_ordinals,ti,1}
  
  
  @param ti (C++: til_t  *)
  """
  return _ida_typeinf.alloc_type_ordinal(*args)

def get_ordinal_qty(*args):
  """
  get_ordinal_qty(ti) -> uint32


  Get number of allocated ordinals.
  
  @param ti (C++: const  til_t  *)
  @return: uint32(-1) if failed
  """
  return _ida_typeinf.get_ordinal_qty(*args)

def set_numbered_type(*args):
  """
  set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t


  Store a type in the til. 'name' may be NULL for anonymous types. The
  specified ordinal must be free (no other type is using it). For
  ntf_flags, only 'NTF_REPLACE' is consulted.
  
  @param ti (C++: til_t  *)
  @param ordinal (C++: uint32)
  @param ntf_flags (C++: int)
  @param name (C++: const char *)
  @param type (C++: const  type_t  *)
  @param fields (C++: const  p_list  *)
  @param cmt (C++: const char *)
  @param fldcmts (C++: const  p_list  *)
  @param sclass (C++: const  sclass_t  *)
  """
  return _ida_typeinf.set_numbered_type(*args)

def del_numbered_type(*args):
  """
  del_numbered_type(ti, ordinal) -> bool


  Delete a numbered type.
  
  
  @param ti (C++: til_t  *)
  @param ordinal (C++: uint32)
  """
  return _ida_typeinf.del_numbered_type(*args)

def set_type_alias(*args):
  """
  set_type_alias(ti, src_ordinal, dst_ordinal) -> bool


  Create a type alias. Redirects all references to source type to the
  destination type. This is equivalent to instantaneous replacement all
  reference to srctype by dsttype.
  
  @param ti (C++: til_t  *)
  @param src_ordinal (C++: uint32)
  @param dst_ordinal (C++: uint32)
  """
  return _ida_typeinf.set_type_alias(*args)

def get_alias_target(*args):
  """
  get_alias_target(ti, ordinal) -> uint32


  Find the final alias destination. If the ordinal has not been aliased,
  return the specified ordinal itself If failed, returns 0.
  
  @param ti (C++: const  til_t  *)
  @param ordinal (C++: uint32)
  """
  return _ida_typeinf.get_alias_target(*args)

def get_type_ordinal(*args):
  """
  get_type_ordinal(ti, name) -> int32


  Get type ordinal by its name.
  
  
  @param ti (C++: const  til_t  *)
  @param name (C++: const char *)
  """
  return _ida_typeinf.get_type_ordinal(*args)

def get_numbered_type_name(*args):
  """
  get_numbered_type_name(ti, ordinal) -> char const *


  Get type name (if exists) by its ordinal. If the type is anonymous,
  returns "". If failed, returns NULL
  
  @param ti (C++: const  til_t  *)
  @param ordinal (C++: uint32)
  """
  return _ida_typeinf.get_numbered_type_name(*args)

def create_numbered_type_name(*args):
  """
  create_numbered_type_name(ord) -> ssize_t


  Create anonymous name for numbered type. This name can be used to
  reference a numbered type by its ordinal Ordinal names have the
  following format: '#' + set_de(ord) Returns: -1 if error, otherwise
  the name length
  
  @param ord (C++: int32)
  """
  return _ida_typeinf.create_numbered_type_name(*args)

def is_ordinal_name(*args):
  """
  is_ordinal_name(name, ord=None) -> bool


  Check if the name is an ordinal name. Ordinal names have the following
  format: '#' + set_de(ord)
  
  @param name (C++: const char *)
  @param ord (C++: uint32  *)
  """
  return _ida_typeinf.is_ordinal_name(*args)

def get_ordinal_from_idb_type(*args):
  """
  get_ordinal_from_idb_type(name, type) -> int


  Get ordinal number of an idb type (struct/enum). The 'type' parameter
  is used only to determine the kind of the type (struct or enum) Use
  this function to find out the correspondence between idb types and til
  types
  
  @param name (C++: const char *)
  @param type (C++: const  type_t  *)
  """
  return _ida_typeinf.get_ordinal_from_idb_type(*args)

def is_autosync(*args):
  """
    is_autosync(name, type) -> bool
    is_autosync(name, tif) -> bool


  Is the specified idb type automatically synchronized?
  
  
  @param name (C++: const char *)
  @param type (C++: const  type_t  *)
    """
  return _ida_typeinf.is_autosync(*args)

def deref_ptr(*args):
  """
  deref_ptr(ptr_ea, tif, closure_obj=None) -> bool


  Dereference a pointer.
  
  @param ptr_ea: in/out parameter   in: address of the pointer   out:
                 the pointed address (C++: ea_t *)
  @param tif: type of the pointer (C++: const  tinfo_t  &)
  @param closure_obj: closure object (not used yet) (C++: ea_t *)
  @return: success
  """
  return _ida_typeinf.deref_ptr(*args)

def import_type(*args):
  """
  import_type(til, idx, name, flags=0) -> tid_t


  Copy a named type from til to idb.
  
  @param til: type library (C++: const  til_t  *)
  @param idx: the position of the new type in the list of types
              (structures or enums). -1 means at the end of the list
              (C++: int)
  @param name: the type name (C++: const char *)
  @param flags: combination of  Import type flags (C++: int)
  @return: BADNODE  on error
  """
  return _ida_typeinf.import_type(*args)
IMPTYPE_VERBOSE = _ida_typeinf.IMPTYPE_VERBOSE
"""
more verbose output (dialog boxes may appear)
"""
IMPTYPE_OVERRIDE = _ida_typeinf.IMPTYPE_OVERRIDE
"""
override existing type
"""
IMPTYPE_LOCAL = _ida_typeinf.IMPTYPE_LOCAL
"""
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically
"""

def add_til(*args):
  """
  add_til(name, flags) -> int


  Load a til file.
  
  @param name: til name (C++: const char *)
  @param flags: combination of  Load TIL flags (C++: int)
  @return: one of  Load TIL result codes
  """
  return _ida_typeinf.add_til(*args)
ADDTIL_DEFAULT = _ida_typeinf.ADDTIL_DEFAULT
"""
default behavior
"""
ADDTIL_INCOMP = _ida_typeinf.ADDTIL_INCOMP
"""
load incompatible tils
"""
ADDTIL_SILENT = _ida_typeinf.ADDTIL_SILENT
"""
do not ask any questions
"""
ADDTIL_FAILED = _ida_typeinf.ADDTIL_FAILED
"""
something bad, the warning is displayed
"""
ADDTIL_OK = _ida_typeinf.ADDTIL_OK
"""
ok, til is loaded
"""
ADDTIL_COMP = _ida_typeinf.ADDTIL_COMP
"""
ok, but til is not compatible with the current compiler
"""
ADDTIL_ABORTED = _ida_typeinf.ADDTIL_ABORTED
"""
til was not loaded (incompatible til rejected by user)
"""

def del_til(*args):
  """
  del_til(name) -> bool


  Unload a til file.
  
  
  @param name (C++: const char *)
  """
  return _ida_typeinf.del_til(*args)

def apply_named_type(*args):
  """
  apply_named_type(ea, name) -> bool


  Apply the specified named type to the address.
  
  @param ea: linear address (C++: ea_t)
  @param name: the type name, e.g. "FILE" (C++: const char *)
  @return: success
  """
  return _ida_typeinf.apply_named_type(*args)

def apply_tinfo(*args):
  """
  apply_tinfo(ea, tif, flags) -> bool


  Apply the specified type to the specified address. This function sets
  the type and tries to convert the item at the specified address to
  conform the type.
  
  @param ea: linear address (C++: ea_t)
  @param tif: type string in internal format (C++: const  tinfo_t  &)
  @param flags: combination of  Apply tinfo flags (C++: uint32)
  @return: success
  """
  return _ida_typeinf.apply_tinfo(*args)
TINFO_GUESSED = _ida_typeinf.TINFO_GUESSED
"""
this is a guessed type
"""
TINFO_DEFINITE = _ida_typeinf.TINFO_DEFINITE
"""
this is a definite type
"""
TINFO_DELAYFUNC = _ida_typeinf.TINFO_DELAYFUNC
"""
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately
"""
TINFO_STRICT = _ida_typeinf.TINFO_STRICT
"""
never convert given type to another one before applying
"""

def apply_cdecl(*args):
  """
  apply_cdecl(til, ea, decl, flags=0) -> bool


  Apply the specified type to the address. This function parses the
  declaration and calls 'apply_tinfo()'
  
  @param til: type library (C++: til_t  *)
  @param ea: linear address (C++: ea_t)
  @param decl: type declaration in C form (C++: const char *)
  @param flags: flags to pass to apply_tinfo ( TINFO_DEFINITE  is always
                passed) (C++: int)
  @return: success
  """
  return _ida_typeinf.apply_cdecl(*args)

def apply_callee_tinfo(*args):
  """
  apply_callee_tinfo(caller, tif) -> bool


  Apply the type of the called function to the calling instruction. This
  function will append parameter comments and rename the local variables
  of the calling function. It also stores information about the
  instructions that initialize call arguments in the database. Use
  'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
  possible to hook to processor_t::arg_addrs_ready event.
  
  @param caller: linear address of the calling instruction. must belong
                 to a function. (C++: ea_t)
  @param tif: type info (C++: const  tinfo_t  &)
  @return: success
  """
  return _ida_typeinf.apply_callee_tinfo(*args)

def apply_once_tinfo_and_name(*args):
  """
  apply_once_tinfo_and_name(dea, tif, name) -> bool


  Apply the specified type and name to the address. This function checks
  if the address already has a type. If the old typedoes not exist or
  the new type is 'better' than the old type, then thenew type will be
  applied. A type is considered better if it has moreinformation (e.g.
  'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
  name: if the address already have a meaningfulname, it will be
  preserved. Only if the old name does not exist or itis a dummy name
  like byte_123, it will be replaced by the new name.
  
  @param dea: linear address (C++: ea_t)
  @param tif: type string in the internal format (C++: const  tinfo_t
              &)
  @param name: new name for the address (C++: const char *)
  @return: success
  """
  return _ida_typeinf.apply_once_tinfo_and_name(*args)

def guess_tinfo(*args):
  """
  guess_tinfo(tif, id) -> int


  Generate a type information about the id from the disassembly. id can
  be a structure/union/enum id or an address.
  
  @param tif (C++: tinfo_t  *)
  @param id (C++: tid_t)
  @return: one of  Guess tinfo codes
  """
  return _ida_typeinf.guess_tinfo(*args)
GUESS_FUNC_FAILED = _ida_typeinf.GUESS_FUNC_FAILED
"""
couldn't guess the function type
"""
GUESS_FUNC_TRIVIAL = _ida_typeinf.GUESS_FUNC_TRIVIAL
"""
the function type doesn't have interesting info
"""
GUESS_FUNC_OK = _ida_typeinf.GUESS_FUNC_OK
"""
ok, some non-trivial information is gathered
"""

def set_c_header_path(*args):
  """
  set_c_header_path(incdir)


  Set include directory path the target compiler.
  
  
  @param incdir (C++: const char *)
  """
  return _ida_typeinf.set_c_header_path(*args)

def get_c_header_path(*args):
  """
  get_c_header_path() -> ssize_t


  Get the include directory path of the target compiler.
  """
  return _ida_typeinf.get_c_header_path(*args)

def set_c_macros(*args):
  """
  set_c_macros(macros)


  Set predefined macros for the target compiler.
  
  
  @param macros (C++: const char *)
  """
  return _ida_typeinf.set_c_macros(*args)

def get_c_macros(*args):
  """
  get_c_macros() -> ssize_t


  Get predefined macros for the target compiler.
  """
  return _ida_typeinf.get_c_macros(*args)

def get_idati(*args):
  """
  get_idati() -> til_t


  Pointer to the local type library - this til is private for each IDB
  file Function that accepts til_t* uses local type library instead of
  NULL.
  """
  return _ida_typeinf.get_idati(*args)

def get_idainfo_by_type(*args):
  """
  get_idainfo_by_type(tif) -> bool


  Extract information from a 'tinfo_t' .
  
  @param tif: the type to inspect (C++: const  tinfo_t  &)
  """
  return _ida_typeinf.get_idainfo_by_type(*args)
STI_PCHAR = _ida_typeinf.STI_PCHAR
STI_PUCHAR = _ida_typeinf.STI_PUCHAR
STI_PCCHAR = _ida_typeinf.STI_PCCHAR
STI_PCUCHAR = _ida_typeinf.STI_PCUCHAR
STI_PBYTE = _ida_typeinf.STI_PBYTE
STI_PINT = _ida_typeinf.STI_PINT
STI_PUINT = _ida_typeinf.STI_PUINT
STI_PVOID = _ida_typeinf.STI_PVOID
STI_PPVOID = _ida_typeinf.STI_PPVOID
STI_PCVOID = _ida_typeinf.STI_PCVOID
STI_ACHAR = _ida_typeinf.STI_ACHAR
STI_AUCHAR = _ida_typeinf.STI_AUCHAR
STI_ACCHAR = _ida_typeinf.STI_ACCHAR
STI_ACUCHAR = _ida_typeinf.STI_ACUCHAR
STI_FPURGING = _ida_typeinf.STI_FPURGING
STI_FDELOP = _ida_typeinf.STI_FDELOP
STI_MSGSEND = _ida_typeinf.STI_MSGSEND
STI_AEABI_LCMP = _ida_typeinf.STI_AEABI_LCMP
STI_AEABI_ULCMP = _ida_typeinf.STI_AEABI_ULCMP
STI_DONT_USE = _ida_typeinf.STI_DONT_USE
STI_SIZE_T = _ida_typeinf.STI_SIZE_T
STI_SSIZE_T = _ida_typeinf.STI_SSIZE_T
STI_AEABI_MEMCPY = _ida_typeinf.STI_AEABI_MEMCPY
STI_AEABI_MEMSET = _ida_typeinf.STI_AEABI_MEMSET
STI_AEABI_MEMCLR = _ida_typeinf.STI_AEABI_MEMCLR
STI_RTC_CHECK_2 = _ida_typeinf.STI_RTC_CHECK_2
STI_RTC_CHECK_4 = _ida_typeinf.STI_RTC_CHECK_4
STI_RTC_CHECK_8 = _ida_typeinf.STI_RTC_CHECK_8
STI_LAST = _ida_typeinf.STI_LAST
GTD_CALC_LAYOUT = _ida_typeinf.GTD_CALC_LAYOUT
GTD_NO_LAYOUT = _ida_typeinf.GTD_NO_LAYOUT
GTD_DEL_BITFLDS = _ida_typeinf.GTD_DEL_BITFLDS
GTD_CALC_ARGLOCS = _ida_typeinf.GTD_CALC_ARGLOCS
GTD_NO_ARGLOCS = _ida_typeinf.GTD_NO_ARGLOCS
GTS_NESTED = _ida_typeinf.GTS_NESTED
GTS_BASECLASS = _ida_typeinf.GTS_BASECLASS
SUDT_SORT = _ida_typeinf.SUDT_SORT
"""
fields are not sorted by offset, sort them first
"""
SUDT_ALIGN = _ida_typeinf.SUDT_ALIGN
"""
to match the offsets and size info

recalculate field alignments, struct packing, etc
"""
SUDT_GAPS = _ida_typeinf.SUDT_GAPS
"""
allow to fill gaps with additional members (_BYTE[])
"""
SUDT_UNEX = _ida_typeinf.SUDT_UNEX
"""
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.
"""
SUDT_FAST = _ida_typeinf.SUDT_FAST
"""
serialize without verifying offsets and alignments
"""
SUDT_CONST = _ida_typeinf.SUDT_CONST
"""
only for serialize_udt: make type const
"""
SUDT_VOLATILE = _ida_typeinf.SUDT_VOLATILE
"""
only for serialize_udt: make type volatile
"""
SUDT_TRUNC = _ida_typeinf.SUDT_TRUNC
"""
serialize: truncate useless strings from fields, fldcmts
"""

def copy_tinfo_t(*args):
  """
  copy_tinfo_t(_this, r)
  """
  return _ida_typeinf.copy_tinfo_t(*args)

def clear_tinfo_t(*args):
  """
  clear_tinfo_t(_this)
  """
  return _ida_typeinf.clear_tinfo_t(*args)

def create_tinfo(*args):
  """
  create_tinfo(_this, bt, bt2, ptr) -> bool
  """
  return _ida_typeinf.create_tinfo(*args)

def verify_tinfo(*args):
  """
  verify_tinfo(typid) -> int
  """
  return _ida_typeinf.verify_tinfo(*args)

def get_tinfo_details(*args):
  """
  get_tinfo_details(typid, bt2, buf) -> bool
  """
  return _ida_typeinf.get_tinfo_details(*args)

def get_tinfo_size(*args):
  """
  get_tinfo_size(p_effalign, typid, gts_code) -> size_t
  """
  return _ida_typeinf.get_tinfo_size(*args)

def get_tinfo_pdata(*args):
  """
  get_tinfo_pdata(outptr, typid, what) -> size_t
  """
  return _ida_typeinf.get_tinfo_pdata(*args)

def get_tinfo_property(*args):
  """
  get_tinfo_property(typid, gta_prop) -> size_t
  """
  return _ida_typeinf.get_tinfo_property(*args)

def set_tinfo_property(*args):
  """
  set_tinfo_property(tif, sta_prop, x) -> size_t
  """
  return _ida_typeinf.set_tinfo_property(*args)

def serialize_tinfo(*args):
  """
  serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
  """
  return _ida_typeinf.serialize_tinfo(*args)

def deserialize_tinfo(*args):
  """
  deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool
  """
  return _ida_typeinf.deserialize_tinfo(*args)

def find_tinfo_udt_member(*args):
  """
  find_tinfo_udt_member(udm, typid, strmem_flags) -> int
  """
  return _ida_typeinf.find_tinfo_udt_member(*args)

def print_tinfo(*args):
  """
  print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> bool
  """
  return _ida_typeinf.print_tinfo(*args)

def dstr_tinfo(*args):
  """
  dstr_tinfo(tif) -> char const *
  """
  return _ida_typeinf.dstr_tinfo(*args)

def visit_subtypes(*args):
  """
  visit_subtypes(visitor, out, tif, name, cmt) -> int
  """
  return _ida_typeinf.visit_subtypes(*args)

def compare_tinfo(*args):
  """
  compare_tinfo(t1, t2, tcflags) -> bool
  """
  return _ida_typeinf.compare_tinfo(*args)

def lexcompare_tinfo(*args):
  """
  lexcompare_tinfo(t1, t2, arg3) -> int
  """
  return _ida_typeinf.lexcompare_tinfo(*args)

def get_stock_tinfo(*args):
  """
  get_stock_tinfo(tif, id) -> bool
  """
  return _ida_typeinf.get_stock_tinfo(*args)

def read_tinfo_bitfield_value(*args):
  """
  read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
  """
  return _ida_typeinf.read_tinfo_bitfield_value(*args)

def write_tinfo_bitfield_value(*args):
  """
  write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
  """
  return _ida_typeinf.write_tinfo_bitfield_value(*args)

def get_tinfo_attr(*args):
  """
  get_tinfo_attr(typid, key, bv, all_attrs) -> bool
  """
  return _ida_typeinf.get_tinfo_attr(*args)

def set_tinfo_attr(*args):
  """
  set_tinfo_attr(tif, ta, may_overwrite) -> bool
  """
  return _ida_typeinf.set_tinfo_attr(*args)

def del_tinfo_attr(*args):
  """
  del_tinfo_attr(tif, key, make_copy) -> bool
  """
  return _ida_typeinf.del_tinfo_attr(*args)

def get_tinfo_attrs(*args):
  """
  get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
  """
  return _ida_typeinf.get_tinfo_attrs(*args)

def set_tinfo_attrs(*args):
  """
  set_tinfo_attrs(tif, ta) -> bool
  """
  return _ida_typeinf.set_tinfo_attrs(*args)

def score_tinfo(*args):
  """
  score_tinfo(tif) -> uint32
  """
  return _ida_typeinf.score_tinfo(*args)

def save_tinfo(*args):
  """
  save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
  """
  return _ida_typeinf.save_tinfo(*args)

def append_tinfo_covered(*args):
  """
  append_tinfo_covered(out, typid, offset) -> bool
  """
  return _ida_typeinf.append_tinfo_covered(*args)

def calc_tinfo_gaps(*args):
  """
  calc_tinfo_gaps(out, typid) -> bool
  """
  return _ida_typeinf.calc_tinfo_gaps(*args)
class tinfo_t(object):
    """
    Proxy of C++ tinfo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> tinfo_t
        __init__(self, decl_type) -> tinfo_t
        __init__(self, r) -> tinfo_t
        """
        this = _ida_typeinf.new_tinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.tinfo_t_clear(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.tinfo_t_swap(self, *args)

    def get_named_type(self, *args):
        """
        get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
        """
        return _ida_typeinf.tinfo_t_get_named_type(self, *args)

    def get_numbered_type(self, *args):
        """
        get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
        """
        return _ida_typeinf.tinfo_t_get_numbered_type(self, *args)

    def is_correct(self, *args):
        """
        is_correct(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_correct(self, *args)

    def get_realtype(self, *args):
        """
        get_realtype(self, full=False) -> type_t
        """
        return _ida_typeinf.tinfo_t_get_realtype(self, *args)

    def get_decltype(self, *args):
        """
        get_decltype(self) -> type_t
        """
        return _ida_typeinf.tinfo_t_get_decltype(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_typeinf.tinfo_t_empty(self, *args)

    def present(self, *args):
        """
        present(self) -> bool
        """
        return _ida_typeinf.tinfo_t_present(self, *args)

    def get_size(self, *args):
        """
        get_size(self, p_effalign=None, gts_code=0) -> size_t
        """
        return _ida_typeinf.tinfo_t_get_size(self, *args)

    def get_unpadded_size(self, *args):
        """
        get_unpadded_size(self) -> size_t
        """
        return _ida_typeinf.tinfo_t_get_unpadded_size(self, *args)

    def get_sign(self, *args):
        """
        get_sign(self) -> type_sign_t
        """
        return _ida_typeinf.tinfo_t_get_sign(self, *args)

    def is_signed(self, *args):
        """
        is_signed(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_signed(self, *args)

    def is_unsigned(self, *args):
        """
        is_unsigned(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_unsigned(self, *args)

    def get_declalign(self, *args):
        """
        get_declalign(self) -> uchar
        """
        return _ida_typeinf.tinfo_t_get_declalign(self, *args)

    def set_declalign(self, *args):
        """
        set_declalign(self, declalign) -> bool
        """
        return _ida_typeinf.tinfo_t_set_declalign(self, *args)

    def is_typeref(self, *args):
        """
        is_typeref(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_typeref(self, *args)

    def has_details(self, *args):
        """
        has_details(self) -> bool
        """
        return _ida_typeinf.tinfo_t_has_details(self, *args)

    def get_type_name(self, *args):
        """
        get_type_name(self) -> bool
        """
        return _ida_typeinf.tinfo_t_get_type_name(self, *args)

    def get_final_type_name(self, *args):
        """
        get_final_type_name(self) -> bool
        """
        return _ida_typeinf.tinfo_t_get_final_type_name(self, *args)

    def get_next_type_name(self, *args):
        """
        get_next_type_name(self) -> bool
        """
        return _ida_typeinf.tinfo_t_get_next_type_name(self, *args)

    def get_ordinal(self, *args):
        """
        get_ordinal(self) -> uint32
        """
        return _ida_typeinf.tinfo_t_get_ordinal(self, *args)

    def get_final_ordinal(self, *args):
        """
        get_final_ordinal(self) -> uint32
        """
        return _ida_typeinf.tinfo_t_get_final_ordinal(self, *args)

    def get_til(self, *args):
        """
        get_til(self) -> til_t
        """
        return _ida_typeinf.tinfo_t_get_til(self, *args)

    def is_from_subtil(self, *args):
        """
        is_from_subtil(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_from_subtil(self, *args)

    def is_forward_decl(self, *args):
        """
        is_forward_decl(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_forward_decl(self, *args)

    def is_decl_const(self, *args):
        """
        is_decl_const(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_const(self, *args)

    def is_decl_volatile(self, *args):
        """
        is_decl_volatile(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_volatile(self, *args)

    def is_decl_void(self, *args):
        """
        is_decl_void(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_void(self, *args)

    def is_decl_partial(self, *args):
        """
        is_decl_partial(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_partial(self, *args)

    def is_decl_unknown(self, *args):
        """
        is_decl_unknown(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_unknown(self, *args)

    def is_decl_last(self, *args):
        """
        is_decl_last(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_last(self, *args)

    def is_decl_ptr(self, *args):
        """
        is_decl_ptr(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_ptr(self, *args)

    def is_decl_array(self, *args):
        """
        is_decl_array(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_array(self, *args)

    def is_decl_func(self, *args):
        """
        is_decl_func(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_func(self, *args)

    def is_decl_complex(self, *args):
        """
        is_decl_complex(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_complex(self, *args)

    def is_decl_typedef(self, *args):
        """
        is_decl_typedef(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_typedef(self, *args)

    def is_decl_sue(self, *args):
        """
        is_decl_sue(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_sue(self, *args)

    def is_decl_struct(self, *args):
        """
        is_decl_struct(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_struct(self, *args)

    def is_decl_union(self, *args):
        """
        is_decl_union(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_union(self, *args)

    def is_decl_udt(self, *args):
        """
        is_decl_udt(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_udt(self, *args)

    def is_decl_enum(self, *args):
        """
        is_decl_enum(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_enum(self, *args)

    def is_decl_bitfield(self, *args):
        """
        is_decl_bitfield(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_bitfield(self, *args)

    def is_decl_int128(self, *args):
        """
        is_decl_int128(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_int128(self, *args)

    def is_decl_int64(self, *args):
        """
        is_decl_int64(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_int64(self, *args)

    def is_decl_int32(self, *args):
        """
        is_decl_int32(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_int32(self, *args)

    def is_decl_int16(self, *args):
        """
        is_decl_int16(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_int16(self, *args)

    def is_decl_int(self, *args):
        """
        is_decl_int(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_int(self, *args)

    def is_decl_char(self, *args):
        """
        is_decl_char(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_char(self, *args)

    def is_decl_uint(self, *args):
        """
        is_decl_uint(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uint(self, *args)

    def is_decl_uchar(self, *args):
        """
        is_decl_uchar(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uchar(self, *args)

    def is_decl_uint16(self, *args):
        """
        is_decl_uint16(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uint16(self, *args)

    def is_decl_uint32(self, *args):
        """
        is_decl_uint32(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uint32(self, *args)

    def is_decl_uint64(self, *args):
        """
        is_decl_uint64(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uint64(self, *args)

    def is_decl_uint128(self, *args):
        """
        is_decl_uint128(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_uint128(self, *args)

    def is_decl_ldouble(self, *args):
        """
        is_decl_ldouble(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_ldouble(self, *args)

    def is_decl_double(self, *args):
        """
        is_decl_double(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_double(self, *args)

    def is_decl_float(self, *args):
        """
        is_decl_float(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_float(self, *args)

    def is_decl_tbyte(self, *args):
        """
        is_decl_tbyte(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_tbyte(self, *args)

    def is_decl_floating(self, *args):
        """
        is_decl_floating(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_floating(self, *args)

    def is_decl_bool(self, *args):
        """
        is_decl_bool(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_bool(self, *args)

    def is_decl_paf(self, *args):
        """
        is_decl_paf(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_decl_paf(self, *args)

    def is_well_defined(self, *args):
        """
        is_well_defined(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_well_defined(self, *args)

    def is_const(self, *args):
        """
        is_const(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_const(self, *args)

    def is_volatile(self, *args):
        """
        is_volatile(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_volatile(self, *args)

    def is_void(self, *args):
        """
        is_void(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_void(self, *args)

    def is_partial(self, *args):
        """
        is_partial(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_partial(self, *args)

    def is_unknown(self, *args):
        """
        is_unknown(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_unknown(self, *args)

    def is_ptr(self, *args):
        """
        is_ptr(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_ptr(self, *args)

    def is_array(self, *args):
        """
        is_array(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_array(self, *args)

    def is_func(self, *args):
        """
        is_func(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_func(self, *args)

    def is_complex(self, *args):
        """
        is_complex(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_complex(self, *args)

    def is_struct(self, *args):
        """
        is_struct(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_struct(self, *args)

    def is_union(self, *args):
        """
        is_union(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_union(self, *args)

    def is_udt(self, *args):
        """
        is_udt(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_udt(self, *args)

    def is_enum(self, *args):
        """
        is_enum(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_enum(self, *args)

    def is_sue(self, *args):
        """
        is_sue(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_sue(self, *args)

    def is_bitfield(self, *args):
        """
        is_bitfield(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_bitfield(self, *args)

    def is_int128(self, *args):
        """
        is_int128(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_int128(self, *args)

    def is_int64(self, *args):
        """
        is_int64(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_int64(self, *args)

    def is_int32(self, *args):
        """
        is_int32(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_int32(self, *args)

    def is_int16(self, *args):
        """
        is_int16(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_int16(self, *args)

    def is_int(self, *args):
        """
        is_int(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_int(self, *args)

    def is_char(self, *args):
        """
        is_char(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_char(self, *args)

    def is_uint(self, *args):
        """
        is_uint(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uint(self, *args)

    def is_uchar(self, *args):
        """
        is_uchar(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uchar(self, *args)

    def is_uint16(self, *args):
        """
        is_uint16(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uint16(self, *args)

    def is_uint32(self, *args):
        """
        is_uint32(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uint32(self, *args)

    def is_uint64(self, *args):
        """
        is_uint64(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uint64(self, *args)

    def is_uint128(self, *args):
        """
        is_uint128(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_uint128(self, *args)

    def is_ldouble(self, *args):
        """
        is_ldouble(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_ldouble(self, *args)

    def is_double(self, *args):
        """
        is_double(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_double(self, *args)

    def is_float(self, *args):
        """
        is_float(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_float(self, *args)

    def is_tbyte(self, *args):
        """
        is_tbyte(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_tbyte(self, *args)

    def is_bool(self, *args):
        """
        is_bool(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_bool(self, *args)

    def is_paf(self, *args):
        """
        is_paf(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_paf(self, *args)

    def is_ptr_or_array(self, *args):
        """
        is_ptr_or_array(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_ptr_or_array(self, *args)

    def is_integral(self, *args):
        """
        is_integral(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_integral(self, *args)

    def is_ext_integral(self, *args):
        """
        is_ext_integral(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_ext_integral(self, *args)

    def is_floating(self, *args):
        """
        is_floating(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_floating(self, *args)

    def is_arithmetic(self, *args):
        """
        is_arithmetic(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_arithmetic(self, *args)

    def is_ext_arithmetic(self, *args):
        """
        is_ext_arithmetic(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_ext_arithmetic(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_scalar(self, *args)

    def get_ptr_details(self, *args):
        """
        get_ptr_details(self, pi) -> bool
        """
        return _ida_typeinf.tinfo_t_get_ptr_details(self, *args)

    def get_array_details(self, *args):
        """
        get_array_details(self, ai) -> bool
        """
        return _ida_typeinf.tinfo_t_get_array_details(self, *args)

    def get_enum_details(self, *args):
        """
        get_enum_details(self, ei) -> bool
        """
        return _ida_typeinf.tinfo_t_get_enum_details(self, *args)

    def get_bitfield_details(self, *args):
        """
        get_bitfield_details(self, bi) -> bool
        """
        return _ida_typeinf.tinfo_t_get_bitfield_details(self, *args)

    def get_udt_details(self, *args):
        """
        get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
        """
        return _ida_typeinf.tinfo_t_get_udt_details(self, *args)

    def get_func_details(self, *args):
        """
        get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
        """
        return _ida_typeinf.tinfo_t_get_func_details(self, *args)

    def is_funcptr(self, *args):
        """
        is_funcptr(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_funcptr(self, *args)

    def is_shifted_ptr(self, *args):
        """
        is_shifted_ptr(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_shifted_ptr(self, *args)

    def is_varstruct(self, *args):
        """
        is_varstruct(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_varstruct(self, *args)

    def get_ptrarr_objsize(self, *args):
        """
        get_ptrarr_objsize(self) -> int
        """
        return _ida_typeinf.tinfo_t_get_ptrarr_objsize(self, *args)

    def get_ptrarr_object(self, *args):
        """
        get_ptrarr_object(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_ptrarr_object(self, *args)

    def get_pointed_object(self, *args):
        """
        get_pointed_object(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_pointed_object(self, *args)

    def is_pvoid(self, *args):
        """
        is_pvoid(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_pvoid(self, *args)

    def get_array_element(self, *args):
        """
        get_array_element(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_array_element(self, *args)

    def get_array_nelems(self, *args):
        """
        get_array_nelems(self) -> int
        """
        return _ida_typeinf.tinfo_t_get_array_nelems(self, *args)

    def get_nth_arg(self, *args):
        """
        get_nth_arg(self, n) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_nth_arg(self, *args)

    def get_rettype(self, *args):
        """
        get_rettype(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_rettype(self, *args)

    def get_nargs(self, *args):
        """
        get_nargs(self) -> int
        """
        return _ida_typeinf.tinfo_t_get_nargs(self, *args)

    def is_user_cc(self, *args):
        """
        is_user_cc(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_user_cc(self, *args)

    def is_vararg_cc(self, *args):
        """
        is_vararg_cc(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_vararg_cc(self, *args)

    def is_purging_cc(self, *args):
        """
        is_purging_cc(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_purging_cc(self, *args)

    def calc_purged_bytes(self, *args):
        """
        calc_purged_bytes(self) -> int
        """
        return _ida_typeinf.tinfo_t_calc_purged_bytes(self, *args)

    def is_high_func(self, *args):
        """
        is_high_func(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_high_func(self, *args)

    def find_udt_member(self, *args):
        """
        find_udt_member(self, udm, strmem_flags) -> int
        """
        return _ida_typeinf.tinfo_t_find_udt_member(self, *args)

    def get_udt_nmembers(self, *args):
        """
        get_udt_nmembers(self) -> int
        """
        return _ida_typeinf.tinfo_t_get_udt_nmembers(self, *args)

    def is_empty_udt(self, *args):
        """
        is_empty_udt(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_empty_udt(self, *args)

    def is_small_udt(self, *args):
        """
        is_small_udt(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_small_udt(self, *args)

    def requires_qualifier(self, *args):
        """
        requires_qualifier(self, name, offset) -> bool
        """
        return _ida_typeinf.tinfo_t_requires_qualifier(self, *args)

    def append_covered(self, *args):
        """
        append_covered(self, out, offset=0) -> bool
        """
        return _ida_typeinf.tinfo_t_append_covered(self, *args)

    def calc_gaps(self, *args):
        """
        calc_gaps(self, out) -> bool
        """
        return _ida_typeinf.tinfo_t_calc_gaps(self, *args)

    def is_one_fpval(self, *args):
        """
        is_one_fpval(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_one_fpval(self, *args)

    def is_sse_type(self, *args):
        """
        is_sse_type(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_sse_type(self, *args)

    def is_anonymous_udt(self, *args):
        """
        is_anonymous_udt(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_anonymous_udt(self, *args)

    def is_vftable(self, *args):
        """
        is_vftable(self) -> bool
        """
        return _ida_typeinf.tinfo_t_is_vftable(self, *args)

    def has_vftable(self, *args):
        """
        has_vftable(self) -> bool
        """
        return _ida_typeinf.tinfo_t_has_vftable(self, *args)

    def get_enum_base_type(self, *args):
        """
        get_enum_base_type(self) -> type_t
        """
        return _ida_typeinf.tinfo_t_get_enum_base_type(self, *args)

    def get_onemember_type(self, *args):
        """
        get_onemember_type(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_onemember_type(self, *args)

    def calc_score(self, *args):
        """
        calc_score(self) -> uint32
        """
        return _ida_typeinf.tinfo_t_calc_score(self, *args)

    def _print(self, *args):
        """
        _print(self, name=None, prtype_flags=0x0000, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
        """
        return _ida_typeinf.tinfo_t__print(self, *args)

    def dstr(self, *args):
        """
        dstr(self) -> char const *
        """
        return _ida_typeinf.tinfo_t_dstr(self, *args)

    def get_attrs(self, *args):
        """
        get_attrs(self, tav, all_attrs=False) -> bool
        """
        return _ida_typeinf.tinfo_t_get_attrs(self, *args)

    def set_attrs(self, *args):
        """
        set_attrs(self, tav) -> bool
        """
        return _ida_typeinf.tinfo_t_set_attrs(self, *args)

    def set_attr(self, *args):
        """
        set_attr(self, ta, may_overwrite=True) -> bool
        """
        return _ida_typeinf.tinfo_t_set_attr(self, *args)

    def del_attrs(self, *args):
        """
        del_attrs(self)
        """
        return _ida_typeinf.tinfo_t_del_attrs(self, *args)

    def del_attr(self, *args):
        """
        del_attr(self, key, make_copy=True) -> bool
        """
        return _ida_typeinf.tinfo_t_del_attr(self, *args)

    def create_simple_type(self, *args):
        """
        create_simple_type(self, decl_type) -> bool
        """
        return _ida_typeinf.tinfo_t_create_simple_type(self, *args)

    def create_ptr(self, *args):
        """
        create_ptr(self, p, decl_type=BT_PTR) -> bool
        create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
        """
        return _ida_typeinf.tinfo_t_create_ptr(self, *args)

    def create_array(self, *args):
        """
        create_array(self, p, decl_type=BT_ARRAY) -> bool
        create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
        """
        return _ida_typeinf.tinfo_t_create_array(self, *args)

    def create_typedef(self, *args):
        """
        create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
        create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
        create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
        """
        return _ida_typeinf.tinfo_t_create_typedef(self, *args)

    def create_bitfield(self, *args):
        """
        create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
        create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
        """
        return _ida_typeinf.tinfo_t_create_bitfield(self, *args)

    def create_udt(self, *args):
        """
        create_udt(self, p, decl_type) -> bool
        """
        return _ida_typeinf.tinfo_t_create_udt(self, *args)

    def create_enum(self, *args):
        """
        create_enum(self, p, decl_type=BTF_ENUM) -> bool
        """
        return _ida_typeinf.tinfo_t_create_enum(self, *args)

    def create_func(self, *args):
        """
        create_func(self, p, decl_type=BT_FUNC) -> bool
        """
        return _ida_typeinf.tinfo_t_create_func(self, *args)

    def set_named_type(self, *args):
        """
        set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
        """
        return _ida_typeinf.tinfo_t_set_named_type(self, *args)

    def set_symbol_type(self, *args):
        """
        set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
        """
        return _ida_typeinf.tinfo_t_set_symbol_type(self, *args)

    def set_numbered_type(self, *args):
        """
        set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
        """
        return _ida_typeinf.tinfo_t_set_numbered_type(self, *args)

    def create_forward_decl(self, *args):
        """
        create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
        """
        return _ida_typeinf.tinfo_t_create_forward_decl(self, *args)

    def get_stock(*args):
        """
        get_stock(id) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_get_stock(*args)

    get_stock = staticmethod(get_stock)
    def convert_array_to_ptr(self, *args):
        """
        convert_array_to_ptr(self) -> bool
        """
        return _ida_typeinf.tinfo_t_convert_array_to_ptr(self, *args)

    def remove_ptr_or_array(self, *args):
        """
        remove_ptr_or_array(self) -> bool
        """
        return _ida_typeinf.tinfo_t_remove_ptr_or_array(self, *args)

    def change_sign(self, *args):
        """
        change_sign(self, sign) -> bool
        """
        return _ida_typeinf.tinfo_t_change_sign(self, *args)

    def calc_udt_aligns(self, *args):
        """
        calc_udt_aligns(self, sudt_flags=0x0004) -> bool
        """
        return _ida_typeinf.tinfo_t_calc_udt_aligns(self, *args)

    def read_bitfield_value(self, *args):
        """
        read_bitfield_value(self, v, bitoff) -> uint64
        """
        return _ida_typeinf.tinfo_t_read_bitfield_value(self, *args)

    def write_bitfield_value(self, *args):
        """
        write_bitfield_value(self, dst, v, bitoff) -> uint64
        """
        return _ida_typeinf.tinfo_t_write_bitfield_value(self, *args)

    def get_modifiers(self, *args):
        """
        get_modifiers(self) -> type_t
        """
        return _ida_typeinf.tinfo_t_get_modifiers(self, *args)

    def set_modifiers(self, *args):
        """
        set_modifiers(self, mod)
        """
        return _ida_typeinf.tinfo_t_set_modifiers(self, *args)

    def set_const(self, *args):
        """
        set_const(self)
        """
        return _ida_typeinf.tinfo_t_set_const(self, *args)

    def set_volatile(self, *args):
        """
        set_volatile(self)
        """
        return _ida_typeinf.tinfo_t_set_volatile(self, *args)

    def clr_const(self, *args):
        """
        clr_const(self)
        """
        return _ida_typeinf.tinfo_t_clr_const(self, *args)

    def clr_volatile(self, *args):
        """
        clr_volatile(self)
        """
        return _ida_typeinf.tinfo_t_clr_volatile(self, *args)

    def clr_const_volatile(self, *args):
        """
        clr_const_volatile(self)
        """
        return _ida_typeinf.tinfo_t_clr_const_volatile(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_typeinf.tinfo_t_compare(self, *args)

    def compare_with(self, *args):
        """
        compare_with(self, r, tcflags=0) -> bool
        """
        return _ida_typeinf.tinfo_t_compare_with(self, *args)

    def equals_to(self, *args):
        """
        equals_to(self, r) -> bool
        """
        return _ida_typeinf.tinfo_t_equals_to(self, *args)

    def is_castable_to(self, *args):
        """
        is_castable_to(self, target) -> bool
        """
        return _ida_typeinf.tinfo_t_is_castable_to(self, *args)

    def is_manually_castable_to(self, *args):
        """
        is_manually_castable_to(self, target) -> bool
        """
        return _ida_typeinf.tinfo_t_is_manually_castable_to(self, *args)

    def serialize(self, *args):
        """
        serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> PyObject *
        """
        return _ida_typeinf.tinfo_t_serialize(self, *args)

    def deserialize(self, *args):
        """
        deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
        deserialize(self, til, type, fields, cmts=None) -> bool
        """
        return _ida_typeinf.tinfo_t_deserialize(self, *args)

    def copy(self, *args):
        """
        copy(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_copy(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> qstring
        """
        return _ida_typeinf.tinfo_t___str__(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_tinfo_t
    __del__ = lambda self : None;
    def get_attr(self, *args):
        """
        get_attr(self, key, all_attrs=True) -> PyObject *
        """
        return _ida_typeinf.tinfo_t_get_attr(self, *args)

tinfo_t_swigregister = _ida_typeinf.tinfo_t_swigregister
tinfo_t_swigregister(tinfo_t)
COMP_MASK = cvar.COMP_MASK
COMP_UNK = cvar.COMP_UNK
COMP_MS = cvar.COMP_MS
COMP_BC = cvar.COMP_BC
COMP_WATCOM = cvar.COMP_WATCOM
COMP_GNU = cvar.COMP_GNU
COMP_VISAGE = cvar.COMP_VISAGE
COMP_BP = cvar.COMP_BP
COMP_UNSURE = cvar.COMP_UNSURE
BADSIZE = cvar.BADSIZE
BADORD = cvar.BADORD
FIRST_NONTRIVIAL_TYPID = cvar.FIRST_NONTRIVIAL_TYPID
TYPID_ISREF = cvar.TYPID_ISREF
TYPID_SHIFT = cvar.TYPID_SHIFT

def remove_pointer(*args):
  """
  remove_pointer(tif) -> tinfo_t


   'BT_PTR' : If the current type is a pointer, return the pointed
  object. If the current type is not a pointer, return the current type.
  See also get_ptrarr_object() and get_pointed_object()
  
  @param tif (C++: const  tinfo_t  &)
  """
  return _ida_typeinf.remove_pointer(*args)
STRMEM_MASK = _ida_typeinf.STRMEM_MASK
STRMEM_OFFSET = _ida_typeinf.STRMEM_OFFSET
"""
get member by offset- in: udm->offset - is a member offset in bits
"""
STRMEM_INDEX = _ida_typeinf.STRMEM_INDEX
"""
get member by number- in: udm->offset - is a member number
"""
STRMEM_AUTO = _ida_typeinf.STRMEM_AUTO
"""
get member by offset if struct, or get member by index if union - nb:
union: index is stored in the udm->offset field!nb: struct: offset is
in bytes (not in bits)!
"""
STRMEM_NAME = _ida_typeinf.STRMEM_NAME
"""
get member by name- in: udm->name - the desired member name.
"""
STRMEM_TYPE = _ida_typeinf.STRMEM_TYPE
"""
get member by type. - in: udm->type - the desired member type. member
types are compared with tinfo_t::equals_to()
"""
STRMEM_SIZE = _ida_typeinf.STRMEM_SIZE
"""
get member by size.- in: udm->size - the desired member size.
"""
STRMEM_MINS = _ida_typeinf.STRMEM_MINS
"""
get smallest member by size.
"""
STRMEM_MAXS = _ida_typeinf.STRMEM_MAXS
"""
get biggest member by size.
"""
STRMEM_VFTABLE = _ida_typeinf.STRMEM_VFTABLE
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class
"""
STRMEM_SKIP_EMPTY = _ida_typeinf.STRMEM_SKIP_EMPTY
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned
"""
STRMEM_CASTABLE_TO = _ida_typeinf.STRMEM_CASTABLE_TO
"""
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type
"""
STRMEM_ANON = _ida_typeinf.STRMEM_ANON
"""
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.
"""

def tinfo_t_get_stock(*args):
  """
  tinfo_t_get_stock(id) -> tinfo_t
  """
  return _ida_typeinf.tinfo_t_get_stock(*args)
TCMP_EQUAL = _ida_typeinf.TCMP_EQUAL
"""
are types equal?
"""
TCMP_IGNMODS = _ida_typeinf.TCMP_IGNMODS
"""
ignore const/volatile modifiers
"""
TCMP_AUTOCAST = _ida_typeinf.TCMP_AUTOCAST
"""
can t1 be cast into t2 automatically?
"""
TCMP_MANCAST = _ida_typeinf.TCMP_MANCAST
"""
can t1 be cast into t2 manually?
"""
TCMP_CALL = _ida_typeinf.TCMP_CALL
"""
can t1 be called with t2 type?
"""
TCMP_DELPTR = _ida_typeinf.TCMP_DELPTR
"""
remove pointer from types before comparing
"""
TCMP_DECL = _ida_typeinf.TCMP_DECL
"""
compare declarations without resolving them
"""
TCMP_ANYBASE = _ida_typeinf.TCMP_ANYBASE
"""
accept any base class when casting
"""
TCMP_SKIPTHIS = _ida_typeinf.TCMP_SKIPTHIS
"""
skip the first function argument in comparison
"""

class simd_info_t(object):
    """
    Proxy of C++ simd_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_typeinf.simd_info_t_name_get, _ida_typeinf.simd_info_t_name_set)
    tif = _swig_property(_ida_typeinf.simd_info_t_tif_get, _ida_typeinf.simd_info_t_tif_set)
    size = _swig_property(_ida_typeinf.simd_info_t_size_get, _ida_typeinf.simd_info_t_size_set)
    memtype = _swig_property(_ida_typeinf.simd_info_t_memtype_get, _ida_typeinf.simd_info_t_memtype_set)
    def __init__(self, *args):
        """
        __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
        """
        this = _ida_typeinf.new_simd_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def match_pattern(self, *args):
        """
        match_pattern(self, pattern) -> bool
        """
        return _ida_typeinf.simd_info_t_match_pattern(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_simd_info_t
    __del__ = lambda self : None;
simd_info_t_swigregister = _ida_typeinf.simd_info_t_swigregister
simd_info_t_swigregister(simd_info_t)


def guess_func_cc(*args):
  """
  guess_func_cc(fti, npurged, cc_flags) -> cm_t


  Use 'func_type_data_t::guess_cc()'
  
  
  @param fti (C++: const  func_type_data_t  &)
  @param npurged (C++: int)
  @param cc_flags (C++: int)
  """
  return _ida_typeinf.guess_func_cc(*args)

def dump_func_type_data(*args):
  """
  dump_func_type_data(fti, praloc_bits) -> bool


  Use 'func_type_data_t::dump()'
  
  
  @param fti (C++: const  func_type_data_t  &)
  @param praloc_bits (C++: int)
  """
  return _ida_typeinf.dump_func_type_data(*args)
class ptr_type_data_t(object):
    """
    Proxy of C++ ptr_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    obj_type = _swig_property(_ida_typeinf.ptr_type_data_t_obj_type_get, _ida_typeinf.ptr_type_data_t_obj_type_set)
    closure = _swig_property(_ida_typeinf.ptr_type_data_t_closure_get, _ida_typeinf.ptr_type_data_t_closure_set)
    based_ptr_size = _swig_property(_ida_typeinf.ptr_type_data_t_based_ptr_size_get, _ida_typeinf.ptr_type_data_t_based_ptr_size_set)
    taptr_bits = _swig_property(_ida_typeinf.ptr_type_data_t_taptr_bits_get, _ida_typeinf.ptr_type_data_t_taptr_bits_set)
    parent = _swig_property(_ida_typeinf.ptr_type_data_t_parent_get, _ida_typeinf.ptr_type_data_t_parent_set)
    delta = _swig_property(_ida_typeinf.ptr_type_data_t_delta_get, _ida_typeinf.ptr_type_data_t_delta_set)
    def __init__(self, *args):
        """
        __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
        """
        this = _ida_typeinf.new_ptr_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.ptr_type_data_t_swap(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.ptr_type_data_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.ptr_type_data_t___ne__(self, *args)

    def is_code_ptr(self, *args):
        """
        is_code_ptr(self) -> bool
        """
        return _ida_typeinf.ptr_type_data_t_is_code_ptr(self, *args)

    def is_shifted(self, *args):
        """
        is_shifted(self) -> bool
        """
        return _ida_typeinf.ptr_type_data_t_is_shifted(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_ptr_type_data_t
    __del__ = lambda self : None;
ptr_type_data_t_swigregister = _ida_typeinf.ptr_type_data_t_swigregister
ptr_type_data_t_swigregister(ptr_type_data_t)

class array_type_data_t(object):
    """
    Proxy of C++ array_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    elem_type = _swig_property(_ida_typeinf.array_type_data_t_elem_type_get, _ida_typeinf.array_type_data_t_elem_type_set)
    base = _swig_property(_ida_typeinf.array_type_data_t_base_get, _ida_typeinf.array_type_data_t_base_set)
    nelems = _swig_property(_ida_typeinf.array_type_data_t_nelems_get, _ida_typeinf.array_type_data_t_nelems_set)
    def __init__(self, *args):
        """
        __init__(self, b=0, n=0) -> array_type_data_t
        """
        this = _ida_typeinf.new_array_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.array_type_data_t_swap(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_array_type_data_t
    __del__ = lambda self : None;
array_type_data_t_swigregister = _ida_typeinf.array_type_data_t_swigregister
array_type_data_t_swigregister(array_type_data_t)

class funcarg_t(object):
    """
    Proxy of C++ funcarg_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    argloc = _swig_property(_ida_typeinf.funcarg_t_argloc_get, _ida_typeinf.funcarg_t_argloc_set)
    name = _swig_property(_ida_typeinf.funcarg_t_name_get, _ida_typeinf.funcarg_t_name_set)
    cmt = _swig_property(_ida_typeinf.funcarg_t_cmt_get, _ida_typeinf.funcarg_t_cmt_set)
    type = _swig_property(_ida_typeinf.funcarg_t_type_get, _ida_typeinf.funcarg_t_type_set)
    flags = _swig_property(_ida_typeinf.funcarg_t_flags_get, _ida_typeinf.funcarg_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> funcarg_t
        """
        this = _ida_typeinf.new_funcarg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.funcarg_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.funcarg_t___ne__(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_funcarg_t
    __del__ = lambda self : None;
funcarg_t_swigregister = _ida_typeinf.funcarg_t_swigregister
funcarg_t_swigregister(funcarg_t)
FAI_HIDDEN = _ida_typeinf.FAI_HIDDEN
"""
hidden argument
"""
FAI_RETPTR = _ida_typeinf.FAI_RETPTR
"""
pointer to return value. implies hidden
"""
FAI_STRUCT = _ida_typeinf.FAI_STRUCT
"""
was initially a structure
"""
FAI_ARRAY = _ida_typeinf.FAI_ARRAY
"""
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type
"""
TA_ORG_TYPEDEF = _ida_typeinf.TA_ORG_TYPEDEF
"""
the original typedef name (simple string)
"""
TA_ORG_ARRDIM = _ida_typeinf.TA_ORG_ARRDIM
"""
the original array dimension (pack_dd)
"""
TA_FORMAT = _ida_typeinf.TA_FORMAT
"""
info about the 'format' argument 3 times pack_dd: 'format_functype_t'
, argument number of 'format', argument number of '...'
"""

class func_type_data_t(funcargvec_t):
    """
    Proxy of C++ func_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flags = _swig_property(_ida_typeinf.func_type_data_t_flags_get, _ida_typeinf.func_type_data_t_flags_set)
    rettype = _swig_property(_ida_typeinf.func_type_data_t_rettype_get, _ida_typeinf.func_type_data_t_rettype_set)
    retloc = _swig_property(_ida_typeinf.func_type_data_t_retloc_get, _ida_typeinf.func_type_data_t_retloc_set)
    stkargs = _swig_property(_ida_typeinf.func_type_data_t_stkargs_get, _ida_typeinf.func_type_data_t_stkargs_set)
    spoiled = _swig_property(_ida_typeinf.func_type_data_t_spoiled_get, _ida_typeinf.func_type_data_t_spoiled_set)
    cc = _swig_property(_ida_typeinf.func_type_data_t_cc_get, _ida_typeinf.func_type_data_t_cc_set)
    def __init__(self, *args):
        """
        __init__(self) -> func_type_data_t
        """
        this = _ida_typeinf.new_func_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.func_type_data_t_swap(self, *args)

    def is_high(self, *args):
        """
        is_high(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_high(self, *args)

    def is_noret(self, *args):
        """
        is_noret(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_noret(self, *args)

    def is_pure(self, *args):
        """
        is_pure(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_pure(self, *args)

    def get_call_method(self, *args):
        """
        get_call_method(self) -> int
        """
        return _ida_typeinf.func_type_data_t_get_call_method(self, *args)

    def is_vararg_cc(self, *args):
        """
        is_vararg_cc(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_vararg_cc(self, *args)

    def guess_cc(self, *args):
        """
        guess_cc(self, purged, cc_flags) -> cm_t
        """
        return _ida_typeinf.func_type_data_t_guess_cc(self, *args)

    def dump(self, *args):
        """
        dump(self, praloc_bits=0x02) -> bool
        """
        return _ida_typeinf.func_type_data_t_dump(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_func_type_data_t
    __del__ = lambda self : None;
func_type_data_t_swigregister = _ida_typeinf.func_type_data_t_swigregister
func_type_data_t_swigregister(func_type_data_t)
FTI_SPOILED = _ida_typeinf.FTI_SPOILED
"""
information about spoiled registers is present
"""
FTI_NORET = _ida_typeinf.FTI_NORET
"""
noreturn
"""
FTI_PURE = _ida_typeinf.FTI_PURE
"""
__pure
"""
FTI_HIGH = _ida_typeinf.FTI_HIGH
"""
high level prototype (with possibly hidden args)
"""
FTI_STATIC = _ida_typeinf.FTI_STATIC
"""
static
"""
FTI_VIRTUAL = _ida_typeinf.FTI_VIRTUAL
"""
virtual
"""
FTI_CALLTYPE = _ida_typeinf.FTI_CALLTYPE
"""
mask for FTI_*CALL
"""
FTI_DEFCALL = _ida_typeinf.FTI_DEFCALL
"""
default call
"""
FTI_NEARCALL = _ida_typeinf.FTI_NEARCALL
"""
near call
"""
FTI_FARCALL = _ida_typeinf.FTI_FARCALL
"""
far call
"""
FTI_INTCALL = _ida_typeinf.FTI_INTCALL
"""
interrupt call
"""
FTI_ARGLOCS = _ida_typeinf.FTI_ARGLOCS
"""
(stkargs and retloc too)

info about argument locations has been calculated
"""
FTI_ALL = _ida_typeinf.FTI_ALL
"""
all defined bits
"""
CC_CDECL_OK = _ida_typeinf.CC_CDECL_OK
"""
can use __cdecl calling convention?
"""
CC_ALLOW_ARGPERM = _ida_typeinf.CC_ALLOW_ARGPERM
"""
disregard argument order?
"""
CC_ALLOW_REGHOLES = _ida_typeinf.CC_ALLOW_REGHOLES
"""
allow holes in register argument list?
"""
CC_HAS_ELLIPSIS = _ida_typeinf.CC_HAS_ELLIPSIS
"""
function has a variable list of arguments?
"""

FMTFUNC_PRINTF = _ida_typeinf.FMTFUNC_PRINTF
FMTFUNC_SCANF = _ida_typeinf.FMTFUNC_SCANF
FMTFUNC_STRFTIME = _ida_typeinf.FMTFUNC_STRFTIME
FMTFUNC_STRFMON = _ida_typeinf.FMTFUNC_STRFMON
class enum_member_t(object):
    """
    Proxy of C++ enum_member_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_typeinf.enum_member_t_name_get, _ida_typeinf.enum_member_t_name_set)
    cmt = _swig_property(_ida_typeinf.enum_member_t_cmt_get, _ida_typeinf.enum_member_t_cmt_set)
    value = _swig_property(_ida_typeinf.enum_member_t_value_get, _ida_typeinf.enum_member_t_value_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.enum_member_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.enum_member_t___ne__(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.enum_member_t_swap(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> enum_member_t
        """
        this = _ida_typeinf.new_enum_member_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_enum_member_t
    __del__ = lambda self : None;
enum_member_t_swigregister = _ida_typeinf.enum_member_t_swigregister
enum_member_t_swigregister(enum_member_t)

class enum_type_data_t(enum_member_vec_t):
    """
    Proxy of C++ enum_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    group_sizes = _swig_property(_ida_typeinf.enum_type_data_t_group_sizes_get, _ida_typeinf.enum_type_data_t_group_sizes_set)
    taenum_bits = _swig_property(_ida_typeinf.enum_type_data_t_taenum_bits_get, _ida_typeinf.enum_type_data_t_taenum_bits_set)
    bte = _swig_property(_ida_typeinf.enum_type_data_t_bte_get, _ida_typeinf.enum_type_data_t_bte_set)
    def __init__(self, *args):
        """
        __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
        """
        this = _ida_typeinf.new_enum_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_64bit(self, *args):
        """
        is_64bit(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_64bit(self, *args)

    def is_hex(self, *args):
        """
        is_hex(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_hex(self, *args)

    def is_char(self, *args):
        """
        is_char(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_char(self, *args)

    def is_sdec(self, *args):
        """
        is_sdec(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_sdec(self, *args)

    def is_udec(self, *args):
        """
        is_udec(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_udec(self, *args)

    def calc_nbytes(self, *args):
        """
        calc_nbytes(self) -> int
        """
        return _ida_typeinf.enum_type_data_t_calc_nbytes(self, *args)

    def calc_mask(self, *args):
        """
        calc_mask(self) -> uint64
        """
        return _ida_typeinf.enum_type_data_t_calc_mask(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.enum_type_data_t_swap(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_enum_type_data_t
    __del__ = lambda self : None;
enum_type_data_t_swigregister = _ida_typeinf.enum_type_data_t_swigregister
enum_type_data_t_swigregister(enum_type_data_t)

class typedef_type_data_t(object):
    """
    Proxy of C++ typedef_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    til = _swig_property(_ida_typeinf.typedef_type_data_t_til_get, _ida_typeinf.typedef_type_data_t_til_set)
    is_ordref = _swig_property(_ida_typeinf.typedef_type_data_t_is_ordref_get, _ida_typeinf.typedef_type_data_t_is_ordref_set)
    resolve = _swig_property(_ida_typeinf.typedef_type_data_t_resolve_get, _ida_typeinf.typedef_type_data_t_resolve_set)
    def __init__(self, *args):
        """
        __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
        __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
        """
        this = _ida_typeinf.new_typedef_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.typedef_type_data_t_swap(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_typedef_type_data_t
    __del__ = lambda self : None;
typedef_type_data_t_swigregister = _ida_typeinf.typedef_type_data_t_swigregister
typedef_type_data_t_swigregister(typedef_type_data_t)

class udt_member_t(object):
    """
    Proxy of C++ udt_member_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    offset = _swig_property(_ida_typeinf.udt_member_t_offset_get, _ida_typeinf.udt_member_t_offset_set)
    size = _swig_property(_ida_typeinf.udt_member_t_size_get, _ida_typeinf.udt_member_t_size_set)
    name = _swig_property(_ida_typeinf.udt_member_t_name_get, _ida_typeinf.udt_member_t_name_set)
    cmt = _swig_property(_ida_typeinf.udt_member_t_cmt_get, _ida_typeinf.udt_member_t_cmt_set)
    type = _swig_property(_ida_typeinf.udt_member_t_type_get, _ida_typeinf.udt_member_t_type_set)
    effalign = _swig_property(_ida_typeinf.udt_member_t_effalign_get, _ida_typeinf.udt_member_t_effalign_set)
    tafld_bits = _swig_property(_ida_typeinf.udt_member_t_tafld_bits_get, _ida_typeinf.udt_member_t_tafld_bits_set)
    fda = _swig_property(_ida_typeinf.udt_member_t_fda_get, _ida_typeinf.udt_member_t_fda_set)
    def __init__(self, *args):
        """
        __init__(self) -> udt_member_t
        """
        this = _ida_typeinf.new_udt_member_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_bitfield(self, *args):
        """
        is_bitfield(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_bitfield(self, *args)

    def is_zero_bitfield(self, *args):
        """
        is_zero_bitfield(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_zero_bitfield(self, *args)

    def is_unaligned(self, *args):
        """
        is_unaligned(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_unaligned(self, *args)

    def is_baseclass(self, *args):
        """
        is_baseclass(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_baseclass(self, *args)

    def is_virtbase(self, *args):
        """
        is_virtbase(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_virtbase(self, *args)

    def is_vftable(self, *args):
        """
        is_vftable(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_vftable(self, *args)

    def set_unaligned(self, *args):
        """
        set_unaligned(self)
        """
        return _ida_typeinf.udt_member_t_set_unaligned(self, *args)

    def set_baseclass(self, *args):
        """
        set_baseclass(self)
        """
        return _ida_typeinf.udt_member_t_set_baseclass(self, *args)

    def set_virtbase(self, *args):
        """
        set_virtbase(self)
        """
        return _ida_typeinf.udt_member_t_set_virtbase(self, *args)

    def set_vftable(self, *args):
        """
        set_vftable(self)
        """
        return _ida_typeinf.udt_member_t_set_vftable(self, *args)

    def clr_unaligned(self, *args):
        """
        clr_unaligned(self)
        """
        return _ida_typeinf.udt_member_t_clr_unaligned(self, *args)

    def clr_baseclass(self, *args):
        """
        clr_baseclass(self)
        """
        return _ida_typeinf.udt_member_t_clr_baseclass(self, *args)

    def clr_virtbase(self, *args):
        """
        clr_virtbase(self)
        """
        return _ida_typeinf.udt_member_t_clr_virtbase(self, *args)

    def clr_vftable(self, *args):
        """
        clr_vftable(self)
        """
        return _ida_typeinf.udt_member_t_clr_vftable(self, *args)

    def begin(self, *args):
        """
        begin(self) -> uint64
        """
        return _ida_typeinf.udt_member_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> uint64
        """
        return _ida_typeinf.udt_member_t_end(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.udt_member_t___lt__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.udt_member_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.udt_member_t___ne__(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.udt_member_t_swap(self, *args)

    def is_anonymous_udm(self, *args):
        """
        is_anonymous_udm(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_anonymous_udm(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_udt_member_t
    __del__ = lambda self : None;
udt_member_t_swigregister = _ida_typeinf.udt_member_t_swigregister
udt_member_t_swigregister(udt_member_t)

class udt_type_data_t(udtmembervec_t):
    """
    Proxy of C++ udt_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    total_size = _swig_property(_ida_typeinf.udt_type_data_t_total_size_get, _ida_typeinf.udt_type_data_t_total_size_set)
    unpadded_size = _swig_property(_ida_typeinf.udt_type_data_t_unpadded_size_get, _ida_typeinf.udt_type_data_t_unpadded_size_set)
    effalign = _swig_property(_ida_typeinf.udt_type_data_t_effalign_get, _ida_typeinf.udt_type_data_t_effalign_set)
    taudt_bits = _swig_property(_ida_typeinf.udt_type_data_t_taudt_bits_get, _ida_typeinf.udt_type_data_t_taudt_bits_set)
    sda = _swig_property(_ida_typeinf.udt_type_data_t_sda_get, _ida_typeinf.udt_type_data_t_sda_set)
    pack = _swig_property(_ida_typeinf.udt_type_data_t_pack_get, _ida_typeinf.udt_type_data_t_pack_set)
    is_union = _swig_property(_ida_typeinf.udt_type_data_t_is_union_get, _ida_typeinf.udt_type_data_t_is_union_set)
    def __init__(self, *args):
        """
        __init__(self) -> udt_type_data_t
        """
        this = _ida_typeinf.new_udt_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.udt_type_data_t_swap(self, *args)

    def is_unaligned(self, *args):
        """
        is_unaligned(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_unaligned(self, *args)

    def is_msstruct(self, *args):
        """
        is_msstruct(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_msstruct(self, *args)

    def is_cppobj(self, *args):
        """
        is_cppobj(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_cppobj(self, *args)

    def is_vftable(self, *args):
        """
        is_vftable(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_vftable(self, *args)

    def is_last_baseclass(self, *args):
        """
        is_last_baseclass(self, idx) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_last_baseclass(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_udt_type_data_t
    __del__ = lambda self : None;
udt_type_data_t_swigregister = _ida_typeinf.udt_type_data_t_swigregister
udt_type_data_t_swigregister(udt_type_data_t)

VTBL_SUFFIX = _ida_typeinf.VTBL_SUFFIX
VTBL_MEMNAME = _ida_typeinf.VTBL_MEMNAME
class bitfield_type_data_t(object):
    """
    Proxy of C++ bitfield_type_data_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nbytes = _swig_property(_ida_typeinf.bitfield_type_data_t_nbytes_get, _ida_typeinf.bitfield_type_data_t_nbytes_set)
    width = _swig_property(_ida_typeinf.bitfield_type_data_t_width_get, _ida_typeinf.bitfield_type_data_t_width_set)
    is_unsigned = _swig_property(_ida_typeinf.bitfield_type_data_t_is_unsigned_get, _ida_typeinf.bitfield_type_data_t_is_unsigned_set)
    def __init__(self, *args):
        """
        __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
        """
        this = _ida_typeinf.new_bitfield_type_data_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_typeinf.bitfield_type_data_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_typeinf.bitfield_type_data_t_compare(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_typeinf.bitfield_type_data_t_swap(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_bitfield_type_data_t
    __del__ = lambda self : None;
bitfield_type_data_t_swigregister = _ida_typeinf.bitfield_type_data_t_swigregister
bitfield_type_data_t_swigregister(bitfield_type_data_t)

class type_mods_t(object):
    """
    Proxy of C++ type_mods_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    type = _swig_property(_ida_typeinf.type_mods_t_type_get, _ida_typeinf.type_mods_t_type_set)
    name = _swig_property(_ida_typeinf.type_mods_t_name_get, _ida_typeinf.type_mods_t_name_set)
    cmt = _swig_property(_ida_typeinf.type_mods_t_cmt_get, _ida_typeinf.type_mods_t_cmt_set)
    flags = _swig_property(_ida_typeinf.type_mods_t_flags_get, _ida_typeinf.type_mods_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> type_mods_t
        """
        this = _ida_typeinf.new_type_mods_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_typeinf.type_mods_t_clear(self, *args)

    def set_new_type(self, *args):
        """
        set_new_type(self, t)
        """
        return _ida_typeinf.type_mods_t_set_new_type(self, *args)

    def set_new_name(self, *args):
        """
        set_new_name(self, n)
        """
        return _ida_typeinf.type_mods_t_set_new_name(self, *args)

    def set_new_cmt(self, *args):
        """
        set_new_cmt(self, c)
        """
        return _ida_typeinf.type_mods_t_set_new_cmt(self, *args)

    def has_type(self, *args):
        """
        has_type(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_type(self, *args)

    def has_name(self, *args):
        """
        has_name(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_name(self, *args)

    def has_cmt(self, *args):
        """
        has_cmt(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_cmt(self, *args)

    def has_info(self, *args):
        """
        has_info(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_info(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_type_mods_t
    __del__ = lambda self : None;
type_mods_t_swigregister = _ida_typeinf.type_mods_t_swigregister
type_mods_t_swigregister(type_mods_t)
TVIS_TYPE = _ida_typeinf.TVIS_TYPE
"""
new type info is present
"""
TVIS_NAME = _ida_typeinf.TVIS_NAME
"""
new name is present
"""
TVIS_CMT = _ida_typeinf.TVIS_CMT
"""
new comment is present
"""

class tinfo_visitor_t(object):
    """
    Proxy of C++ tinfo_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    state = _swig_property(_ida_typeinf.tinfo_visitor_t_state_get, _ida_typeinf.tinfo_visitor_t_state_set)
    def __init__(self, *args):
        """
        __init__(self, s=0) -> tinfo_visitor_t
        """
        if self.__class__ == tinfo_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_typeinf.new_tinfo_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def visit_type(self, *args):
        """
        visit_type(self, out, tif, name, cmt) -> int
        """
        return _ida_typeinf.tinfo_visitor_t_visit_type(self, *args)

    def prune_now(self, *args):
        """
        prune_now(self)
        """
        return _ida_typeinf.tinfo_visitor_t_prune_now(self, *args)

    def apply_to(self, *args):
        """
        apply_to(self, tif, out=None, name=None, cmt=None) -> int
        """
        return _ida_typeinf.tinfo_visitor_t_apply_to(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_tinfo_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_tinfo_visitor_t(self)
        return weakref_proxy(self)
tinfo_visitor_t_swigregister = _ida_typeinf.tinfo_visitor_t_swigregister
tinfo_visitor_t_swigregister(tinfo_visitor_t)
TVST_PRUNE = _ida_typeinf.TVST_PRUNE
"""
don't visit children of current type
"""
TVST_DEF = _ida_typeinf.TVST_DEF
"""
visit type definition (meaningful for typerefs)
"""
TVST_LEVEL = _ida_typeinf.TVST_LEVEL

class regobj_t(object):
    """
    Proxy of C++ regobj_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    regidx = _swig_property(_ida_typeinf.regobj_t_regidx_get, _ida_typeinf.regobj_t_regidx_set)
    relocate = _swig_property(_ida_typeinf.regobj_t_relocate_get, _ida_typeinf.regobj_t_relocate_set)
    value = _swig_property(_ida_typeinf.regobj_t_value_get, _ida_typeinf.regobj_t_value_set)
    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_typeinf.regobj_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> regobj_t
        """
        this = _ida_typeinf.new_regobj_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_regobj_t
    __del__ = lambda self : None;
regobj_t_swigregister = _ida_typeinf.regobj_t_swigregister
regobj_t_swigregister(regobj_t)

class regobjs_t(regobjvec_t):
    """
    Proxy of C++ regobjs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> regobjs_t
        """
        this = _ida_typeinf.new_regobjs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_regobjs_t
    __del__ = lambda self : None;
regobjs_t_swigregister = _ida_typeinf.regobjs_t_swigregister
regobjs_t_swigregister(regobjs_t)


def unpack_idcobj_from_idb(*args):
  """
  unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t


  Collection of register objects.
  
  Read a typed idc object from the database
  
  @param obj (C++: idc_value_t  *)
  @param tif (C++: const  tinfo_t  &)
  @param ea (C++: ea_t)
  @param off0 (C++: const  bytevec_t  *)
  @param pio_flags (C++: int)
  """
  return _ida_typeinf.unpack_idcobj_from_idb(*args)
PIO_NOATTR_FAIL = _ida_typeinf.PIO_NOATTR_FAIL
"""
missing attributes are not ok
"""
PIO_IGNORE_PTRS = _ida_typeinf.PIO_IGNORE_PTRS
"""
do not follow pointers
"""

def unpack_idcobj_from_bv(*args):
  """
  unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t


  Read a typed idc object from the byte vector.
  
  
  @param obj (C++: idc_value_t  *)
  @param tif (C++: const  tinfo_t  &)
  @param bytes (C++: const  bytevec_t  &)
  @param pio_flags (C++: int)
  """
  return _ida_typeinf.unpack_idcobj_from_bv(*args)

def pack_idcobj_to_idb(*args):
  """
  pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t


  Write a typed idc object to the database.
  
  
  @param obj (C++: const  idc_value_t  *)
  @param tif (C++: const  tinfo_t  &)
  @param ea (C++: ea_t)
  @param pio_flags (C++: int)
  """
  return _ida_typeinf.pack_idcobj_to_idb(*args)

def pack_idcobj_to_bv(*args):
  """
  pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t


  Write a typed idc object to the byte vector. Byte vector may be non-
  empty, this function will append data to it
  
  @param obj (C++: const  idc_value_t  *)
  @param tif (C++: const  tinfo_t  &)
  @param bytes (C++: relobj_t  *)
  @param objoff (C++: void *)
  @param pio_flags (C++: int)
  """
  return _ida_typeinf.pack_idcobj_to_bv(*args)

def apply_tinfo_to_stkarg(*args):
  """
  apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool


  Helper function for the processor modules. to be called from
  \ph{use_stkarg_type}
  
  @param insn (C++: const  insn_t  &)
  @param x (C++: const  op_t  &)
  @param v (C++: uval_t)
  @param tif (C++: const  tinfo_t  &)
  @param name (C++: const char *)
  """
  return _ida_typeinf.apply_tinfo_to_stkarg(*args)

def gen_use_arg_tinfos(*args):
  """
  gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)


  The main function using these callbacks:
  
  
  @param caller (C++: ea_t)
  @param fti (C++: func_type_data_t  *)
  @param rargs (C++: funcargvec_t  *)
  @param set_optype (C++: set_op_tinfo_t  *)
  @param is_stkarg_load (C++: is_stkarg_load_t  *)
  @param has_delay_slot (C++: has_delay_slot_t  *)
  """
  return _ida_typeinf.gen_use_arg_tinfos(*args)
UTP_ENUM = _ida_typeinf.UTP_ENUM
UTP_STRUCT = _ida_typeinf.UTP_STRUCT

def func_has_stkframe_hole(*args):
  """
  func_has_stkframe_hole(ea, fti) -> bool


  Looks for a hole at the beginning of the stack arguments. Will make
  use of the IDB's 'func_t' function at that place (if present) to help
  determine the presence of such a hole.
  
  @param ea (C++: ea_t)
  @param fti (C++: const  func_type_data_t  &)
  """
  return _ida_typeinf.func_has_stkframe_hole(*args)
class lowertype_helper_t(object):
    """
    Proxy of C++ lowertype_helper_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def func_has_stkframe_hole(self, *args):
        """
        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
        """
        return _ida_typeinf.lowertype_helper_t_func_has_stkframe_hole(self, *args)

    def get_func_purged_bytes(self, *args):
        """
        get_func_purged_bytes(self, candidate, candidate_data) -> int
        """
        return _ida_typeinf.lowertype_helper_t_get_func_purged_bytes(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_lowertype_helper_t
    __del__ = lambda self : None;
lowertype_helper_t_swigregister = _ida_typeinf.lowertype_helper_t_swigregister
lowertype_helper_t_swigregister(lowertype_helper_t)

class ida_lowertype_helper_t(lowertype_helper_t):
    """
    Proxy of C++ ida_lowertype_helper_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
        """
        this = _ida_typeinf.new_ida_lowertype_helper_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def func_has_stkframe_hole(self, *args):
        """
        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
        """
        return _ida_typeinf.ida_lowertype_helper_t_func_has_stkframe_hole(self, *args)

    def get_func_purged_bytes(self, *args):
        """
        get_func_purged_bytes(self, candidate, arg3) -> int
        """
        return _ida_typeinf.ida_lowertype_helper_t_get_func_purged_bytes(self, *args)

    __swig_destroy__ = _ida_typeinf.delete_ida_lowertype_helper_t
    __del__ = lambda self : None;
ida_lowertype_helper_t_swigregister = _ida_typeinf.ida_lowertype_helper_t_swigregister
ida_lowertype_helper_t_swigregister(ida_lowertype_helper_t)


def lower_type(*args):
  """
  lower_type(til, tif, name=None, _helper=None) -> int


  Lower type. Inspect the type and lower all function subtypes using
  lower_func_type().We call the prototypes usually encountered in source
  files "high level"They may have implicit arguments, array arguments,
  big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
  pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
  order to improve heuristics for recognition of big structure
  retvals,it is recommended to pass a helper that will be used to make
  decisions.That helper will be used only for lowering 'tif', and not
  for the childrentypes walked through by recursion.
  
  @param til (C++: til_t  *)
  @param tif (C++: tinfo_t  *)
  @param name (C++: const char *)
  @param _helper (C++: lowertype_helper_t  *)
  """
  return _ida_typeinf.lower_type(*args)

def replace_ordinal_typerefs(*args):
  """
  replace_ordinal_typerefs(til, tif) -> int


  Replace references to ordinal types by name references. This function
  'unties' the type from the current local type library and makes it
  easier to export it.
  
  @param til: type library to use. may be NULL. (C++: til_t  *)
  @param tif: type to modify (in/out) (C++: tinfo_t  *)
  """
  return _ida_typeinf.replace_ordinal_typerefs(*args)

def begin_type_updating(*args):
  """
  begin_type_updating(utp)


  Mark the beginning of a large update operation on the types. Can be
  used with 'add_enum_member()' , add_struc_member, etc... Also see
  'end_type_updating()'
  
  @param utp (C++: update_type_t)
  """
  return _ida_typeinf.begin_type_updating(*args)

def end_type_updating(*args):
  """
  end_type_updating(utp)


  Mark the end of a large update operation on the types (see
  'begin_type_updating()' )
  
  
  @param utp (C++: update_type_t)
  """
  return _ida_typeinf.end_type_updating(*args)
class valstr_t(object):
    """
    Proxy of C++ valstr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    oneline = _swig_property(_ida_typeinf.valstr_t_oneline_get, _ida_typeinf.valstr_t_oneline_set)
    length = _swig_property(_ida_typeinf.valstr_t_length_get, _ida_typeinf.valstr_t_length_set)
    members = _swig_property(_ida_typeinf.valstr_t_members_get, _ida_typeinf.valstr_t_members_set)
    info = _swig_property(_ida_typeinf.valstr_t_info_get, _ida_typeinf.valstr_t_info_set)
    props = _swig_property(_ida_typeinf.valstr_t_props_get, _ida_typeinf.valstr_t_props_set)
    def __init__(self, *args):
        """
        __init__(self) -> valstr_t
        """
        this = _ida_typeinf.new_valstr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_valstr_t
    __del__ = lambda self : None;
valstr_t_swigregister = _ida_typeinf.valstr_t_swigregister
valstr_t_swigregister(valstr_t)
VALSTR_OPEN = _ida_typeinf.VALSTR_OPEN
"""
printed opening curly brace '{'
"""

class valstrs_t(valstrvec_t):
    """
    Proxy of C++ valstrs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> valstrs_t
        """
        this = _ida_typeinf.new_valstrs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_valstrs_t
    __del__ = lambda self : None;
valstrs_t_swigregister = _ida_typeinf.valstrs_t_swigregister
valstrs_t_swigregister(valstrs_t)

class text_sink_t(object):
    """
    Proxy of C++ text_sink_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def _print(self, *args):
        """
        _print(self, str) -> int
        """
        return _ida_typeinf.text_sink_t__print(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> text_sink_t
        """
        if self.__class__ == text_sink_t:
            _self = None
        else:
            _self = self
        this = _ida_typeinf.new_text_sink_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_text_sink_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_text_sink_t(self)
        return weakref_proxy(self)
text_sink_t_swigregister = _ida_typeinf.text_sink_t_swigregister
text_sink_t_swigregister(text_sink_t)

PDF_INCL_DEPS = _ida_typeinf.PDF_INCL_DEPS
"""
Include all type dependencies.
"""
PDF_DEF_FWD = _ida_typeinf.PDF_DEF_FWD
"""
Allow forward declarations.
"""
PDF_DEF_BASE = _ida_typeinf.PDF_DEF_BASE
"""
Include base types: __int8, __int16, etc..
"""
PDF_HEADER_CMT = _ida_typeinf.PDF_HEADER_CMT
"""
Prepend output with a descriptive comment.
"""

def calc_number_of_children(*args):
  """
  calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int


  Calculate max number of lines of a formatted c data, when expanded (
  'PTV_EXPAND' ).
  
  @param loc: location of the data ( ALOC_STATIC  or  ALOC_CUSTOM )
              (C++: const  argloc_t  &)
  @param tif: type info (C++: const  tinfo_t  &)
  @param dont_deref_ptr: consider 'ea' as the ptr value (C++: bool)
  """
  return _ida_typeinf.calc_number_of_children(*args)
PCN_RADIX = _ida_typeinf.PCN_RADIX
"""
number base to use
"""
PCN_DEC = _ida_typeinf.PCN_DEC
"""
decimal
"""
PCN_HEX = _ida_typeinf.PCN_HEX
"""
hexadecimal
"""
PCN_OCT = _ida_typeinf.PCN_OCT
"""
octal
"""
PCN_CHR = _ida_typeinf.PCN_CHR
"""
character
"""
PCN_UNSIGNED = _ida_typeinf.PCN_UNSIGNED
"""
add 'u' suffix
"""
PCN_LZHEX = _ida_typeinf.PCN_LZHEX
"""
print leading zeroes for hexdecimal number
"""
PCN_NEGSIGN = _ida_typeinf.PCN_NEGSIGN
"""
print negated value (-N) for negative numbers
"""
PCN_DECSEXT = _ida_typeinf.PCN_DECSEXT
"""
automatically extend sign of signed decimal numbers
"""

def get_enum_member_expr(*args):
  """
  get_enum_member_expr(tif, serial, value) -> bool


  Return a C expression that can be used to represent an enum member. If
  the value does not correspond to any single enum member, this function
  tries to find a bitwise combination of enum members that correspond to
  it. If more than half of value bits do not match any enum members, it
  fails.
  
  @param tif: enumeration type (C++: const  tinfo_t  &)
  @param serial: which enumeration member to use (0 means the first with
                 the given value) (C++: int)
  @param value: value to search in the enumeration type. only 32-bit
                number can be handled yet (C++: uint64)
  @return: success
  """
  return _ida_typeinf.get_enum_member_expr(*args)
class til_symbol_t(object):
    """
    Proxy of C++ til_symbol_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_typeinf.til_symbol_t_name_get, _ida_typeinf.til_symbol_t_name_set)
    til = _swig_property(_ida_typeinf.til_symbol_t_til_get, _ida_typeinf.til_symbol_t_til_set)
    def __init__(self, *args):
        """
        __init__(self, n=None, t=None) -> til_symbol_t
        """
        this = _ida_typeinf.new_til_symbol_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_til_symbol_t
    __del__ = lambda self : None;
til_symbol_t_swigregister = _ida_typeinf.til_symbol_t_swigregister
til_symbol_t_swigregister(til_symbol_t)

class predicate_t(object):
    """
    Proxy of C++ predicate_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def should_display(self, *args):
        """
        should_display(self, til, name, type, fields) -> bool
        """
        return _ida_typeinf.predicate_t_should_display(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> predicate_t
        """
        if self.__class__ == predicate_t:
            _self = None
        else:
            _self = self
        this = _ida_typeinf.new_predicate_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_typeinf.delete_predicate_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_predicate_t(self)
        return weakref_proxy(self)
predicate_t_swigregister = _ida_typeinf.predicate_t_swigregister
predicate_t_swigregister(predicate_t)


def choose_named_type(*args):
  """
  choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool


  Choose a type from a type library.
  
  @param out_sym: pointer to be filled with the chosen type (C++:
                  til_symbol_t  *)
  @param root_til: pointer to starting til (the function will inspect
                   the base tils if allowed by flags) (C++: const  til_t
                   *)
  @param title: title of listbox to display (C++: const char *)
  @param ntf_flags: combination of  Flags for named types (C++: int)
  @param predicate: predicate to select types to display (maybe NULL)
                    (C++: predicate_t  *)
  @return: false if nothing is chosen, otherwise true
  """
  return _ida_typeinf.choose_named_type(*args)

def choose_local_tinfo(*args):
  """
  choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32


  Choose a type from the local type library.
  
  @param ti: pointer to til (C++: const  til_t  *)
  @param title: title of listbox to display (C++: const char *)
  @param func: predicate to select types to display (maybe NULL) (C++:
               local_tinfo_predicate_t  *)
  @param def_ord: ordinal to position cursor before choose (C++: uint32)
  @param ud: user data (C++: void *)
  @return: == 0 means nothing is chosen, otherwise an ordinal number
  """
  return _ida_typeinf.choose_local_tinfo(*args)

def idc_parse_decl(*args):
  """
  idc_parse_decl(ti, decl, flags) -> PyObject *
  """
  return _ida_typeinf.idc_parse_decl(*args)

def calc_type_size(*args):
  """
  calc_type_size(ti, tp) -> PyObject *


  Returns the size of a type
  @param ti: Type info. 'None' can be passed.
  @param tp: type string
  @return:
      - None on failure
      - The size of the type
  """
  return _ida_typeinf.calc_type_size(*args)

def apply_type(*args):
  """
  apply_type(ti, py_type, py_fields, ea, flags) -> bool


  Apply the specified type to the address
  @param ti: Type info library. 'None' can be used.
  @param py_type: type string
  @param py_fields: fields string (may be empty or None)
  @param ea: the address of the object
  @param flags: combination of TINFO_... constants or 0
  @return: Boolean
  """
  return _ida_typeinf.apply_type(*args)

def get_arg_addrs(*args):
  """
  get_arg_addrs(caller) -> PyObject *


  Retrieve addresses of argument initialization instructions
  
  @param caller: the address of the call instruction
  @return: list of instruction addresses
  """
  return _ida_typeinf.get_arg_addrs(*args)

def unpack_object_from_idb(*args):
  """
  unpack_object_from_idb(ti, py_type, py_fields, ea, pio_flags=0) -> PyObject *
  """
  return _ida_typeinf.unpack_object_from_idb(*args)

def unpack_object_from_bv(*args):
  """
  unpack_object_from_bv(ti, py_type, py_fields, py_bytes, pio_flags=0) -> PyObject *


  Unpacks a buffer into an object.
  Returns the error_t returned by idaapi.pack_object_to_idb
  @param ti: Type info. 'None' can be passed.
  @param tp: type string
  @param fields: fields string (may be empty or None)
  @param bytes: the bytes to unpack
  @param pio_flags: flags used while unpacking
  @return:
      - tuple(0, err) on failure
      - tuple(1, obj) on success
  """
  return _ida_typeinf.unpack_object_from_bv(*args)

def pack_object_to_idb(*args):
  """
  pack_object_to_idb(py_obj, ti, py_type, py_fields, ea, pio_flags=0) -> PyObject *


  Write a typed object to the database.
  Raises an exception if wrong parameters were passed or conversion fails
  Returns the error_t returned by idaapi.pack_object_to_idb
  @param ti: Type info. 'None' can be passed.
  @param tp: type string
  @param fields: fields string (may be empty or None)
  @param ea: ea to be used while packing
  @param pio_flags: flags used while unpacking
  """
  return _ida_typeinf.pack_object_to_idb(*args)

def pack_object_to_bv(*args):
  """
  pack_object_to_bv(py_obj, ti, py_type, py_fields, base_ea, pio_flags=0) -> PyObject *


  Packs a typed object to a string
  @param ti: Type info. 'None' can be passed.
  @param tp: type string
  @param fields: fields string (may be empty or None)
  @param base_ea: base ea used to relocate the pointers in the packed object
  @param pio_flags: flags used while unpacking
  @return:
      tuple(0, err_code) on failure
      tuple(1, packed_buf) on success
  """
  return _ida_typeinf.pack_object_to_bv(*args)

def idc_parse_types(*args):
  """
  idc_parse_types(input, flags) -> int
  """
  return _ida_typeinf.idc_parse_types(*args)

def idc_get_type_raw(*args):
  """
  idc_get_type_raw(ea) -> PyObject *
  """
  return _ida_typeinf.idc_get_type_raw(*args)

def idc_get_local_type_raw(*args):
  """
  idc_get_local_type_raw(ordinal) -> PyObject *
  """
  return _ida_typeinf.idc_get_local_type_raw(*args)

def idc_guess_type(*args):
  """
  idc_guess_type(ea) -> char *
  """
  return _ida_typeinf.idc_guess_type(*args)

def idc_get_type(*args):
  """
  idc_get_type(ea) -> char *
  """
  return _ida_typeinf.idc_get_type(*args)

def idc_set_local_type(*args):
  """
  idc_set_local_type(ordinal, dcl, flags) -> int
  """
  return _ida_typeinf.idc_set_local_type(*args)

def idc_get_local_type(*args):
  """
  idc_get_local_type(ordinal, flags, buf, maxsize) -> int
  """
  return _ida_typeinf.idc_get_local_type(*args)

def idc_print_type(*args):
  """
  idc_print_type(py_type, py_fields, name, flags) -> PyObject *
  """
  return _ida_typeinf.idc_print_type(*args)

def idc_get_local_type_name(*args):
  """
  idc_get_local_type_name(ordinal) -> char
  """
  return _ida_typeinf.idc_get_local_type_name(*args)

def get_named_type(*args):
  """
  get_named_type(til, name, ntf_flags) -> PyObject *


  Get a type data by its name.
  @param til: the type library
  @param name: the type name
  @param ntf_flags: a combination of NTF_* constants
  @return:
      None on failure
      tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success
  """
  return _ida_typeinf.get_named_type(*args)

def get_named_type64(*args):
  """
  get_named_type64(til, name, ntf_flags) -> PyObject *


  See 'get_named_type()' above.If the value in the 'ti' library is
  32-bit, it will be sign-extended before being stored in the 'value'
  pointer.
  
  @param name (C++: const char *)
  @param ntf_flags (C++: int)
  """
  return _ida_typeinf.get_named_type64(*args)

def print_decls(*args):
  """
  print_decls(printer, til, py_ordinals, flags) -> int


  Print types (and possibly their dependencies) in a format suitable for
  use in a header file. This is the reverse 'parse_decls()' .
  
  @param printer: a handler for printing text (C++: text_sink_t  &)
  @param til: the type library holding the ordinals (C++: til_t  *)
  @param flags: flags for the algorithm. A combination of PDF_*
                constants (C++: uint32)
  """
  return _ida_typeinf.print_decls(*args)

def load_til(*args):
  """
  load_til(name, tildir) -> til_t


  Load til from a file. Failure to load base tils are reported into
  'errbuf'. They do not prevent loading of the main til.
  
  @param name: filename of the til. If it's an absolute path, tildir is
               ignored.   NB: the file extension is forced to .til (C++:
               const char *)
  @param tildir: directory where to load the til from. NULL means
                 default til subdirectories. (C++: const char *)
  @return: pointer to resulting til, NULL if failed and error message is
           in errbuf
  """
  return _ida_typeinf.load_til(*args)

def load_til_header(*args):
  """
  load_til_header(tildir, name) -> til_t


  Get human-readable til description.
  
  
  @param tildir (C++: const char *)
  @param name (C++: const char *)
  """
  return _ida_typeinf.load_til_header(*args)

def remove_tinfo_pointer(*args):
  """
  remove_tinfo_pointer(tif, name, til) -> PyObject *


  Remove pointer of a type. (i.e. convert "char *" into "char").
  Optionally remove the "lp" (or similar) prefix of the input name. If
  the input type is not a pointer, then fail.
  
  @param tif (C++: tinfo_t  *)
  @param til (C++: const  til_t  *)
  """
  return _ida_typeinf.remove_tinfo_pointer(*args)

def get_numbered_type(*args):
  """
  get_numbered_type(til, ordinal) -> PyObject *


  Retrieve a type by its ordinal number.
  
  
  @param ordinal (C++: uint32)
  """
  return _ida_typeinf.get_numbered_type(*args)
#<pycode(py_typeinf)>

import ida_idaapi
ida_idaapi._listify_types(
    reginfovec_t)

#</pycode(py_typeinf)>

if _BC695:
    BFI_NOCONST=0
    BFI_NOLOCS=0
    NTF_NOIDB=0
    PRVLOC_STKOFF=PRALOC_VERIFY
    PRVLOC_VERIFY=PRALOC_STKOFF
    TERR_TOOLONGNAME=TERR_WRONGNAME
    @bc695redef
    def add_til(name, flags=0):
        return _ida_typeinf.add_til(name, flags)
    add_til2=add_til
    def apply_decl(arg0, arg1, arg2=None, arg3=0):
        if type(arg0) in [int, long]: # old apply_cdecl()
            return _ida_typeinf.apply_cdecl(cvar.idati, arg0, arg1, 0)
        else:
            assert(arg2 is not None)
            return _ida_typeinf.apply_cdecl(arg0, arg1, arg2, arg3)
    apply_cdecl2=apply_decl
    apply_tinfo2=apply_tinfo
    calc_c_cpp_name4=calc_c_cpp_name
    import ida_idaapi
    callregs_init_regs=ida_idaapi._BC695.dummy
    choose_local_type=choose_local_tinfo
    def choose_named_type2(root_til, title, ntf_flags, func, out_sym):
        class func_pred_t(predicate_t):
            def __init__(self, func):
                predicate_t.__init__(self)
                self.func = func
            def should_display(self, til, name, tp, flds):
                return self.func(name, tp, flds)
        fp = func_pred_t(func)
        return choose_named_type(out_sym, root_til, title, ntf_flags, fp)
    deref_ptr2=deref_ptr
    extract_varloc=extract_argloc
    const_vloc_visitor_t=const_aloc_visitor_t
    for_all_const_varlocs=for_all_const_arglocs
    for_all_varlocs=for_all_arglocs
    def gen_decorate_name3(name, mangle, cc):
        return gen_decorate_name(name, mangle, cc, None) # ATM gen_decorate_name doesn't use its tinfo_t
    get_enum_member_expr2=get_enum_member_expr
    get_idainfo_by_type3=get_idainfo_by_type
    def guess_func_tinfo2(pfn, tif):
        return guess_tinfo(pfn.start_ea, tif)
    @bc695redef
    def load_til(name, tildir=None, *args):
        # 6.95 C++ prototypes
        # idaman til_t *ida_export load_til(const char *tildir, const char *name, char *errbuf, size_t bufsize);
        # idaman til_t *ida_export load_til2(                   const char *name, char *errbuf, size_t bufsize);
        #
        # 6.95 Python prototypes
        # load_til(tildir, name)
        # load_til(tildir, name, errbuf, bufsize)
        # load_til2(name, errbuf, bufsize=0)
        #
        # -> it's virtually impossible to tell whether it's load_til2(),
        # or load_til() that's called since they both take 2 first string
        # arguments. We'll rely the contents of those strings...
        if name is None or name == "": # load_til(), with an empty tildir
            name = tildir
            tildir = ""
            return _ida_typeinf.load_til(name, tildir)
        else:
            return _ida_typeinf.load_til(name, tildir)
    load_til2=load_til
    lower_type2=lower_type
    optimize_varloc=optimize_argloc
    def parse_decl2(til, decl, tif, flags):
        return _ida_typeinf.parse_decl(tif, til, decl, flags)
    @bc695redef
    def print_type(ea, flags):
        if isinstance(flags, bool):
            flags = PRTYPE_1LINE if flags else 0
        return _ida_typeinf.print_type(ea, flags)
    def print_type2(ea, flags):
        return _ida_typeinf.print_type(ea, flags)
    print_type3=_ida_typeinf.print_type
    print_varloc=print_argloc
    def resolve_typedef2(til, p, *args):
        return _ida_typeinf.resolve_typedef(til, p)
    scattered_vloc_t=scattered_aloc_t
    set_compiler2=set_compiler
    varloc_t=argloc_t
    varpart_t=argpart_t
    verify_varloc=verify_argloc
    vloc_visitor_t=aloc_visitor_t
    def guess_tinfo(*args):
        if isinstance(args[1], tinfo_t): # 6.95: id, tinfo_t
            tid, tif = args
        else:                            # 7.00: tinfo_t, id
            tif, tid = args
        return _ida_typeinf.guess_tinfo(tif, tid)
    guess_tinfo2=guess_tinfo
    def find_tinfo_udt_member(*args):
        if isinstance(args[2], udt_member_t): # 6.95: typid, strmem_flags, udm
              typid, strmem_flags, udm = args
        else:                                 # 7.00: udm, typid, strmem_flags
              udm, typid, strmem_flags = args
        return _ida_typeinf.find_tinfo_udt_member(udm, typid, strmem_flags)
    def __tinfo_t_find_udt_member(self, *args):
        if isinstance(args[1], udt_member_t): # 6.95: strmem_flags, udm
              strmem_flags, udm = args
        else:                                 # 7.00: udm, strmem_flags
              udm, strmem_flags = args
        return _ida_typeinf.tinfo_t_find_udt_member(self, udm, strmem_flags)
    tinfo_t.find_udt_member=__tinfo_t_find_udt_member
    def save_tinfo(*args):
        if isinstance(args[4], tinfo_t): # 6.95: til_t, size_t, name, int, tinfo_t
            til, _ord, name, ntf_flags, tif = args
        else:                            # 7.00: tinfo_t, til_t, size_t, name, int
            tif, til, _ord, name, ntf_flags = args
        return _ida_typeinf.save_tinfo(tif, til, _ord, name, ntf_flags)



