# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: funcs
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_funcs', [dirname(__file__)])
        except ImportError:
            import _ida_funcs
            return _ida_funcs
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_funcs', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_funcs = swig_import_helper()
    del swig_import_helper
else:
    import _ida_funcs
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
class stkpnt_array(object):
    """
    Proxy of C++ dynamic_wrapped_array_t<(stkpnt_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_ida_funcs.stkpnt_array_data_get)
    count = _swig_property(_ida_funcs.stkpnt_array_count_get)
    def __init__(self, *args):
        """
        __init__(self, _data, _count) -> stkpnt_array
        """
        this = _ida_funcs.new_stkpnt_array(*args)
        try: self.this.append(this)
        except: self.this = this
    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_funcs.stkpnt_array___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> stkpnt_t const &
        """
        return _ida_funcs.stkpnt_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_funcs.stkpnt_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_funcs.delete_stkpnt_array
    __del__ = lambda self : None;
stkpnt_array_swigregister = _ida_funcs.stkpnt_array_swigregister
stkpnt_array_swigregister(stkpnt_array)

class regvar_array(object):
    """
    Proxy of C++ dynamic_wrapped_array_t<(regvar_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_ida_funcs.regvar_array_data_get)
    count = _swig_property(_ida_funcs.regvar_array_count_get)
    def __init__(self, *args):
        """
        __init__(self, _data, _count) -> regvar_array
        """
        this = _ida_funcs.new_regvar_array(*args)
        try: self.this.append(this)
        except: self.this = this
    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_funcs.regvar_array___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> regvar_t const &
        """
        return _ida_funcs.regvar_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_funcs.regvar_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_funcs.delete_regvar_array
    __del__ = lambda self : None;
regvar_array_swigregister = _ida_funcs.regvar_array_swigregister
regvar_array_swigregister(regvar_array)

class range_array(object):
    """
    Proxy of C++ dynamic_wrapped_array_t<(range_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_ida_funcs.range_array_data_get)
    count = _swig_property(_ida_funcs.range_array_count_get)
    def __init__(self, *args):
        """
        __init__(self, _data, _count) -> range_array
        """
        this = _ida_funcs.new_range_array(*args)
        try: self.this.append(this)
        except: self.this = this
    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_funcs.range_array___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> range_t
        """
        return _ida_funcs.range_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_funcs.range_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_funcs.delete_range_array
    __del__ = lambda self : None;
range_array_swigregister = _ida_funcs.range_array_swigregister
range_array_swigregister(range_array)

class regarg_t(object):
    """
    Proxy of C++ regarg_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    reg = _swig_property(_ida_funcs.regarg_t_reg_get, _ida_funcs.regarg_t_reg_set)
    type = _swig_property(_ida_funcs.regarg_t_type_get, _ida_funcs.regarg_t_type_set)
    name = _swig_property(_ida_funcs.regarg_t_name_get, _ida_funcs.regarg_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> regarg_t
        """
        this = _ida_funcs.new_regarg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_funcs.delete_regarg_t
    __del__ = lambda self : None;
regarg_t_swigregister = _ida_funcs.regarg_t_swigregister
regarg_t_swigregister(regarg_t)

class func_t(ida_range.range_t):
    """
    Proxy of C++ func_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flags = _swig_property(_ida_funcs.func_t_flags_get, _ida_funcs.func_t_flags_set)
    def is_far(self, *args):
        """
        is_far(self) -> bool
        """
        return _ida_funcs.func_t_is_far(self, *args)

    def does_return(self, *args):
        """
        does_return(self) -> bool
        """
        return _ida_funcs.func_t_does_return(self, *args)

    def analyzed_sp(self, *args):
        """
        analyzed_sp(self) -> bool
        """
        return _ida_funcs.func_t_analyzed_sp(self, *args)

    def need_prolog_analysis(self, *args):
        """
        need_prolog_analysis(self) -> bool
        """
        return _ida_funcs.func_t_need_prolog_analysis(self, *args)

    frame = _swig_property(_ida_funcs.func_t_frame_get, _ida_funcs.func_t_frame_set)
    frsize = _swig_property(_ida_funcs.func_t_frsize_get, _ida_funcs.func_t_frsize_set)
    frregs = _swig_property(_ida_funcs.func_t_frregs_get, _ida_funcs.func_t_frregs_set)
    argsize = _swig_property(_ida_funcs.func_t_argsize_get, _ida_funcs.func_t_argsize_set)
    fpd = _swig_property(_ida_funcs.func_t_fpd_get, _ida_funcs.func_t_fpd_set)
    color = _swig_property(_ida_funcs.func_t_color_get, _ida_funcs.func_t_color_set)
    pntqty = _swig_property(_ida_funcs.func_t_pntqty_get, _ida_funcs.func_t_pntqty_set)
    points = _swig_property(_ida_funcs.func_t_points_get, _ida_funcs.func_t_points_set)
    regvarqty = _swig_property(_ida_funcs.func_t_regvarqty_get, _ida_funcs.func_t_regvarqty_set)
    regvars = _swig_property(_ida_funcs.func_t_regvars_get, _ida_funcs.func_t_regvars_set)
    llabelqty = _swig_property(_ida_funcs.func_t_llabelqty_get, _ida_funcs.func_t_llabelqty_set)
    llabels = _swig_property(_ida_funcs.func_t_llabels_get, _ida_funcs.func_t_llabels_set)
    regargqty = _swig_property(_ida_funcs.func_t_regargqty_get, _ida_funcs.func_t_regargqty_set)
    regargs = _swig_property(_ida_funcs.func_t_regargs_get, _ida_funcs.func_t_regargs_set)
    tailqty = _swig_property(_ida_funcs.func_t_tailqty_get, _ida_funcs.func_t_tailqty_set)
    tails = _swig_property(_ida_funcs.func_t_tails_get, _ida_funcs.func_t_tails_set)
    owner = _swig_property(_ida_funcs.func_t_owner_get, _ida_funcs.func_t_owner_set)
    refqty = _swig_property(_ida_funcs.func_t_refqty_get, _ida_funcs.func_t_refqty_set)
    referers = _swig_property(_ida_funcs.func_t_referers_get, _ida_funcs.func_t_referers_set)
    def __init__(self, *args):
        """
        __init__(self, start=0, end=0, f=0) -> func_t
        """
        this = _ida_funcs.new_func_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __get_points__(self, *args):
        """
        __get_points__(self) -> stkpnt_array
        """
        return _ida_funcs.func_t___get_points__(self, *args)

    def __get_regvars__(self, *args):
        """
        __get_regvars__(self) -> regvar_array
        """
        return _ida_funcs.func_t___get_regvars__(self, *args)

    def __get_tails__(self, *args):
        """
        __get_tails__(self) -> range_array
        """
        return _ida_funcs.func_t___get_tails__(self, *args)

    points = property(__get_points__)
    regvars = property(__get_regvars__)
    tails = property(__get_tails__)

    __swig_destroy__ = _ida_funcs.delete_func_t
    __del__ = lambda self : None;
func_t_swigregister = _ida_funcs.func_t_swigregister
func_t_swigregister(func_t)
FUNC_NORET = _ida_funcs.FUNC_NORET
"""
Function doesn't return.
"""
FUNC_FAR = _ida_funcs.FUNC_FAR
"""
Far function.
"""
FUNC_LIB = _ida_funcs.FUNC_LIB
"""
Library function.
"""
FUNC_STATICDEF = _ida_funcs.FUNC_STATICDEF
"""
Static function.
"""
FUNC_FRAME = _ida_funcs.FUNC_FRAME
"""
Function uses frame pointer (BP)
"""
FUNC_USERFAR = _ida_funcs.FUNC_USERFAR
"""
of the function

User has specified far-ness
"""
FUNC_HIDDEN = _ida_funcs.FUNC_HIDDEN
"""
A hidden function chunk.
"""
FUNC_THUNK = _ida_funcs.FUNC_THUNK
"""
Thunk (jump) function.
"""
FUNC_BOTTOMBP = _ida_funcs.FUNC_BOTTOMBP
"""
BP points to the bottom of the stack frame.
"""
FUNC_NORET_PENDING = _ida_funcs.FUNC_NORET_PENDING
"""
This flag is verified upon 'func_does_return()'

Function 'non-return' analysis must be performed.
"""
FUNC_SP_READY = _ida_funcs.FUNC_SP_READY
"""
SP-analysis has been performed. If this flag is on, the stack change
points should not be not modified anymore. Currently this analysis is
performed only for PC
"""
FUNC_FUZZY_SP = _ida_funcs.FUNC_FUZZY_SP
"""
for example: and esp, 0FFFFFFF0h

Function changes SP in untraceable way,
"""
FUNC_PROLOG_OK = _ida_funcs.FUNC_PROLOG_OK
"""
by last SP-analysis

Prolog analysis has be performed
"""
FUNC_PURGED_OK = _ida_funcs.FUNC_PURGED_OK
"""
'argsize' field has been validated. If this bit is clear and 'argsize'
is 0, then we do not known the real number of bytes removed from the
stack. This bit is handled by the processor module.
"""
FUNC_TAIL = _ida_funcs.FUNC_TAIL
"""
This is a function tail. Other bits must be clear (except
'FUNC_HIDDEN' ).
"""
FUNC_LUMINA = _ida_funcs.FUNC_LUMINA
"""
Function info is provided by Lumina.
"""


def is_func_entry(*args):
  """
  is_func_entry(pfn) -> bool


  Does function describe a function entry chunk?
  
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.is_func_entry(*args)

def is_func_tail(*args):
  """
  is_func_tail(pfn) -> bool


  Does function describe a function tail chunk?
  
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.is_func_tail(*args)

def lock_func_range(*args):
  """
  lock_func_range(pfn, lock)


  Lock function pointer Locked pointers are guaranteed to remain valid
  until they are unlocked. Ranges with locked pointers cannot be deleted
  or moved.
  
  @param pfn (C++: const  func_t  *)
  @param lock (C++: bool)
  """
  return _ida_funcs.lock_func_range(*args)
class lock_func(object):
    """
    Proxy of C++ lock_func class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _pfn) -> lock_func
        """
        this = _ida_funcs.new_lock_func(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_funcs.delete_lock_func
    __del__ = lambda self : None;
lock_func_swigregister = _ida_funcs.lock_func_swigregister
lock_func_swigregister(lock_func)


def is_func_locked(*args):
  """
  is_func_locked(pfn) -> bool


  Is the function pointer locked?
  
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.is_func_locked(*args)

def get_func(*args):
  """
  get_func(ea) -> func_t


  Get pointer to function structure by address.
  
  @param ea: any address in a function (C++: ea_t)
  @return: ptr to a function or NULL. This function returns a function
           entry chunk.
  """
  return _ida_funcs.get_func(*args)

def get_func_chunknum(*args):
  """
  get_func_chunknum(pfn, ea) -> int


  Get the containing tail chunk of 'ea'.
  
  @param pfn (C++: func_t  *)
  @param ea (C++: ea_t)
  """
  return _ida_funcs.get_func_chunknum(*args)

def func_contains(*args):
  """
  func_contains(pfn, ea) -> bool


  Does the given function contain the given address?
  
  
  @param pfn (C++: func_t  *)
  @param ea (C++: ea_t)
  """
  return _ida_funcs.func_contains(*args)

def is_same_func(*args):
  """
  is_same_func(ea1, ea2) -> bool


  Do two addresses belong to the same function?
  
  
  @param ea1 (C++: ea_t)
  @param ea2 (C++: ea_t)
  """
  return _ida_funcs.is_same_func(*args)

def getn_func(*args):
  """
  getn_func(n) -> func_t


  Get pointer to function structure by number.
  
  @param n: number of function, is in range 0.. get_func_qty() -1 (C++:
            size_t)
  @return: ptr to a function or NULL. This function returns a function
           entry chunk.
  """
  return _ida_funcs.getn_func(*args)

def get_func_qty(*args):
  """
  get_func_qty() -> size_t


  Get total number of functions in the program.
  """
  return _ida_funcs.get_func_qty(*args)

def get_func_num(*args):
  """
  get_func_num(ea) -> int


  Get ordinal number of a function.
  
  @param ea: any address in the function (C++: ea_t)
  @return: number of function (0.. get_func_qty() -1). -1 means 'no
           function at the specified address'.
  """
  return _ida_funcs.get_func_num(*args)

def get_prev_func(*args):
  """
  get_prev_func(ea) -> func_t


  Get pointer to the previous function.
  
  @param ea: any address in the program (C++: ea_t)
  @return: ptr to function or NULL if previous function doesn't exist
  """
  return _ida_funcs.get_prev_func(*args)

def get_next_func(*args):
  """
  get_next_func(ea) -> func_t


  Get pointer to the next function.
  
  @param ea: any address in the program (C++: ea_t)
  @return: ptr to function or NULL if next function doesn't exist
  """
  return _ida_funcs.get_next_func(*args)

def get_func_ranges(*args):
  """
  get_func_ranges(ranges, pfn) -> ea_t


  Get function ranges.
  
  @param ranges: buffer to receive the range info (C++: rangeset_t  *)
  @param pfn: ptr to function structure (C++: func_t  *)
  @return: end address of the last function range (BADADDR-error)
  """
  return _ida_funcs.get_func_ranges(*args)

def get_func_cmt(*args):
  """
  get_func_cmt(pfn, repeatable) -> ssize_t


  Get function comment.
  
  @param pfn: ptr to function structure (C++: const  func_t  *)
  @param repeatable: get repeatable comment? (C++: bool)
  @return: size of comment or -1 In fact this function works with
           function chunks too.
  """
  return _ida_funcs.get_func_cmt(*args)

def set_func_cmt(*args):
  """
  set_func_cmt(pfn, cmt, repeatable) -> bool


  Set function comment. This function works with function chunks too.
  
  @param pfn: ptr to function structure (C++: const  func_t  *)
  @param cmt: comment string, may be multiline (with '  '). Use empty
              str ("") to delete comment (C++: const char *)
  @param repeatable: set repeatable comment? (C++: bool)
  """
  return _ida_funcs.set_func_cmt(*args)

def update_func(*args):
  """
  update_func(pfn) -> bool


  Update information about a function in the database ( 'func_t' ). You
  must not change the function start and end addresses using this
  function. Use 'set_func_start()' and 'set_func_end()' for it.
  
  @param pfn: ptr to function structure (C++: func_t  *)
  @return: success
  """
  return _ida_funcs.update_func(*args)

def add_func_ex(*args):
  """
  add_func_ex(pfn) -> bool


  Add a new function. If the fn->end_ea is 'BADADDR' , then IDA will try
  to determine the function bounds by calling find_func_bounds(...,
  'FIND_FUNC_DEFINE' ).
  
  @param pfn: ptr to filled function structure (C++: func_t  *)
  @return: success
  """
  return _ida_funcs.add_func_ex(*args)

def add_func(*args):
  """
  add_func(ea1, ea2=BADADDR) -> bool


  Add a new function. If the function end address is 'BADADDR' , then
  IDA will try to determine the function bounds by calling
  find_func_bounds(..., 'FIND_FUNC_DEFINE' ).
  
  @param ea1: start address (C++: ea_t)
  @param ea2: end address (C++: ea_t)
  @return: success
  """
  return _ida_funcs.add_func(*args)

def del_func(*args):
  """
  del_func(ea) -> bool


  Delete a function.
  
  @param ea: any address in the function entry chunk (C++: ea_t)
  @return: success
  """
  return _ida_funcs.del_func(*args)

def set_func_start(*args):
  """
  set_func_start(ea, newstart) -> int


  Move function chunk start address.
  
  @param ea: any address in the function (C++: ea_t)
  @param newstart: new end address of the function (C++: ea_t)
  @return: Function move result codes
  """
  return _ida_funcs.set_func_start(*args)
MOVE_FUNC_OK = _ida_funcs.MOVE_FUNC_OK
"""
ok
"""
MOVE_FUNC_NOCODE = _ida_funcs.MOVE_FUNC_NOCODE
"""
no instruction at 'newstart'
"""
MOVE_FUNC_BADSTART = _ida_funcs.MOVE_FUNC_BADSTART
"""
bad new start address
"""
MOVE_FUNC_NOFUNC = _ida_funcs.MOVE_FUNC_NOFUNC
"""
no function at 'ea'
"""
MOVE_FUNC_REFUSED = _ida_funcs.MOVE_FUNC_REFUSED
"""
a plugin refused the action
"""

def set_func_end(*args):
  """
  set_func_end(ea, newend) -> bool


  Move function chunk end address.
  
  @param ea: any address in the function (C++: ea_t)
  @param newend: new end address of the function (C++: ea_t)
  @return: success
  """
  return _ida_funcs.set_func_end(*args)

def reanalyze_function(*args):
  """
  reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)


  Reanalyze a function. This function plans to analyzes all chunks of
  the given function. Optional parameters (ea1, ea2) may be used to
  narrow the analyzed range.
  
  @param pfn: pointer to a function (C++: func_t  *)
  @param ea1: start of the range to analyze (C++: ea_t)
  @param ea2: end of range to analyze (C++: ea_t)
  @param analyze_parents: meaningful only if pfn points to a function
                          tail. if true, all tail parents will be
                          reanalyzed. if false, only the given tail will
                          be reanalyzed. (C++: bool)
  """
  return _ida_funcs.reanalyze_function(*args)

def find_func_bounds(*args):
  """
  find_func_bounds(nfn, flags) -> int


  Determine the boundaries of a new function. This function tries to
  find the start and end addresses of a new function. It calls the
  module with \ph{func_bounds} in order to fine tune the function
  boundaries.
  
  @param nfn: structure to fill with information \ nfn->start_ea points
              to the start address of the new function. (C++: func_t  *)
  @param flags: Find function bounds flags (C++: int)
  @return: Find function bounds result codes
  """
  return _ida_funcs.find_func_bounds(*args)
FIND_FUNC_NORMAL = _ida_funcs.FIND_FUNC_NORMAL
"""
stop processing if undefined byte is encountered
"""
FIND_FUNC_DEFINE = _ida_funcs.FIND_FUNC_DEFINE
"""
create instruction if undefined byte is encountered
"""
FIND_FUNC_IGNOREFN = _ida_funcs.FIND_FUNC_IGNOREFN
"""
ignore existing function boundaries. by default the function returns
function boundaries if ea belongs to a function.
"""
FIND_FUNC_KEEPBD = _ida_funcs.FIND_FUNC_KEEPBD
"""
just create instructions inside the boundaries.

do not modify incoming function boundaries,
"""
FIND_FUNC_UNDEF = _ida_funcs.FIND_FUNC_UNDEF
"""
nfn->end_ea will have the address of the unexplored byte.

function has instructions that pass execution flow to unexplored
bytes.
"""
FIND_FUNC_OK = _ida_funcs.FIND_FUNC_OK
"""
ok, 'nfn' is ready for 'add_func()'
"""
FIND_FUNC_EXIST = _ida_funcs.FIND_FUNC_EXIST
"""
its bounds are returned in 'nfn'.

function exists already.
"""

def get_func_name(*args):
  """
  get_func_name(ea) -> ssize_t


  Get function name.
  
  @param ea: any address in the function (C++: ea_t)
  @return: length of the function name
  """
  return _ida_funcs.get_func_name(*args)

def calc_func_size(*args):
  """
  calc_func_size(pfn) -> asize_t


  Calculate function size. This function takes into account all
  fragments of the function.
  
  @param pfn: ptr to function structure (C++: func_t  *)
  """
  return _ida_funcs.calc_func_size(*args)

def get_func_bitness(*args):
  """
  get_func_bitness(pfn) -> int


  Get function bitness (which is equal to the function segment bitness).
  pfn==NULL => returns 0
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.get_func_bitness(*args)

def get_func_bits(*args):
  """
  get_func_bits(pfn) -> int


  Get number of bits in the function addressing.
  
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.get_func_bits(*args)

def get_func_bytes(*args):
  """
  get_func_bytes(pfn) -> int


  Get number of bytes in the function addressing.
  
  
  @param pfn (C++: const  func_t  *)
  """
  return _ida_funcs.get_func_bytes(*args)

def is_visible_func(*args):
  """
  is_visible_func(pfn) -> bool


  Is the function visible (not hidden)?
  
  
  @param pfn (C++: func_t  *)
  """
  return _ida_funcs.is_visible_func(*args)

def is_finally_visible_func(*args):
  """
  is_finally_visible_func(pfn) -> bool


  Is the function visible (event after considering 'SCF_SHHID_FUNC' )?
  
  
  @param pfn (C++: func_t  *)
  """
  return _ida_funcs.is_finally_visible_func(*args)

def set_visible_func(*args):
  """
  set_visible_func(pfn, visible)


  Set visibility of function.
  
  
  @param pfn (C++: func_t  *)
  @param visible (C++: bool)
  """
  return _ida_funcs.set_visible_func(*args)

def set_func_name_if_jumpfunc(*args):
  """
  set_func_name_if_jumpfunc(pfn, oldname) -> int


  Give a meaningful name to function if it consists of only 'jump'
  instruction.
  
  @param pfn: pointer to function (may be NULL) (C++: func_t  *)
  @param oldname: old name of function. if old name was in "j_..." form,
                  then we may discard it and set a new name. if oldname
                  is not known, you may pass NULL. (C++: const char *)
  @return: success
  """
  return _ida_funcs.set_func_name_if_jumpfunc(*args)

def calc_thunk_func_target(*args):
  """
  calc_thunk_func_target(pfn) -> ea_t


  Calculate target of a thunk function.
  
  @param pfn: pointer to function (may not be NULL) (C++: func_t  *)
  @return: the target function or  BADADDR
  """
  return _ida_funcs.calc_thunk_func_target(*args)

def func_does_return(*args):
  """
  func_does_return(callee) -> bool


  Does the function return?. To calculate the answer, 'FUNC_NORET' flag
  and is_noret() are consulted The latter is required for imported
  functions in the .idata section. Since in .idata we have only function
  pointers but not functions, we have to introduce a special flag for
  them.
  
  @param callee (C++: ea_t)
  """
  return _ida_funcs.func_does_return(*args)

def reanalyze_noret_flag(*args):
  """
  reanalyze_noret_flag(ea) -> bool


  Plan to reanalyze noret flag. This function does not remove FUNC_NORET
  if it is already present. It just plans to reanalysis.
  
  @param ea (C++: ea_t)
  """
  return _ida_funcs.reanalyze_noret_flag(*args)

def set_noret_insn(*args):
  """
  set_noret_insn(insn_ea, noret) -> bool


  Signal a non-returning instruction. This function can be used by the
  processor module to tell the kernel about non-returning instructions
  (like call exit). The kernel will perform the global function analysis
  and find out if the function returns at all. This analysis will be
  done at the first call to 'func_does_return()'
  
  @param insn_ea (C++: ea_t)
  @param noret (C++: bool)
  @return: true if the instruction 'noret' flag has been changed
  """
  return _ida_funcs.set_noret_insn(*args)

def get_fchunk(*args):
  """
  get_fchunk(ea) -> func_t


  Get pointer to function chunk structure by address.
  
  @param ea: any address in a function chunk (C++: ea_t)
  @return: ptr to a function chunk or NULL. This function may return a
           function entry as well as a function tail.
  """
  return _ida_funcs.get_fchunk(*args)

def getn_fchunk(*args):
  """
  getn_fchunk(n) -> func_t


  Get pointer to function chunk structure by number.
  
  @param n: number of function chunk, is in range 0.. get_fchunk_qty()
            -1 (C++: int)
  @return: ptr to a function chunk or NULL. This function may return a
           function entry as well as a function tail.
  """
  return _ida_funcs.getn_fchunk(*args)

def get_fchunk_qty(*args):
  """
  get_fchunk_qty() -> size_t


  Get total number of function chunks in the program.
  """
  return _ida_funcs.get_fchunk_qty(*args)

def get_fchunk_num(*args):
  """
  get_fchunk_num(ea) -> int


  Get ordinal number of a function chunk in the global list of function
  chunks.
  
  @param ea: any address in the function chunk (C++: ea_t)
  @return: number of function chunk (0.. get_fchunk_qty() -1). -1 means
           'no function chunk at the specified address'.
  """
  return _ida_funcs.get_fchunk_num(*args)

def get_prev_fchunk(*args):
  """
  get_prev_fchunk(ea) -> func_t


  Get pointer to the previous function chunk in the global list.
  
  @param ea: any address in the program (C++: ea_t)
  @return: ptr to function chunk or NULL if previous function chunk
           doesn't exist
  """
  return _ida_funcs.get_prev_fchunk(*args)

def get_next_fchunk(*args):
  """
  get_next_fchunk(ea) -> func_t


  Get pointer to the next function chunk in the global list.
  
  @param ea: any address in the program (C++: ea_t)
  @return: ptr to function chunk or NULL if next function chunk doesn't
           exist
  """
  return _ida_funcs.get_next_fchunk(*args)

def append_func_tail(*args):
  """
  append_func_tail(pfn, ea1, ea2) -> bool


  Append a new tail chunk to the function definition. If the tail
  already exists, then it will simply be added to the function tail list
  Otherwise a new tail will be created and its owner will be set to be
  our function If a new tail cannot be created, then this function will
  fail.
  
  @param pfn (C++: func_t  *)
  @param ea1: start of the tail. If a tail already exists at the
              specified address it must start at 'ea1' (C++: ea_t)
  @param ea2: end of the tail. If a tail already exists at the specified
              address it must end at 'ea2'. If specified as BADADDR, IDA
              will determine the end address itself. (C++: ea_t)
  """
  return _ida_funcs.append_func_tail(*args)

def remove_func_tail(*args):
  """
  remove_func_tail(pfn, tail_ea) -> bool


  Remove a function tail. If the tail belongs only to one function, it
  will be completely removed. Otherwise if the function was the tail
  owner, the first function using this tail becomes the owner of the
  tail.
  
  @param pfn (C++: func_t  *)
  @param tail_ea (C++: ea_t)
  """
  return _ida_funcs.remove_func_tail(*args)

def set_tail_owner(*args):
  """
  set_tail_owner(fnt, func_start) -> bool


  Set a function as the possessing function of a function tail. The
  function should already refer to the tail (after append_func_tail).
  
  @param fnt (C++: func_t  *)
  @param func_start (C++: ea_t)
  """
  return _ida_funcs.set_tail_owner(*args)

def func_tail_iterator_set(*args):
  """
  func_tail_iterator_set(fti, pfn, ea) -> bool
  """
  return _ida_funcs.func_tail_iterator_set(*args)

def func_tail_iterator_set_ea(*args):
  """
  func_tail_iterator_set_ea(fti, ea) -> bool
  """
  return _ida_funcs.func_tail_iterator_set_ea(*args)

def func_parent_iterator_set(*args):
  """
  func_parent_iterator_set(fpi, pfn) -> bool
  """
  return _ida_funcs.func_parent_iterator_set(*args)

def func_item_iterator_next(*args):
  """
  func_item_iterator_next(fii, testf, ud) -> bool
  """
  return _ida_funcs.func_item_iterator_next(*args)

def func_item_iterator_prev(*args):
  """
  func_item_iterator_prev(fii, testf, ud) -> bool
  """
  return _ida_funcs.func_item_iterator_prev(*args)

def func_item_iterator_decode_prev_insn(*args):
  """
  func_item_iterator_decode_prev_insn(fii, out) -> bool
  """
  return _ida_funcs.func_item_iterator_decode_prev_insn(*args)

def func_item_iterator_decode_preceding_insn(*args):
  """
  func_item_iterator_decode_preceding_insn(fii, visited, p_farref, out) -> bool
  """
  return _ida_funcs.func_item_iterator_decode_preceding_insn(*args)

def f_any(*args):
  """
  f_any(arg1, arg2) -> bool


  Helper function to accept any address.
  """
  return _ida_funcs.f_any(*args)
class func_tail_iterator_t(object):
    """
    Proxy of C++ func_tail_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> func_tail_iterator_t
        __init__(self, _pfn, ea=BADADDR) -> func_tail_iterator_t
        """
        this = _ida_funcs.new_func_tail_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_funcs.delete_func_tail_iterator_t
    __del__ = lambda self : None;
    def set(self, *args):
        """
        set(self, _pfn, ea=BADADDR) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_set(self, *args)

    def set_ea(self, *args):
        """
        set_ea(self, ea) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_set_ea(self, *args)

    def set_range(self, *args):
        """
        set_range(self, ea1, ea2) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_set_range(self, *args)

    def chunk(self, *args):
        """
        chunk(self) -> range_t
        """
        return _ida_funcs.func_tail_iterator_t_chunk(self, *args)

    def first(self, *args):
        """
        first(self) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_first(self, *args)

    def last(self, *args):
        """
        last(self) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_last(self, *args)

    def next(self, *args):
        """
        next(self) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_next(self, *args)

    def prev(self, *args):
        """
        prev(self) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_prev(self, *args)

    def main(self, *args):
        """
        main(self) -> bool
        """
        return _ida_funcs.func_tail_iterator_t_main(self, *args)

func_tail_iterator_t_swigregister = _ida_funcs.func_tail_iterator_t_swigregister
func_tail_iterator_t_swigregister(func_tail_iterator_t)

class func_item_iterator_t(object):
    """
    Proxy of C++ func_item_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> func_item_iterator_t
        __init__(self, pfn, _ea=BADADDR) -> func_item_iterator_t
        """
        this = _ida_funcs.new_func_item_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """
        set(self, pfn, _ea=BADADDR) -> bool
        """
        return _ida_funcs.func_item_iterator_t_set(self, *args)

    def set_range(self, *args):
        """
        set_range(self, ea1, ea2) -> bool
        """
        return _ida_funcs.func_item_iterator_t_set_range(self, *args)

    def first(self, *args):
        """
        first(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_first(self, *args)

    def last(self, *args):
        """
        last(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_last(self, *args)

    def current(self, *args):
        """
        current(self) -> ea_t
        """
        return _ida_funcs.func_item_iterator_t_current(self, *args)

    def chunk(self, *args):
        """
        chunk(self) -> range_t
        """
        return _ida_funcs.func_item_iterator_t_chunk(self, *args)

    def next(self, *args):
        """
        next(self, func, ud) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next(self, *args)

    def prev(self, *args):
        """
        prev(self, func, ud) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev(self, *args)

    def next_addr(self, *args):
        """
        next_addr(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next_addr(self, *args)

    def next_head(self, *args):
        """
        next_head(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next_head(self, *args)

    def next_code(self, *args):
        """
        next_code(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next_code(self, *args)

    def next_data(self, *args):
        """
        next_data(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next_data(self, *args)

    def next_not_tail(self, *args):
        """
        next_not_tail(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_next_not_tail(self, *args)

    def prev_addr(self, *args):
        """
        prev_addr(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev_addr(self, *args)

    def prev_head(self, *args):
        """
        prev_head(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev_head(self, *args)

    def prev_code(self, *args):
        """
        prev_code(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev_code(self, *args)

    def prev_data(self, *args):
        """
        prev_data(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev_data(self, *args)

    def prev_not_tail(self, *args):
        """
        prev_not_tail(self) -> bool
        """
        return _ida_funcs.func_item_iterator_t_prev_not_tail(self, *args)

    def decode_prev_insn(self, *args):
        """
        decode_prev_insn(self, out) -> bool
        """
        return _ida_funcs.func_item_iterator_t_decode_prev_insn(self, *args)

    def decode_preceding_insn(self, *args):
        """
        decode_preceding_insn(self, visited, p_farref, out) -> bool
        """
        return _ida_funcs.func_item_iterator_t_decode_preceding_insn(self, *args)

    __swig_destroy__ = _ida_funcs.delete_func_item_iterator_t
    __del__ = lambda self : None;
func_item_iterator_t_swigregister = _ida_funcs.func_item_iterator_t_swigregister
func_item_iterator_t_swigregister(func_item_iterator_t)

class func_parent_iterator_t(object):
    """
    Proxy of C++ func_parent_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> func_parent_iterator_t
        __init__(self, _fnt) -> func_parent_iterator_t
        """
        this = _ida_funcs.new_func_parent_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_funcs.delete_func_parent_iterator_t
    __del__ = lambda self : None;
    def set(self, *args):
        """
        set(self, _fnt) -> bool
        """
        return _ida_funcs.func_parent_iterator_t_set(self, *args)

    def parent(self, *args):
        """
        parent(self) -> ea_t
        """
        return _ida_funcs.func_parent_iterator_t_parent(self, *args)

    def first(self, *args):
        """
        first(self) -> bool
        """
        return _ida_funcs.func_parent_iterator_t_first(self, *args)

    def last(self, *args):
        """
        last(self) -> bool
        """
        return _ida_funcs.func_parent_iterator_t_last(self, *args)

    def next(self, *args):
        """
        next(self) -> bool
        """
        return _ida_funcs.func_parent_iterator_t_next(self, *args)

    def prev(self, *args):
        """
        prev(self) -> bool
        """
        return _ida_funcs.func_parent_iterator_t_prev(self, *args)

    def reset_fnt(self, *args):
        """
        reset_fnt(self, _fnt)
        """
        return _ida_funcs.func_parent_iterator_t_reset_fnt(self, *args)

func_parent_iterator_t_swigregister = _ida_funcs.func_parent_iterator_t_swigregister
func_parent_iterator_t_swigregister(func_parent_iterator_t)


def get_prev_func_addr(*args):
  """
  get_prev_func_addr(pfn, ea) -> ea_t
  """
  return _ida_funcs.get_prev_func_addr(*args)

def get_next_func_addr(*args):
  """
  get_next_func_addr(pfn, ea) -> ea_t
  """
  return _ida_funcs.get_next_func_addr(*args)

def read_regargs(*args):
  """
  read_regargs(pfn)
  """
  return _ida_funcs.read_regargs(*args)

def add_regarg(*args):
  """
  add_regarg(pfn, reg, tif, name)
  """
  return _ida_funcs.add_regarg(*args)
IDASGN_OK = _ida_funcs.IDASGN_OK
"""
ok
"""
IDASGN_BADARG = _ida_funcs.IDASGN_BADARG
"""
bad number of signature
"""
IDASGN_APPLIED = _ida_funcs.IDASGN_APPLIED
"""
signature is already applied
"""
IDASGN_CURRENT = _ida_funcs.IDASGN_CURRENT
"""
signature is currently being applied
"""
IDASGN_PLANNED = _ida_funcs.IDASGN_PLANNED
"""
signature is planned to be applied
"""

def plan_to_apply_idasgn(*args):
  """
  plan_to_apply_idasgn(fname) -> int


  Add a signature file to the list of planned signature files.
  
  @param fname: file name. should not contain directory part. (C++:
                const char *)
  @return: 0 if failed, otherwise number of planned (and applied)
           signatures
  """
  return _ida_funcs.plan_to_apply_idasgn(*args)

def apply_idasgn_to(*args):
  """
  apply_idasgn_to(signame, ea, is_startup) -> int


  Apply a signature file to the specified address.
  
  @param signame: short name of signature file (the file name without
                  path) (C++: const char *)
  @param ea: address to apply the signature (C++: ea_t)
  @param is_startup: if set, then the signature is treated as a startup
                     one for startup signature ida doesn't rename the
                     first function of the applied module. (C++: bool)
  @return: Library function codes
  """
  return _ida_funcs.apply_idasgn_to(*args)

def get_idasgn_qty(*args):
  """
  get_idasgn_qty() -> int


  Get number of signatures in the list of planned and applied
  signatures.
  
  @return: 0..n
  """
  return _ida_funcs.get_idasgn_qty(*args)

def get_current_idasgn(*args):
  """
  get_current_idasgn() -> int


  Get number of the the current signature.
  
  @return: 0..n-1
  """
  return _ida_funcs.get_current_idasgn(*args)

def calc_idasgn_state(*args):
  """
  calc_idasgn_state(n) -> int


  Get state of a signature in the list of planned signatures
  
  @param n: number of signature in the list (0.. get_idasgn_qty() -1)
            (C++: int)
  @return: state of signature or  IDASGN_BADARG
  """
  return _ida_funcs.calc_idasgn_state(*args)

def del_idasgn(*args):
  """
  del_idasgn(n) -> int


  Remove signature from the list of planned signatures.
  
  @param n: number of signature in the list (0.. get_idasgn_qty() -1)
            (C++: int)
  @return: IDASGN_OK ,  IDASGN_BADARG ,  IDASGN_APPLIED
  """
  return _ida_funcs.del_idasgn(*args)

def get_idasgn_title(*args):
  """
  get_idasgn_title(name) -> ssize_t


  Get full description of the signature by its short name.
  
  @param name: short name of a signature (C++: const char *)
  @return: size of signature description or -1
  """
  return _ida_funcs.get_idasgn_title(*args)

def apply_startup_sig(*args):
  """
  apply_startup_sig(ea, startup) -> bool


  Apply a startup signature file to the specified address.
  
  @param ea: address to apply the signature to; usually \inf{start_ea}
             (C++: ea_t)
  @param startup: the name of the signature file without path and
                  extension (C++: const char *)
  @return: true if successfully applied the signature
  """
  return _ida_funcs.apply_startup_sig(*args)

def try_to_add_libfunc(*args):
  """
  try_to_add_libfunc(ea) -> int


  Apply the currently loaded signature file to the specified address. If
  a library function is found, then create a function and name it
  accordingly.
  
  @param ea: any address in the program (C++: ea_t)
  @return: Library function codes
  """
  return _ida_funcs.try_to_add_libfunc(*args)
LIBFUNC_FOUND = _ida_funcs.LIBFUNC_FOUND
"""
ok, library function is found
"""
LIBFUNC_NONE = _ida_funcs.LIBFUNC_NONE
"""
no, this is not a library function
"""
LIBFUNC_DELAY = _ida_funcs.LIBFUNC_DELAY
"""
no decision because of lack of information
"""

def get_fchunk_referer(*args):
  """
  get_fchunk_referer(ea, idx) -> ea_t
  """
  return _ida_funcs.get_fchunk_referer(*args)

def get_idasgn_desc(*args):
  """
  get_idasgn_desc(n) -> PyObject *


  Get information about a signature in the list.
  It returns: (name of signature, names of optional libraries)
  
  See also: get_idasgn_desc_with_matches
  
  @param n: number of signature in the list (0..get_idasgn_qty()-1)
  @return: None on failure or tuple(signame, optlibs)
  """
  return _ida_funcs.get_idasgn_desc(*args)

def get_idasgn_desc_with_matches(*args):
  """
  get_idasgn_desc_with_matches(n) -> PyObject *


  Get information about a signature in the list.
  It returns: (name of signature, names of optional libraries, number of matches)
  
  @param n: number of signature in the list (0..get_idasgn_qty()-1)
  @return: None on failure or tuple(signame, optlibs, nmatches)
  """
  return _ida_funcs.get_idasgn_desc_with_matches(*args)

def func_t__from_ptrval__(*args):
  """
  func_t__from_ptrval__(ptrval) -> func_t
  """
  return _ida_funcs.func_t__from_ptrval__(*args)
#<pycode(py_funcs)>
import ida_idaapi
@ida_idaapi.replfun
def calc_thunk_func_target(*args):
    if len(args) == 2:
        pfn, rawptr = args
        target, fptr = calc_thunk_func_target.__dict__["orig"](pfn)
        import ida_pro
        ida_pro.ea_pointer.frompointer(rawptr).assign(fptr)
        return target
    else:
        return calc_thunk_func_target.__dict__["orig"](*args)
#</pycode(py_funcs)>

if _BC695:
    FUNC_STATIC=FUNC_STATICDEF
    add_regarg2=add_regarg
    clear_func_struct=lambda *args: True
    def del_func_cmt(pfn, rpt):
        set_func_cmt(pfn, "", rpt)
    func_parent_iterator_set2=func_parent_iterator_set
    func_setend=set_func_end
    func_setstart=set_func_start
    func_tail_iterator_set2=func_tail_iterator_set
    def get_func_limits(pfn, limits):
        import ida_range
        rs = ida_range.rangeset_t()
        if get_func_ranges(rs, pfn) == ida_idaapi.BADADDR:
            return False
        limits.start_ea = rs.begin().start_ea
        limits.end_ea = rs.begin().end_ea
        return True
    get_func_name2=get_func_name



