# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: expr
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_expr', [dirname(__file__)])
        except ImportError:
            import _ida_expr
            return _ida_expr
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_expr', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_expr = swig_import_helper()
    del swig_import_helper
else:
    import _ida_expr
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def compile_idc_file(*args):
  """
  compile_idc_file(nonnul_line) -> bool
  """
  return _ida_expr.compile_idc_file(*args)

def compile_idc_text(*args):
  """
  compile_idc_text(nonnul_line) -> bool
  """
  return _ida_expr.compile_idc_text(*args)

def py_get_call_idc_func(*args):
  """
  py_get_call_idc_func() -> size_t
  """
  return _ida_expr.py_get_call_idc_func(*args)

def pyw_register_idc_func(*args):
  """
  pyw_register_idc_func(name, args, py_fp) -> size_t
  """
  return _ida_expr.pyw_register_idc_func(*args)

def pyw_unregister_idc_func(*args):
  """
  pyw_unregister_idc_func(ctxptr) -> bool
  """
  return _ida_expr.pyw_unregister_idc_func(*args)

def pyw_convert_defvals(*args):
  """
  pyw_convert_defvals(out, py_seq) -> bool
  """
  return _ida_expr.pyw_convert_defvals(*args)

def py_add_idc_func(*args):
  """
  py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool
  """
  return _ida_expr.py_add_idc_func(*args)

def eval_expr(*args):
  """
  eval_expr(rv, where, line) -> bool


  Compile and calculate an expression.
  
  @param rv: pointer to the result (C++: idc_value_t  *)
  @param where: the current linear address in the addressing space of
                the program being disassembled. If will be used to
                resolve names of local variables etc. if not applicable,
                then should be  BADADDR . (C++: ea_t)
  @param line: the expression to evaluate (C++: const char *)
  """
  return _ida_expr.eval_expr(*args)

def eval_idc_expr(*args):
  """
  eval_idc_expr(rv, where, line) -> bool


  Same as 'eval_expr()' , but will always use the IDC interpreter
  regardless of the currently installed extlang.
  
  @param rv (C++: idc_value_t  *)
  @param where (C++: ea_t)
  """
  return _ida_expr.eval_idc_expr(*args)
IDC_LANG_EXT = _ida_expr.IDC_LANG_EXT
"""
IDC script extension.
"""

def idcv_long(*args):
  """
  idcv_long(v) -> error_t


  Convert IDC variable to a long (32/64bit) number.
  
  @param v (C++: idc_value_t  *)
  @return: v = 0 if impossible to convert to long
  """
  return _ida_expr.idcv_long(*args)

def idcv_int64(*args):
  """
  idcv_int64(v) -> error_t


  Convert IDC variable to a 64bit number.
  
  @param v (C++: idc_value_t  *)
  @return: v = 0 if impossible to convert to int64
  """
  return _ida_expr.idcv_int64(*args)

def idcv_num(*args):
  """
  idcv_num(v) -> error_t


  Convert IDC variable to a long number.
  
  @param v (C++: idc_value_t  *)
  @return: v = 0 if IDC variable = "false" string   v = 1 if IDC
           variable = "true" string   v = number if IDC variable is
           number or string containing a number   eTypeConflict if IDC
           variable = empty string
  """
  return _ida_expr.idcv_num(*args)

def idcv_string(*args):
  """
  idcv_string(v) -> error_t


  Convert IDC variable to a text string.
  
  
  @param v (C++: idc_value_t  *)
  """
  return _ida_expr.idcv_string(*args)

def idcv_float(*args):
  """
  idcv_float(v) -> error_t


  Convert IDC variable to a floating point.
  
  
  @param v (C++: idc_value_t  *)
  """
  return _ida_expr.idcv_float(*args)

def idcv_object(*args):
  """
  idcv_object(v, icls=None) -> error_t


  Create an IDC object. The original value of 'v' is discarded (freed).
  
  @param v: variable to hold the object. any previous value will be
            cleaned (C++: idc_value_t  *)
  @param icls: ptr to the desired class. NULL means "object" class this
               ptr must be returned by  add_idc_class()  or
               find_idc_class() (C++: const idc_class_t *)
  @return: always eOk
  """
  return _ida_expr.idcv_object(*args)

def move_idcv(*args):
  """
  move_idcv(dst, src) -> error_t


  Move 'src' to 'dst'. This function is more effective than copy_idcv
  since it never copies big amounts of data.
  
  @param dst (C++: idc_value_t  *)
  @param src (C++: idc_value_t  *)
  """
  return _ida_expr.move_idcv(*args)

def copy_idcv(*args):
  """
  copy_idcv(dst, src) -> error_t


  Copy 'src' to 'dst'. For idc objects only a reference is copied.
  
  @param dst (C++: idc_value_t  *)
  @param src (C++: const  idc_value_t  &)
  """
  return _ida_expr.copy_idcv(*args)

def deep_copy_idcv(*args):
  """
  deep_copy_idcv(dst, src) -> error_t


  Deep copy an IDC object. This function performs deep copy of idc
  objects. If 'src' is not an object, 'copy_idcv()' will be called
  
  @param dst (C++: idc_value_t  *)
  @param src (C++: const  idc_value_t  &)
  """
  return _ida_expr.deep_copy_idcv(*args)

def free_idcv(*args):
  """
  free_idcv(v)


  Free storage used by 'VT_STR' / 'VT_OBJ' IDC variables. After this
  call the variable has a numeric value 0
  
  @param v (C++: idc_value_t  *)
  """
  return _ida_expr.free_idcv(*args)

def swap_idcvs(*args):
  """
  swap_idcvs(v1, v2)


  Swap 2 variables.
  
  
  @param v1 (C++: idc_value_t  *)
  @param v2 (C++: idc_value_t  *)
  """
  return _ida_expr.swap_idcvs(*args)

def get_idcv_class_name(*args):
  """
  get_idcv_class_name(obj) -> error_t


  Retrieves the IDC object class name.
  
  @param obj: class instance variable (C++: const  idc_value_t  *)
  @return: error code, eOk on success
  """
  return _ida_expr.get_idcv_class_name(*args)

def get_idcv_attr(*args):
  """
  get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t


  Get an object attribute.
  
  @param res: buffer for the attribute value (C++: idc_value_t  *)
  @param obj: variable that holds an object reference. if obj is NULL it
              searches global variables, then user functions (C++: const
              idc_value_t  *)
  @param attr: attribute name (C++: const char *)
  @param may_use_getattr: may call getattr functions to calculate the
                          attribute if it does not exist (C++: bool)
  @return: error code, eOk on success
  """
  return _ida_expr.get_idcv_attr(*args)

def set_idcv_attr(*args):
  """
  set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t


  Set an object attribute.
  
  @param obj: variable that holds an object reference. if obj is NULL
              then it tries to modify a global variable with the
              attribute name (C++: idc_value_t  *)
  @param attr: attribute name (C++: const char *)
  @param value: new attribute value (C++: const  idc_value_t  &)
  @param may_use_setattr: may call setattr functions for the class (C++:
                          bool)
  @return: error code, eOk on success
  """
  return _ida_expr.set_idcv_attr(*args)

def del_idcv_attr(*args):
  """
  del_idcv_attr(obj, attr) -> error_t


  Delete an object attribute.
  
  @param obj: variable that holds an object reference (C++: idc_value_t
              *)
  @param attr: attribute name (C++: const char *)
  @return: error code, eOk on success
  """
  return _ida_expr.del_idcv_attr(*args)

def first_idcv_attr(*args):
  """
  first_idcv_attr(obj) -> char const *
  """
  return _ida_expr.first_idcv_attr(*args)

def last_idcv_attr(*args):
  """
  last_idcv_attr(obj) -> char const *
  """
  return _ida_expr.last_idcv_attr(*args)

def next_idcv_attr(*args):
  """
  next_idcv_attr(obj, attr) -> char const *
  """
  return _ida_expr.next_idcv_attr(*args)

def prev_idcv_attr(*args):
  """
  prev_idcv_attr(obj, attr) -> char const *
  """
  return _ida_expr.prev_idcv_attr(*args)

def print_idcv(*args):
  """
  print_idcv(v, name=None, indent=0) -> bool


  Get text representation of 'idc_value_t' .
  
  
  @param v (C++: const  idc_value_t  &)
  @param name (C++: const char *)
  @param indent (C++: int)
  """
  return _ida_expr.print_idcv(*args)

def get_idcv_slice(*args):
  """
  get_idcv_slice(res, v, i1, i2, flags=0) -> error_t


  Get slice.
  
  @param res: output variable that will contain the slice (C++:
              idc_value_t  *)
  @param v: input variable (string or object) (C++: const  idc_value_t
            *)
  @param i1: slice start index (C++: uval_t)
  @param i2: slice end index (excluded) (C++: uval_t)
  @param flags: IDC variable slice flags  or 0 (C++: int)
  @return: eOk if success
  """
  return _ida_expr.get_idcv_slice(*args)
VARSLICE_SINGLE = _ida_expr.VARSLICE_SINGLE
"""
return single index (i2 is ignored)
"""

def set_idcv_slice(*args):
  """
  set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t


  Set slice.
  
  @param v: variable to modify (string or object) (C++: idc_value_t  *)
  @param i1: slice start index (C++: uval_t)
  @param i2: slice end index (excluded) (C++: uval_t)
  @param flags: IDC variable slice flags  or 0 (C++: int)
  @return: eOk on success
  """
  return _ida_expr.set_idcv_slice(*args)

def add_idc_class(*args):
  """
  add_idc_class(name, super=None) -> idc_class_t *


  Create a new IDC class.
  
  @param name: name of the new class (C++: const char *)
  @param super: the base class for the new class. if the new class is
                not based on any other class, pass NULL (C++: const
                idc_class_t *)
  @return: pointer to the created class. If such a class already exists,
           a pointer to it will be returned. Pointers to other existing
           classes may be invalidated by this call.
  """
  return _ida_expr.add_idc_class(*args)

def find_idc_class(*args):
  """
  find_idc_class(name) -> idc_class_t *


  Find an existing IDC class by its name.
  
  @param name: name of the class (C++: const char *)
  @return: pointer to the class or NULL. The returned pointer is valid
           until a new call to  add_idc_class()
  """
  return _ida_expr.find_idc_class(*args)

def deref_idcv(*args):
  """
  deref_idcv(v, vref_flags) -> idc_value_t


  Dereference a 'VT_REF' variable.
  
  @param v: variable to dereference (C++: idc_value_t  *)
  @param vref_flags: Dereference IDC variable flags (C++: int)
  @return: pointer to the dereference result or NULL. If returns NULL,
           qerrno is set to eExecBadRef "Illegal variable reference"
  """
  return _ida_expr.deref_idcv(*args)
VREF_LOOP = _ida_expr.VREF_LOOP
"""
dereference until we get a non 'VT_REF'
"""
VREF_ONCE = _ida_expr.VREF_ONCE
"""
dereference only once, do not loop
"""
VREF_COPY = _ida_expr.VREF_COPY
"""
copy the result to the input var (v)
"""

def create_idcv_ref(*args):
  """
  create_idcv_ref(ref, v) -> bool


  Create a variable reference. Currently only references to global
  variables can be created.
  
  @param ref: ptr to the result (C++: idc_value_t  *)
  @param v: variable to reference (C++: const  idc_value_t  *)
  @return: success
  """
  return _ida_expr.create_idcv_ref(*args)

def add_idc_gvar(*args):
  """
  add_idc_gvar(name) -> idc_value_t


  Add global IDC variable.
  
  @param name: name of the global variable (C++: const char *)
  @return: pointer to the created variable or existing variable. NB: the
           returned pointer is valid until a new global var is added.
  """
  return _ida_expr.add_idc_gvar(*args)

def find_idc_gvar(*args):
  """
  find_idc_gvar(name) -> idc_value_t


  Find an existing global IDC variable by its name.
  
  @param name: name of the global variable (C++: const char *)
  @return: pointer to the variable or NULL. NB: the returned pointer is
           valid until a new global var is added. FIXME: it is difficult
           to use this function in a thread safe manner
  """
  return _ida_expr.find_idc_gvar(*args)
class idc_value_t(object):
    """
    Proxy of C++ idc_value_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    vtype = _swig_property(_ida_expr.idc_value_t_vtype_get, _ida_expr.idc_value_t_vtype_set)
    num = _swig_property(_ida_expr.idc_value_t_num_get, _ida_expr.idc_value_t_num_set)
    e = _swig_property(_ida_expr.idc_value_t_e_get, _ida_expr.idc_value_t_e_set)
    obj = _swig_property(_ida_expr.idc_value_t_obj_get, _ida_expr.idc_value_t_obj_set)
    funcidx = _swig_property(_ida_expr.idc_value_t_funcidx_get, _ida_expr.idc_value_t_funcidx_set)
    pvoid = _swig_property(_ida_expr.idc_value_t_pvoid_get, _ida_expr.idc_value_t_pvoid_set)
    i64 = _swig_property(_ida_expr.idc_value_t_i64_get, _ida_expr.idc_value_t_i64_set)
    reserve = _swig_property(_ida_expr.idc_value_t_reserve_get, _ida_expr.idc_value_t_reserve_set)
    def __init__(self, *args):
        """
        __init__(self, n=0) -> idc_value_t
        __init__(self, r) -> idc_value_t
        __init__(self, _str) -> idc_value_t
        """
        this = _ida_expr.new_idc_value_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_expr.delete_idc_value_t
    __del__ = lambda self : None;
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_expr.idc_value_t_clear(self, *args)

    def qstr(self, *args):
        """
        qstr(self) -> qstring
        qstr(self) -> qstring const &
        """
        return _ida_expr.idc_value_t_qstr(self, *args)

    def c_str(self, *args):
        """
        c_str(self) -> char const *
        """
        return _ida_expr.idc_value_t_c_str(self, *args)

    def u_str(self, *args):
        """
        u_str(self) -> uchar const *
        """
        return _ida_expr.idc_value_t_u_str(self, *args)

    def swap(self, *args):
        """
        swap(self, v)
        """
        return _ida_expr.idc_value_t_swap(self, *args)

    def is_zero(self, *args):
        """
        is_zero(self) -> bool
        """
        return _ida_expr.idc_value_t_is_zero(self, *args)

    def is_integral(self, *args):
        """
        is_integral(self) -> bool
        """
        return _ida_expr.idc_value_t_is_integral(self, *args)

    def is_convertible(self, *args):
        """
        is_convertible(self) -> bool
        """
        return _ida_expr.idc_value_t_is_convertible(self, *args)

    def _create_empty_string(self, *args):
        """
        _create_empty_string(self)
        """
        return _ida_expr.idc_value_t__create_empty_string(self, *args)

    def create_empty_string(self, *args):
        """
        create_empty_string(self)
        """
        return _ida_expr.idc_value_t_create_empty_string(self, *args)

    def set_string(self, *args):
        """
        set_string(self, _str, len)
        set_string(self, _str)
        """
        return _ida_expr.idc_value_t_set_string(self, *args)

    def set_long(self, *args):
        """
        set_long(self, v)
        """
        return _ida_expr.idc_value_t_set_long(self, *args)

    def set_pvoid(self, *args):
        """
        set_pvoid(self, p)
        """
        return _ida_expr.idc_value_t_set_pvoid(self, *args)

    def set_int64(self, *args):
        """
        set_int64(self, v)
        """
        return _ida_expr.idc_value_t_set_int64(self, *args)

    def set_float(self, *args):
        """
        set_float(self, f)
        """
        return _ida_expr.idc_value_t_set_float(self, *args)

    str = property(lambda self: self.c_str(), lambda self, v: self.set_string(v))

idc_value_t_swigregister = _ida_expr.idc_value_t_swigregister
idc_value_t_swigregister(idc_value_t)
VT_LONG = _ida_expr.VT_LONG
"""
Integer (see 'idc_value_t::num' )
"""
VT_FLOAT = _ida_expr.VT_FLOAT
"""
Floating point (see 'idc_value_t::e' )
"""
VT_WILD = _ida_expr.VT_WILD
"""
Function with arbitrary number of arguments. The actual number of
arguments will be passed in 'idc_value_t::num' . This value should not
be used for 'idc_value_t' .
"""
VT_OBJ = _ida_expr.VT_OBJ
"""
Object (see idc_value_t::obj)
"""
VT_FUNC = _ida_expr.VT_FUNC
"""
Function (see 'idc_value_t::funcidx' )
"""
VT_STR = _ida_expr.VT_STR
"""
String (see qstr() and similar functions)
"""
VT_PVOID = _ida_expr.VT_PVOID
"""
void *
"""
VT_INT64 = _ida_expr.VT_INT64
"""
i64
"""
VT_REF = _ida_expr.VT_REF
"""
Reference.
"""

class idc_global_t(object):
    """
    Proxy of C++ idc_global_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_expr.idc_global_t_name_get, _ida_expr.idc_global_t_name_set)
    value = _swig_property(_ida_expr.idc_global_t_value_get, _ida_expr.idc_global_t_value_set)
    def __init__(self, *args):
        """
        __init__(self) -> idc_global_t
        __init__(self, n) -> idc_global_t
        """
        this = _ida_expr.new_idc_global_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_expr.delete_idc_global_t
    __del__ = lambda self : None;
idc_global_t_swigregister = _ida_expr.idc_global_t_swigregister
idc_global_t_swigregister(idc_global_t)

eExecThrow = _ida_expr.eExecThrow
"""
See return value of 'idc_func_t' .
"""

def find_idc_func(*args):
  """
  find_idc_func(prefix, n=0) -> bool
  """
  return _ida_expr.find_idc_func(*args)
HF_DEFAULT = _ida_expr.HF_DEFAULT
HF_KEYWORD1 = _ida_expr.HF_KEYWORD1
HF_KEYWORD2 = _ida_expr.HF_KEYWORD2
HF_KEYWORD3 = _ida_expr.HF_KEYWORD3
HF_STRING = _ida_expr.HF_STRING
HF_COMMENT = _ida_expr.HF_COMMENT
HF_PREPROC = _ida_expr.HF_PREPROC
HF_NUMBER = _ida_expr.HF_NUMBER
HF_MAX = _ida_expr.HF_MAX
class highlighter_cbs_t(object):
    """
    Proxy of C++ highlighter_cbs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_expr.delete_highlighter_cbs_t
    __del__ = lambda self : None;
    def set_style(self, *args):
        """
        set_style(self, arg0, arg1, arg2)
        """
        return _ida_expr.highlighter_cbs_t_set_style(self, *args)

    def prev_block_state(self, *args):
        """
        prev_block_state(self) -> int32
        """
        return _ida_expr.highlighter_cbs_t_prev_block_state(self, *args)

    def cur_block_state(self, *args):
        """
        cur_block_state(self) -> int32
        """
        return _ida_expr.highlighter_cbs_t_cur_block_state(self, *args)

    def set_block_state(self, *args):
        """
        set_block_state(self, arg0)
        """
        return _ida_expr.highlighter_cbs_t_set_block_state(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> highlighter_cbs_t
        """
        if self.__class__ == highlighter_cbs_t:
            _self = None
        else:
            _self = self
        this = _ida_expr.new_highlighter_cbs_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _ida_expr.disown_highlighter_cbs_t(self)
        return weakref_proxy(self)
highlighter_cbs_t_swigregister = _ida_expr.highlighter_cbs_t_swigregister
highlighter_cbs_t_swigregister(highlighter_cbs_t)


def set_header_path(*args):
  """
  set_header_path(path, add) -> bool


  Set or append a header path. IDA looks for the include files in the
  appended header paths, then in the ida executable directory.
  
  @param path: list of directories to add (separated by ';') may be
               NULL, in this case nothing is added (C++: const char *)
  @param add: true: append. false: remove old paths. (C++: bool)
  """
  return _ida_expr.set_header_path(*args)

def get_idc_filename(*args):
  """
  get_idc_filename(file) -> char *


  Get full name of IDC file name. Search for file in list of include
  directories, IDCPATH directory and the current directory.
  
  @param file: file name without full path (C++: const char *)
  @return: NULL is file not found. otherwise returns pointer to buf
  """
  return _ida_expr.get_idc_filename(*args)

def exec_system_script(*args):
  """
  exec_system_script(file, complain_if_no_file=True) -> bool


  Compile and execute "main" function from system file.
  
  @param file: file name with IDC function(s). The file will be searched
               in the idc subdir of ida (C++: const char *)
  @param complain_if_no_file: 1: display warning if the file is not
                              found   0: don't complain if file doesn't
                              exist (C++: bool)
  """
  return _ida_expr.exec_system_script(*args)
CPL_DEL_MACROS = _ida_expr.CPL_DEL_MACROS
"""
delete macros at the end of compilation
"""
CPL_USE_LABELS = _ida_expr.CPL_USE_LABELS
"""
allow program labels in the script
"""
CPL_ONLY_SAFE = _ida_expr.CPL_ONLY_SAFE
"""
allow calls of only thread-safe functions
"""

def compile_idc_snippet(*args):
  """
  compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> bool


  Compile text with IDC statements.
  
  @param func: name of the function to create out of the snippet (C++:
               const char *)
  @param text: text to compile (C++: const char *)
  @param resolver: callback object to get values of undefined variables
                   This object will be called if IDC function contains
                   references to undefined variables. May be NULL. (C++:
                   idc_resolver_t  *)
  @param only_safe_funcs: if true, any calls to functions without
                          EXTFUN_SAFE  flag will lead to a compilation
                          error. (C++: bool)
  """
  return _ida_expr.compile_idc_snippet(*args)

def exec_idc_script(*args):
  """
  exec_idc_script(result, path, func, args, argsnum) -> bool


  Compile and execute IDC function(s) from file.
  
  @param result: ptr to  idc_value_t  to hold result of the function. If
                 execution fails, this variable will contain the
                 exception information. You may pass NULL if you are not
                 interested in the returned value. (C++: idc_value_t  *)
  @param path: text file containing text of IDC functions (C++: const
               char *)
  @param func: function name to execute (C++: const char *)
  @param args: array of parameters (C++: const  idc_value_t)
  @param argsnum: number of parameters to pass to 'fname' This number
                  should be equal to number of parameters the function
                  expects. (C++: size_t)
  """
  return _ida_expr.exec_idc_script(*args)

def throw_idc_exception(*args):
  """
  throw_idc_exception(r, desc) -> error_t


  Create an idc execution exception object. This helper function can be
  used to return an exception from C++ code to IDC. In other words this
  function can be called from 'idc_func_t()' callbacks. Sample usage: if
  ( !ok ) return throw_idc_exception(r, "detailed error msg");
  
  @param r: object to hold the exception object (C++: idc_value_t  *)
  @param desc: exception description (C++: const char *)
  @return: eExecThrow
  """
  return _ida_expr.throw_idc_exception(*args)
class idc_values_t(object):
    """
    Proxy of C++ qvector<(idc_value_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> idc_values_t
        __init__(self, x) -> idc_values_t
        """
        this = _ida_expr.new_idc_values_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_expr.delete_idc_values_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_expr.idc_values_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_expr.idc_values_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_expr.idc_values_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> idc_value_t
        """
        return _ida_expr.idc_values_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_expr.idc_values_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_expr.idc_values_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_expr.idc_values_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=idc_value_t())
        """
        return _ida_expr.idc_values_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_expr.idc_values_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_expr.idc_values_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_expr.idc_values_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_expr.idc_values_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_expr.idc_values_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> idc_value_t
        begin(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> idc_value_t
        end(self) -> idc_value_t
        """
        return _ida_expr.idc_values_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> idc_value_t
        """
        return _ida_expr.idc_values_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> idc_value_t
        erase(self, first, last) -> idc_value_t
        """
        return _ida_expr.idc_values_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_expr.idc_values_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> idc_value_t
        """
        return _ida_expr.idc_values_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_expr.idc_values_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

idc_values_t_swigregister = _ida_expr.idc_values_t_swigregister
idc_values_t_swigregister(idc_values_t)

#<pycode(py_expr)>
try:
    import types
    import ctypes
    # Callback for IDC func callback (On Windows, we use stdcall)
    # typedef error_t idaapi idc_func_t(idc_value_t *argv,idc_value_t *r);
    try:
        _IDCFUNC_CB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p)
    except:
        _IDCFUNC_CB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p)

    # A trampoline function that is called from idcfunc_t that will
    # call the Python callback with the argv and r properly serialized to python
    call_idc_func__ = ctypes.CFUNCTYPE(ctypes.c_long, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p)(_ida_expr.py_get_call_idc_func())
except:
    def call_idc_func__(*args):
        warning("IDC extensions need ctypes library in order to work")
        return 0
    _IDCFUNC_CB_T = None

# --------------------------------------------------------------------------
EXTFUN_BASE  = 0x0001
"""
requires open database
"""
EXTFUN_NORET = 0x0002
"""
does not return. the interpreter may clean up its state before calling it.
"""
EXTFUN_SAFE  = 0x0004
"""
thread safe function. may be called
"""

# --------------------------------------------------------------------------
class _IdcFunction(object):
    """
    Internal class that calls pyw_call_idc_func() with a context
    """
    def __init__(self, ctxptr):
        self.ctxptr = ctxptr
        # Take a reference to the ctypes callback
        # (note: this will create a circular reference)
        self.cb = _IDCFUNC_CB_T(self)

    fp_ptr = property(lambda self: ctypes.cast(self.cb, ctypes.c_void_p).value)

    def __call__(self, args, res):
        return call_idc_func__(self.ctxptr, args, res)


# --------------------------------------------------------------------------
# Dictionary to remember IDC function names along with the context pointer
# retrieved by using the internal pyw_register_idc_func()
__IDC_FUNC_CTXS = {}

def del_idc_func(name):
    """
    Unregisters the specified IDC function

    @param name: IDC function name to unregister

    @return: Boolean


    Delete an IDC function
    """
    global __IDC_FUNC_CTXS

    # Get the context
    f = __IDC_FUNC_CTXS.get(name, None)

    if f is None:
        return False # Not registered

    # Break circular reference
    del f.cb

    # Delete the name from the dictionary
    del __IDC_FUNC_CTXS[name]

    # Delete the context and unregister the function
    return _ida_expr.pyw_unregister_idc_func(f.ctxptr)

# --------------------------------------------------------------------------
def add_idc_func(name, fp, args, defvals=None, flags=0):
    """
    Extends the IDC language by exposing a new IDC function that is backed up by a Python function

    @param name: IDC function name to expose
    @param fp: Python callable that will receive the arguments and return a tuple.
    @param args: Arguments. A tuple of idaapi.VT_XXX constants
    @param flags: IDC function flags. A combination of EXTFUN_XXX constants

    @return: Boolean


    Add an IDC function. This function does not modify the predefined
    kernel functions. Example:
    
    static error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
    {
      msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
      res->num = 5;     // let's return 5
      return eOk;
    }
    static const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
    static const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args, NULL, 0, EXTFUN_BASE };
    
    // after this:
    add_idc_func(myfunc_desc);
    
    // there is a new IDC function which can be called like this:
    MyFunc5(0x123, "test");
    
    If the function already exists, it will be replaced by the new
    function
    
    @return: success
    """
    global __IDC_FUNC_CTXS

    # Get the context
    f = __IDC_FUNC_CTXS.get(name, None)

    # Registering a function that is already registered?
    if f is not None:
        # Unregister it first
        del_idc_func(name)

    # Convert the tupple argument info to a string
    args = "".join([chr(x) for x in args])

    # make sure we don't have an obvious discrepancy between
    # the number of args, and the provided default values
    if len(defvals) > len(args):
        return False

    vdefvals = idc_values_t()
    if not _ida_expr.pyw_convert_defvals(vdefvals, defvals):
        return False

    # Create a context
    ctxptr = _ida_expr.pyw_register_idc_func(name, args, fp)
    if ctxptr == 0:
        return False

    # Bind the context with the IdcFunc object
    f = _IdcFunction(ctxptr)

    # Remember the Python context
    __IDC_FUNC_CTXS[name] = f

    # Register IDC function with a callback
    return _ida_expr.py_add_idc_func(
                name,
                f.fp_ptr,
                args,
                vdefvals,
                flags)

#</pycode(py_expr)>

if _BC695:
    Compile=compile_idc_file
    CompileEx=compile_idc_file
    CompileLine=compile_idc_text
    VT_STR2=VT_STR
    VarCopy=copy_idcv
    VarDelAttr=del_idcv_attr
    VarDeref=deref_idcv
    VarFirstAttr=first_idcv_attr
    def VarGetAttr(obj, attr, res, may_use_getattr=False):
        return get_idcv_attr(res, obj, attr, may_use_getattr)
    VarGetClassName=get_idcv_class_name
    VarGetSlice=get_idcv_slice
    VarInt64=idcv_int64
    VarLastAttr=last_idcv_attr
    VarMove=move_idcv
    VarNextAttr=next_idcv_attr
    VarObject=idcv_object
    VarPrevAttr=prev_idcv_attr
    VarPrint=print_idcv
    VarRef=create_idcv_ref
    VarSetAttr=set_idcv_attr
    VarSetSlice=set_idcv_slice
    VarString2=idcv_string
    VarSwap=swap_idcvs
    def calc_idc_expr(where, expr, res):
        return eval_idc_expr(res, where, expr)
    def calcexpr(where, expr, res):
        return eval_expr(res, where, expr)
    def dosysfile(complain_if_no_file, fname):
        return exec_system_script(fname, complain_if_no_file)
    def execute(line):
        return eval_idc_snippet(None, line)
    py_set_idc_func_ex=py_add_idc_func
    def set_idc_func_ex(name, fp=None, args=(), flags=0):
        return add_idc_func(name, fp, args, (), flags)



