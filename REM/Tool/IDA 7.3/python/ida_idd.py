# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: idd
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_idd', [dirname(__file__)])
        except ImportError:
            import _ida_idd
            return _ida_idd
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_idd', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_idd = swig_import_helper()
    del swig_import_helper
else:
    import _ida_idd
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
class excvec_t(object):
    """
    Proxy of C++ qvector<(exception_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> excvec_t
        __init__(self, x) -> excvec_t
        """
        this = _ida_idd.new_excvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_excvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.excvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.excvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.excvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> exception_info_t
        """
        return _ida_idd.excvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.excvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.excvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.excvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=exception_info_t())
        """
        return _ida_idd.excvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.excvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.excvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.excvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.excvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.excvec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> exception_info_t
        begin(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> exception_info_t
        end(self) -> exception_info_t
        """
        return _ida_idd.excvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> exception_info_t
        """
        return _ida_idd.excvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> exception_info_t
        erase(self, first, last) -> exception_info_t
        """
        return _ida_idd.excvec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.excvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> exception_info_t
        """
        return _ida_idd.excvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.excvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

excvec_t_swigregister = _ida_idd.excvec_t_swigregister
excvec_t_swigregister(excvec_t)

class procinfo_vec_t(object):
    """
    Proxy of C++ qvector<(process_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> procinfo_vec_t
        __init__(self, x) -> procinfo_vec_t
        """
        this = _ida_idd.new_procinfo_vec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_procinfo_vec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.procinfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.procinfo_vec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.procinfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.procinfo_vec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.procinfo_vec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=process_info_t())
        """
        return _ida_idd.procinfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.procinfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.procinfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.procinfo_vec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.procinfo_vec_t_inject(self, *args)

    def begin(self, *args):
        """
        begin(self) -> process_info_t
        begin(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> process_info_t
        end(self) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> process_info_t
        erase(self, first, last) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t_erase(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.procinfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> process_info_t
        """
        return _ida_idd.procinfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.procinfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

procinfo_vec_t_swigregister = _ida_idd.procinfo_vec_t_swigregister
procinfo_vec_t_swigregister(procinfo_vec_t)

class call_stack_t(object):
    """
    Proxy of C++ qvector<(call_stack_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> call_stack_t
        __init__(self, x) -> call_stack_t
        """
        this = _ida_idd.new_call_stack_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_call_stack_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.call_stack_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.call_stack_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.call_stack_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.call_stack_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.call_stack_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.call_stack_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=call_stack_info_t())
        """
        return _ida_idd.call_stack_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.call_stack_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.call_stack_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.call_stack_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.call_stack_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.call_stack_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.call_stack_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.call_stack_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> call_stack_info_t
        begin(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> call_stack_info_t
        end(self) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> call_stack_info_t
        erase(self, first, last) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> call_stack_info_t
        find(self, x) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_idd.call_stack_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_idd.call_stack_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_idd.call_stack_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.call_stack_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> call_stack_info_t
        """
        return _ida_idd.call_stack_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.call_stack_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

call_stack_t_swigregister = _ida_idd.call_stack_t_swigregister
call_stack_t_swigregister(call_stack_t)

class meminfo_vec_t(object):
    """
    Proxy of C++ qvector<(memory_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> meminfo_vec_t
        __init__(self, x) -> meminfo_vec_t
        """
        this = _ida_idd.new_meminfo_vec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_meminfo_vec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_idd.meminfo_vec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_idd.meminfo_vec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_idd.meminfo_vec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.meminfo_vec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_idd.meminfo_vec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=memory_info_t())
        """
        return _ida_idd.meminfo_vec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_idd.meminfo_vec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_idd.meminfo_vec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.meminfo_vec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_idd.meminfo_vec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.meminfo_vec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.meminfo_vec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> memory_info_t
        begin(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> memory_info_t
        end(self) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> memory_info_t
        erase(self, first, last) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> memory_info_t
        find(self, x) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_idd.meminfo_vec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_idd.meminfo_vec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> memory_info_t
        """
        return _ida_idd.meminfo_vec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_idd.meminfo_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

meminfo_vec_t_swigregister = _ida_idd.meminfo_vec_t_swigregister
meminfo_vec_t_swigregister(meminfo_vec_t)

IDD_INTERFACE_VERSION = _ida_idd.IDD_INTERFACE_VERSION
"""
The IDD interface version number.
"""
NO_THREAD = _ida_idd.NO_THREAD
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""
class process_info_t(object):
    """
    Proxy of C++ process_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pid = _swig_property(_ida_idd.process_info_t_pid_get, _ida_idd.process_info_t_pid_set)
    name = _swig_property(_ida_idd.process_info_t_name_get, _ida_idd.process_info_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> process_info_t
        """
        this = _ida_idd.new_process_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_process_info_t
    __del__ = lambda self : None;
process_info_t_swigregister = _ida_idd.process_info_t_swigregister
process_info_t_swigregister(process_info_t)

class debapp_attrs_t(object):
    """
    Proxy of C++ debapp_attrs_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cbsize = _swig_property(_ida_idd.debapp_attrs_t_cbsize_get, _ida_idd.debapp_attrs_t_cbsize_set)
    addrsize = _swig_property(_ida_idd.debapp_attrs_t_addrsize_get, _ida_idd.debapp_attrs_t_addrsize_set)
    platform = _swig_property(_ida_idd.debapp_attrs_t_platform_get, _ida_idd.debapp_attrs_t_platform_set)
    is_be = _swig_property(_ida_idd.debapp_attrs_t_is_be_get, _ida_idd.debapp_attrs_t_is_be_set)
    def __init__(self, *args):
        """
        __init__(self) -> debapp_attrs_t
        """
        this = _ida_idd.new_debapp_attrs_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_debapp_attrs_t
    __del__ = lambda self : None;
debapp_attrs_t_swigregister = _ida_idd.debapp_attrs_t_swigregister
debapp_attrs_t_swigregister(debapp_attrs_t)
DEF_ADDRSIZE = _ida_idd.DEF_ADDRSIZE

class register_info_t(object):
    """
    Proxy of C++ register_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.register_info_t_name_get, _ida_idd.register_info_t_name_set)
    flags = _swig_property(_ida_idd.register_info_t_flags_get, _ida_idd.register_info_t_flags_set)
    register_class = _swig_property(_ida_idd.register_info_t_register_class_get, _ida_idd.register_info_t_register_class_set)
    dtype = _swig_property(_ida_idd.register_info_t_dtype_get, _ida_idd.register_info_t_dtype_set)
    bit_strings = _swig_property(_ida_idd.register_info_t_bit_strings_get, _ida_idd.register_info_t_bit_strings_set)
    default_bit_strings_mask = _swig_property(_ida_idd.register_info_t_default_bit_strings_mask_get, _ida_idd.register_info_t_default_bit_strings_mask_set)
    def __init__(self, *args):
        """
        __init__(self) -> register_info_t
        """
        this = _ida_idd.new_register_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_register_info_t
    __del__ = lambda self : None;
register_info_t_swigregister = _ida_idd.register_info_t_swigregister
register_info_t_swigregister(register_info_t)
REGISTER_READONLY = _ida_idd.REGISTER_READONLY
"""
the user can't modify the current value of this register
"""
REGISTER_IP = _ida_idd.REGISTER_IP
"""
instruction pointer
"""
REGISTER_SP = _ida_idd.REGISTER_SP
"""
stack pointer
"""
REGISTER_FP = _ida_idd.REGISTER_FP
"""
frame pointer
"""
REGISTER_ADDRESS = _ida_idd.REGISTER_ADDRESS
"""
may contain an address
"""
REGISTER_CS = _ida_idd.REGISTER_CS
"""
code segment
"""
REGISTER_SS = _ida_idd.REGISTER_SS
"""
stack segment
"""
REGISTER_NOLF = _ida_idd.REGISTER_NOLF
"""
allowing the next register to be displayed to its right (on the same
line)

displays this register without returning to the next line
"""
REGISTER_CUSTFMT = _ida_idd.REGISTER_CUSTFMT
"""
register should be displayed using a custom data format. the format
name is in bit_strings[0] the corresponding 'regval_t' will use
'bytevec_t'
"""

class memory_info_t(ida_range.range_t):
    """
    Proxy of C++ memory_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.memory_info_t_name_get, _ida_idd.memory_info_t_name_set)
    sclass = _swig_property(_ida_idd.memory_info_t_sclass_get, _ida_idd.memory_info_t_sclass_set)
    sbase = _swig_property(_ida_idd.memory_info_t_sbase_get, _ida_idd.memory_info_t_sbase_set)
    bitness = _swig_property(_ida_idd.memory_info_t_bitness_get, _ida_idd.memory_info_t_bitness_set)
    perm = _swig_property(_ida_idd.memory_info_t_perm_get, _ida_idd.memory_info_t_perm_set)
    def __init__(self, *args):
        """
        __init__(self) -> memory_info_t
        """
        this = _ida_idd.new_memory_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.memory_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.memory_info_t___ne__(self, *args)

    __swig_destroy__ = _ida_idd.delete_memory_info_t
    __del__ = lambda self : None;
memory_info_t_swigregister = _ida_idd.memory_info_t_swigregister
memory_info_t_swigregister(memory_info_t)

class scattered_segm_t(ida_range.range_t):
    """
    Proxy of C++ scattered_segm_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.scattered_segm_t_name_get, _ida_idd.scattered_segm_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> scattered_segm_t
        """
        this = _ida_idd.new_scattered_segm_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_scattered_segm_t
    __del__ = lambda self : None;
scattered_segm_t_swigregister = _ida_idd.scattered_segm_t_swigregister
scattered_segm_t_swigregister(scattered_segm_t)

NO_EVENT = _ida_idd.NO_EVENT
PROCESS_STARTED = _ida_idd.PROCESS_STARTED
PROCESS_EXITED = _ida_idd.PROCESS_EXITED
THREAD_STARTED = _ida_idd.THREAD_STARTED
THREAD_EXITED = _ida_idd.THREAD_EXITED
BREAKPOINT = _ida_idd.BREAKPOINT
STEP = _ida_idd.STEP
EXCEPTION = _ida_idd.EXCEPTION
LIB_LOADED = _ida_idd.LIB_LOADED
LIB_UNLOADED = _ida_idd.LIB_UNLOADED
INFORMATION = _ida_idd.INFORMATION
PROCESS_ATTACHED = _ida_idd.PROCESS_ATTACHED
PROCESS_DETACHED = _ida_idd.PROCESS_DETACHED
PROCESS_SUSPENDED = _ida_idd.PROCESS_SUSPENDED
TRACE_FULL = _ida_idd.TRACE_FULL

def set_debug_event_code(*args):
  """
  set_debug_event_code(ev, id)
  """
  return _ida_idd.set_debug_event_code(*args)
class modinfo_t(object):
    """
    Proxy of C++ modinfo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_idd.modinfo_t_name_get, _ida_idd.modinfo_t_name_set)
    base = _swig_property(_ida_idd.modinfo_t_base_get, _ida_idd.modinfo_t_base_set)
    size = _swig_property(_ida_idd.modinfo_t_size_get, _ida_idd.modinfo_t_size_set)
    rebase_to = _swig_property(_ida_idd.modinfo_t_rebase_to_get, _ida_idd.modinfo_t_rebase_to_set)
    def __init__(self, *args):
        """
        __init__(self) -> modinfo_t
        """
        this = _ida_idd.new_modinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_modinfo_t
    __del__ = lambda self : None;
modinfo_t_swigregister = _ida_idd.modinfo_t_swigregister
modinfo_t_swigregister(modinfo_t)

class bptaddr_t(object):
    """
    Proxy of C++ bptaddr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hea = _swig_property(_ida_idd.bptaddr_t_hea_get, _ida_idd.bptaddr_t_hea_set)
    kea = _swig_property(_ida_idd.bptaddr_t_kea_get, _ida_idd.bptaddr_t_kea_set)
    def __init__(self, *args):
        """
        __init__(self) -> bptaddr_t
        """
        this = _ida_idd.new_bptaddr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_bptaddr_t
    __del__ = lambda self : None;
bptaddr_t_swigregister = _ida_idd.bptaddr_t_swigregister
bptaddr_t_swigregister(bptaddr_t)

class excinfo_t(object):
    """
    Proxy of C++ excinfo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_idd.excinfo_t_code_get, _ida_idd.excinfo_t_code_set)
    can_cont = _swig_property(_ida_idd.excinfo_t_can_cont_get, _ida_idd.excinfo_t_can_cont_set)
    ea = _swig_property(_ida_idd.excinfo_t_ea_get, _ida_idd.excinfo_t_ea_set)
    info = _swig_property(_ida_idd.excinfo_t_info_get, _ida_idd.excinfo_t_info_set)
    def __init__(self, *args):
        """
        __init__(self) -> excinfo_t
        """
        this = _ida_idd.new_excinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_excinfo_t
    __del__ = lambda self : None;
excinfo_t_swigregister = _ida_idd.excinfo_t_swigregister
excinfo_t_swigregister(excinfo_t)

class debug_event_t(object):
    """
    Proxy of C++ debug_event_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pid = _swig_property(_ida_idd.debug_event_t_pid_get, _ida_idd.debug_event_t_pid_set)
    tid = _swig_property(_ida_idd.debug_event_t_tid_get, _ida_idd.debug_event_t_tid_set)
    ea = _swig_property(_ida_idd.debug_event_t_ea_get, _ida_idd.debug_event_t_ea_set)
    handled = _swig_property(_ida_idd.debug_event_t_handled_get, _ida_idd.debug_event_t_handled_set)
    def __init__(self, *args):
        """
        __init__(self) -> debug_event_t
        __init__(self, r) -> debug_event_t
        """
        this = _ida_idd.new_debug_event_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_debug_event_t
    __del__ = lambda self : None;
    def copy(self, *args):
        """
        copy(self, r) -> debug_event_t
        """
        return _ida_idd.debug_event_t_copy(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.debug_event_t_clear(self, *args)

    def clear_all(self, *args):
        """
        clear_all(self)
        """
        return _ida_idd.debug_event_t_clear_all(self, *args)

    def eid(self, *args):
        """
        eid(self) -> event_id_t
        """
        return _ida_idd.debug_event_t_eid(self, *args)

    def set_eid(self, *args):
        """
        set_eid(self, id)
        """
        return _ida_idd.debug_event_t_set_eid(self, *args)

    def modinfo(self, *args):
        """
        modinfo(self) -> modinfo_t
        modinfo(self) -> modinfo_t
        """
        return _ida_idd.debug_event_t_modinfo(self, *args)

    def exit_code(self, *args):
        """
        exit_code(self) -> int const &
        """
        return _ida_idd.debug_event_t_exit_code(self, *args)

    def info(self, *args):
        """
        info(self) -> qstring
        info(self) -> qstring const &
        """
        return _ida_idd.debug_event_t_info(self, *args)

    def bpt(self, *args):
        """
        bpt(self) -> bptaddr_t
        bpt(self) -> bptaddr_t
        """
        return _ida_idd.debug_event_t_bpt(self, *args)

    def exc(self, *args):
        """
        exc(self) -> excinfo_t
        exc(self) -> excinfo_t
        """
        return _ida_idd.debug_event_t_exc(self, *args)

    def set_modinfo(self, *args):
        """
        set_modinfo(self, id) -> modinfo_t
        """
        return _ida_idd.debug_event_t_set_modinfo(self, *args)

    def set_exit_code(self, *args):
        """
        set_exit_code(self, id, code)
        """
        return _ida_idd.debug_event_t_set_exit_code(self, *args)

    def set_info(self, *args):
        """
        set_info(self, id) -> qstring &
        """
        return _ida_idd.debug_event_t_set_info(self, *args)

    def set_bpt(self, *args):
        """
        set_bpt(self) -> bptaddr_t
        """
        return _ida_idd.debug_event_t_set_bpt(self, *args)

    def set_exception(self, *args):
        """
        set_exception(self) -> excinfo_t
        """
        return _ida_idd.debug_event_t_set_exception(self, *args)

    def bpt_ea(self, *args):
        """
        bpt_ea(self) -> ea_t
        """
        return _ida_idd.debug_event_t_bpt_ea(self, *args)

debug_event_t_swigregister = _ida_idd.debug_event_t_swigregister
debug_event_t_swigregister(debug_event_t)

class exception_info_t(object):
    """
    Proxy of C++ exception_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_idd.exception_info_t_code_get, _ida_idd.exception_info_t_code_set)
    flags = _swig_property(_ida_idd.exception_info_t_flags_get, _ida_idd.exception_info_t_flags_set)
    def break_on(self, *args):
        """
        break_on(self) -> bool
        """
        return _ida_idd.exception_info_t_break_on(self, *args)

    def handle(self, *args):
        """
        handle(self) -> bool
        """
        return _ida_idd.exception_info_t_handle(self, *args)

    name = _swig_property(_ida_idd.exception_info_t_name_get, _ida_idd.exception_info_t_name_set)
    desc = _swig_property(_ida_idd.exception_info_t_desc_get, _ida_idd.exception_info_t_desc_set)
    def __init__(self, *args):
        """
        __init__(self) -> exception_info_t
        __init__(self, _code, _flags, _name, _desc) -> exception_info_t
        """
        this = _ida_idd.new_exception_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_exception_info_t
    __del__ = lambda self : None;
exception_info_t_swigregister = _ida_idd.exception_info_t_swigregister
exception_info_t_swigregister(exception_info_t)
cvar = _ida_idd.cvar
BPT_WRITE = cvar.BPT_WRITE
BPT_READ = cvar.BPT_READ
BPT_RDWR = cvar.BPT_RDWR
BPT_SOFT = cvar.BPT_SOFT
BPT_EXEC = cvar.BPT_EXEC
BPT_DEFAULT = cvar.BPT_DEFAULT
EXC_BREAK = _ida_idd.EXC_BREAK
"""
break on the exception
"""
EXC_HANDLE = _ida_idd.EXC_HANDLE
"""
should be handled by the debugger?
"""
EXC_MSG = _ida_idd.EXC_MSG
"""
instead of a warning, log the exception to the output window
"""
EXC_SILENT = _ida_idd.EXC_SILENT
"""
do not warn or log to the output window
"""

class regval_t(object):
    """
    Proxy of C++ regval_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rvtype = _swig_property(_ida_idd.regval_t_rvtype_get, _ida_idd.regval_t_rvtype_set)
    ival = _swig_property(_ida_idd.regval_t_ival_get, _ida_idd.regval_t_ival_set)
    fval = _swig_property(_ida_idd.regval_t_fval_get, _ida_idd.regval_t_fval_set)
    __swig_destroy__ = _ida_idd.delete_regval_t
    __del__ = lambda self : None;
    def __init__(self, *args):
        """
        __init__(self) -> regval_t
        __init__(self, r) -> regval_t
        """
        this = _ida_idd.new_regval_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_idd.regval_t_clear(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.regval_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.regval_t___ne__(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_idd.regval_t_swap(self, *args)

    def set_int(self, *args):
        """
        set_int(self, x)
        """
        return _ida_idd.regval_t_set_int(self, *args)

    def set_float(self, *args):
        """
        set_float(self, x)
        """
        return _ida_idd.regval_t_set_float(self, *args)

    def set_bytes(self, *args):
        """
        set_bytes(self, data, size)
        set_bytes(self, v)
        set_bytes(self) -> bytevec_t &
        """
        return _ida_idd.regval_t_set_bytes(self, *args)

    def set_unavailable(self, *args):
        """
        set_unavailable(self)
        """
        return _ida_idd.regval_t_set_unavailable(self, *args)

    def bytes(self, *args):
        """
        bytes(self) -> bytevec_t
        bytes(self) -> bytevec_t const &
        """
        return _ida_idd.regval_t_bytes(self, *args)

    def get_data(self, *args):
        """
        get_data(self)
        get_data(self) -> void const *
        """
        return _ida_idd.regval_t_get_data(self, *args)

    def get_data_size(self, *args):
        """
        get_data_size(self) -> size_t
        """
        return _ida_idd.regval_t_get_data_size(self, *args)

regval_t_swigregister = _ida_idd.regval_t_swigregister
regval_t_swigregister(regval_t)
RVT_INT = _ida_idd.RVT_INT
"""
integer
"""
RVT_FLOAT = _ida_idd.RVT_FLOAT
"""
floating point
"""
RVT_UNAVAILABLE = _ida_idd.RVT_UNAVAILABLE
"""
other values mean custom data type

unavailable
"""

class call_stack_info_t(object):
    """
    Proxy of C++ call_stack_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    callea = _swig_property(_ida_idd.call_stack_info_t_callea_get, _ida_idd.call_stack_info_t_callea_set)
    funcea = _swig_property(_ida_idd.call_stack_info_t_funcea_get, _ida_idd.call_stack_info_t_funcea_set)
    fp = _swig_property(_ida_idd.call_stack_info_t_fp_get, _ida_idd.call_stack_info_t_fp_set)
    funcok = _swig_property(_ida_idd.call_stack_info_t_funcok_get, _ida_idd.call_stack_info_t_funcok_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idd.call_stack_info_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> call_stack_info_t
        """
        this = _ida_idd.new_call_stack_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_call_stack_info_t
    __del__ = lambda self : None;
call_stack_info_t_swigregister = _ida_idd.call_stack_info_t_swigregister
call_stack_info_t_swigregister(call_stack_info_t)


def dbg_appcall(*args):
  """
  dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t


  Call a function from the debugged application.
  
  @param retval (C++: idc_value_t  *)
  @param func_ea: address to call (C++: ea_t)
  @param tid: thread to use.  NO_THREAD  means to use the current thread
              (C++: thid_t)
  @param ptif: pointer to type of the function to call (C++: const
               tinfo_t  *)
  @param argv: array of arguments (C++: idc_value_t  *)
  @param argnum: number of actual arguments (C++: size_t)
  @return: eOk  if successful, otherwise an error code
  """
  return _ida_idd.dbg_appcall(*args)

def cleanup_appcall(*args):
  """
  cleanup_appcall(tid) -> error_t


  Cleanup after manual appcall.
  
  @param tid: thread to use.  NO_THREAD  means to use the current thread
              The application state is restored as it was before calling
              the last appcall(). Nested appcalls are supported. (C++:
              thid_t)
  @return: eOk  if successful, otherwise an error code
  """
  return _ida_idd.cleanup_appcall(*args)
class thread_name_t(object):
    """
    Proxy of C++ thread_name_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    tid = _swig_property(_ida_idd.thread_name_t_tid_get, _ida_idd.thread_name_t_tid_set)
    name = _swig_property(_ida_idd.thread_name_t_name_get, _ida_idd.thread_name_t_name_set)
    def __init__(self, *args):
        """
        __init__(self) -> thread_name_t
        """
        this = _ida_idd.new_thread_name_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idd.delete_thread_name_t
    __del__ = lambda self : None;
thread_name_t_swigregister = _ida_idd.thread_name_t_swigregister
thread_name_t_swigregister(thread_name_t)

RESMOD_NONE = _ida_idd.RESMOD_NONE
RESMOD_INTO = _ida_idd.RESMOD_INTO
RESMOD_OVER = _ida_idd.RESMOD_OVER
RESMOD_OUT = _ida_idd.RESMOD_OUT
RESMOD_SRCINTO = _ida_idd.RESMOD_SRCINTO
RESMOD_SRCOVER = _ida_idd.RESMOD_SRCOVER
RESMOD_SRCOUT = _ida_idd.RESMOD_SRCOUT
RESMOD_USER = _ida_idd.RESMOD_USER
RESMOD_HANDLE = _ida_idd.RESMOD_HANDLE
RESMOD_MAX = _ida_idd.RESMOD_MAX
STEP_TRACE = _ida_idd.STEP_TRACE
INSN_TRACE = _ida_idd.INSN_TRACE
FUNC_TRACE = _ida_idd.FUNC_TRACE
BBLK_TRACE = _ida_idd.BBLK_TRACE
DRC_EVENTS = _ida_idd.DRC_EVENTS
DRC_CRC = _ida_idd.DRC_CRC
DRC_OK = _ida_idd.DRC_OK
DRC_NONE = _ida_idd.DRC_NONE
DRC_FAILED = _ida_idd.DRC_FAILED
DRC_NETERR = _ida_idd.DRC_NETERR
DRC_NOFILE = _ida_idd.DRC_NOFILE
DRC_IDBSEG = _ida_idd.DRC_IDBSEG
DRC_NOPROC = _ida_idd.DRC_NOPROC
DRC_NOCHG = _ida_idd.DRC_NOCHG
DRC_ERROR = _ida_idd.DRC_ERROR
RQ_MASKING = _ida_idd.RQ_MASKING
RQ_SUSPEND = _ida_idd.RQ_SUSPEND
RQ_NOSUSP = _ida_idd.RQ_NOSUSP
RQ_IGNWERR = _ida_idd.RQ_IGNWERR
RQ_SILENT = _ida_idd.RQ_SILENT
RQ_VERBOSE = _ida_idd.RQ_VERBOSE
RQ_SWSCREEN = _ida_idd.RQ_SWSCREEN
RQ__NOTHRRF = _ida_idd.RQ__NOTHRRF
RQ_PROCEXIT = _ida_idd.RQ_PROCEXIT
RQ_IDAIDLE = _ida_idd.RQ_IDAIDLE
RQ_SUSPRUN = _ida_idd.RQ_SUSPRUN
RQ_RESUME = _ida_idd.RQ_RESUME
RQ_RESMOD = _ida_idd.RQ_RESMOD
RQ_RESMOD_SHIFT = _ida_idd.RQ_RESMOD_SHIFT

def dbg_get_registers(*args):
  """
  dbg_get_registers() -> PyObject *


  This function returns the register definition from the currently loaded debugger.
  Basically, it returns an array of structure similar to to idd.hpp / register_info_t
  @return:
      None if no debugger is loaded
      tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
      The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)
  """
  return _ida_idd.dbg_get_registers(*args)

def dbg_get_thread_sreg_base(*args):
  """
  dbg_get_thread_sreg_base(py_tid, py_sreg_value) -> PyObject *


  Returns the segment register base value
  @param tid: thread id
  @param sreg_value: segment register (selector) value
  @return:
      - The base as an 'ea'
      - Or None on failure
  """
  return _ida_idd.dbg_get_thread_sreg_base(*args)

def dbg_read_memory(*args):
  """
  dbg_read_memory(py_ea, py_sz) -> PyObject *


  Reads from the debugee's memory at the specified ea
  @return:
      - The read buffer (as a string)
      - Or None on failure
  """
  return _ida_idd.dbg_read_memory(*args)

def dbg_write_memory(*args):
  """
  dbg_write_memory(py_ea, py_buf) -> PyObject *


  Writes a buffer to the debugee's memory
  @return: Boolean
  """
  return _ida_idd.dbg_write_memory(*args)

def dbg_get_name(*args):
  """
  dbg_get_name() -> PyObject *


  This function returns the current debugger's name.
  @return: Debugger name or None if no debugger is active
  """
  return _ida_idd.dbg_get_name(*args)

def dbg_get_memory_info(*args):
  """
  dbg_get_memory_info() -> PyObject *


  This function returns the memory configuration of a debugged process.
  @return:
      None if no debugger is active
      tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)
  """
  return _ida_idd.dbg_get_memory_info(*args)

def appcall(*args):
  """
  appcall(func_ea, tid, py_type, py_fields, arg_list) -> PyObject *
  """
  return _ida_idd.appcall(*args)

def get_event_module_name(*args):
  """
  get_event_module_name(ev) -> char
  """
  return _ida_idd.get_event_module_name(*args)

def get_event_module_base(*args):
  """
  get_event_module_base(ev) -> ea_t
  """
  return _ida_idd.get_event_module_base(*args)

def get_event_module_size(*args):
  """
  get_event_module_size(ev) -> asize_t
  """
  return _ida_idd.get_event_module_size(*args)

def get_event_exc_info(*args):
  """
  get_event_exc_info(ev) -> char
  """
  return _ida_idd.get_event_exc_info(*args)

def get_event_info(*args):
  """
  get_event_info(ev) -> char
  """
  return _ida_idd.get_event_info(*args)

def get_event_bpt_hea(*args):
  """
  get_event_bpt_hea(ev) -> ea_t
  """
  return _ida_idd.get_event_bpt_hea(*args)

def get_event_exc_code(*args):
  """
  get_event_exc_code(ev) -> uint
  """
  return _ida_idd.get_event_exc_code(*args)

def get_event_exc_ea(*args):
  """
  get_event_exc_ea(ev) -> ea_t
  """
  return _ida_idd.get_event_exc_ea(*args)

def can_exc_continue(*args):
  """
  can_exc_continue(ev) -> bool
  """
  return _ida_idd.can_exc_continue(*args)
#<pycode(py_idd)>
NO_PROCESS = 0xFFFFFFFF
"""
No process.
"""
NO_THREAD  = 0
"""
No thread. in 'PROCESS_STARTED' this value can be used to specify that
the main thread has not been created. It will be initialized later by
a 'THREAD_STARTED' event.
"""

import types
import _ida_idaapi
import _ida_dbg
import _ida_typeinf
import _ida_name
import _ida_bytes
import _ida_ida
import ida_idaapi
import ida_typeinf

dbg_can_query = _ida_dbg.dbg_can_query

# -----------------------------------------------------------------------
class Appcall_array__(object):
    """
    This class is used with Appcall.array() method
    """
    def __init__(self, tp):
        self.__type = tp

    def pack(self, L):
        """
        Packs a list or tuple into a byref buffer
        """
        t = type(L)
        if not (t == list or t == tuple):
            raise ValueError("Either a list or a tuple must be passed")
        self.__size = len(L)
        if self.__size == 1:
            self.__typedobj = Appcall__.typedobj(self.__type + ";")
        else:
            self.__typedobj = Appcall__.typedobj("%s x[%d];" % (self.__type, self.__size))
        # Now store the object in a string buffer
        ok, buf = self.__typedobj.store(L)
        if ok:
            return Appcall__.byref(buf)
        else:
            return None

    def try_to_convert_to_list(self, obj):
        """
        Is this object a list? We check for the existance of attribute zero and attribute self.size-1
        """
        if not (hasattr(obj, "0") and hasattr(obj, str(self.__size-1))):
            return obj
        # at this point, we are sure we have an "idc list"
        # let us convert to a Python list
        return [getattr(obj, str(x)) for x in xrange(0, self.__size)]

    def unpack(self, buf, as_list=True):
        """
        Unpacks an array back into a list or an object
        """
        # take the value from the special ref object
        if isinstance(buf, ida_idaapi.PyIdc_cvt_refclass__):
            buf = buf.value

        # we can only unpack from strings
        if type(buf) != bytes:
            raise ValueError("Cannot unpack this type!")
        # now unpack
        ok, obj = self.__typedobj.retrieve(buf)
        if not ok:
            raise ValueError("Failed while unpacking!")
        if not as_list:
            return obj
        return self.try_to_convert_to_list(obj)


# -----------------------------------------------------------------------
# Wrapper class for the appcall()
class Appcall_callable__(object):
    """
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)
    """
    def __init__(self, ea, tinfo_or_typestr = None, fields = None):
        """
        Initializes an appcall with a given function ea
        """
        self.__ea      = ea
        self.__tif     = None
        self.__type    = None
        self.__fields  = None
        self.__options = None # Appcall options
        self.__timeout = None # Appcall timeout

        if tinfo_or_typestr:
          if type(tinfo_or_typestr) == types.StringType:
            # a type string? assume (typestr, fields), try to deserialize
            tif = ida_typeinf.tinfo_t()
            if not tif.deserialize(None, tinfo_or_typestr, fields):
              raise ValueError, "Could not deserialize type string"
          else:
            if not isinstance(tinfo_or_typestr, ida_typeinf.tinfo_t):
              raise ValueError, "Invalid argument 'tinfo_or_typestr'"
            tif = tinfo_or_typestr
          self.__tif = tif
          (self.__type, self.__fields, _) = tif.serialize()

    def __get_timeout(self):
        return self.__timeout

    def __set_timeout(self, v):
        self.__timeout = v

    timeout = property(__get_timeout, __set_timeout)
    """
    An Appcall instance can change its timeout value with this attribute
    """

    def __get_options(self):
        return self.__options if self.__options != None else Appcall__.get_appcall_options()

    def __set_options(self, v):
        if self.timeout:
            # If timeout value is set, then put the timeout flag and encode the timeout value
            v |= Appcall__.APPCALL_TIMEOUT | (self.timeout << 16)
        else:
            # Timeout is not set, then clear the timeout flag
            v &= ~Appcall__.APPCALL_TIMEOUT

        self.__options = v

    options = property(__get_options, __set_options)
    """
    Sets the Appcall options locally to this Appcall instance
    """

    def __call__(self, *args):
        """
        Make object callable. We redirect execution to idaapi.appcall()
        """
        if self.ea is None:
            raise ValueError("Object not callable!")

        # convert arguments to a list
        arg_list = list(args)

        # Save appcall options and set new global options
        old_opt = Appcall__.get_appcall_options()
        Appcall__.set_appcall_options(self.options)

        # Do the Appcall (use the wrapped version)
        try:
            return _ida_idd.appcall(
                self.ea,
                _ida_dbg.get_current_thread(),
                self.type,
                self.fields,
                arg_list)
        finally:
            # Restore appcall options
            Appcall__.set_appcall_options(old_opt)

    def __get_ea(self):
        return self.__ea

    def __set_ea(self, val):
        self.__ea = val

    ea = property(__get_ea, __set_ea)
    """
    Returns or sets the EA associated with this object
    """

    def __get_tif(self):
        return self.__tif

    tif = property(__get_tif)
    """
    Returns the tinfo_t object
    """

    def __get_size(self):
        if self.__type == None:
            return -1
        r = _ida_typeinf.calc_type_size(None, self.__type)
        if not r:
            return -1
        return r

    size = property(__get_size)
    """
    Returns the size of the type
    """

    def __get_type(self):
        return self.__type

    type = property(__get_type)
    """
    Returns the typestring
    """

    def __get_fields(self):
        return self.__fields

    fields = property(__get_fields)
    """
    Returns the field names
    """


    def retrieve(self, src=None, flags=0):
        """
        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
        @param src: the address of the object or a string
        @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
        """

        # Nothing passed? Take the address and unpack from the database
        if src is None:
            src = self.ea

        if type(src) == bytes:
            return _ida_typeinf.unpack_object_from_bv(None, self.type, self.fields, src, flags)
        else:
            return _ida_typeinf.unpack_object_from_idb(None, self.type, self.fields, src, flags)

    def store(self, obj, dest_ea=None, base_ea=0, flags=0):
        """
        Packs an object into a given ea if provided or into a string if no address was passed.
        @param obj: The object to pack
        @param dest_ea: If packing to idb this will be the store location
        @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers

        @return:
            - If packing to a string then a Tuple(Boolean, packed_string or error code)
            - If packing to the database then a return code is returned (0 is success)
        """

        # no ea passed? thus pack to a string
        if dest_ea is None:
            return _ida_typeinf.pack_object_to_bv(obj,
                                             None,
                                             self.type,
                                             self.fields,
                                             base_ea,
                                             flags)
        else:
            return _ida_typeinf.pack_object_to_idb(obj,
                                              None,
                                              self.type,
                                              self.fields,
                                              dest_ea,
                                              flags)

# -----------------------------------------------------------------------
class Appcall_consts__(object):
    """
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access
"""
    def __init__(self, default=None):
        self.__default = default

    def __getattr__(self, attr):
        v = Appcall__.valueof(attr, self.__default)
        if v is None:
            raise ValueError("No constant with name " + attr)
        return v

# -----------------------------------------------------------------------
class Appcall__(object):
    APPCALL_MANUAL = 0x1
    """
    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished
    """

    APPCALL_DEBEV  = 0x2
    """
    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception
    """

    APPCALL_TIMEOUT = 0x4
    """
    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".
    """

    __name__ = "Appcall__"

    def __init__(self):
        self.__consts = Appcall_consts__()

    def __get_consts(self):
        return self.__consts

    Consts = property(__get_consts)
    """
    Use Appcall.Consts.CONST_NAME to access constants
    """

    @staticmethod
    def __name_or_ea(name_or_ea):
        """
        Function that accepts a name or an ea and checks if the address is enabled.
        If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
        @return:
            - Returns the resolved EA or
            - Raises an exception if the address is not enabled
        """

        # a string? try to resolve it
        if type(name_or_ea) == bytes:
            ea = _ida_name.get_name_ea(_ida_idaapi.BADADDR, name_or_ea)
        else:
            ea = name_or_ea
        # could not resolve name or invalid address?
        if ea == _ida_idaapi.BADADDR or not _ida_bytes.is_mapped(ea):
            raise ValueError("Undefined function " + name_or_ea)
        return ea

    @staticmethod
    def __typedecl_or_tinfo(typedecl_or_tinfo, flags = None):
        """
        Function that accepts a tinfo_t object or type declaration as a string
        If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
        @return:
            - Returns the tinfo_t object
            - Raises an exception if the declaration cannot be parsed
        """

        # a string? try to parse it
        if type(typedecl_or_tinfo) == types.StringType:
          if flags is None:
              flags = ida_typeinf.PT_SIL|ida_typeinf.PT_NDC|ida_typeinf.PT_TYP
          tif = ida_typeinf.tinfo_t()
          if ida_typeinf.parse_decl(tif, None, typedecl_or_tinfo, flags) == None:
            raise ValueError, "Could not parse type: " + typedecl_or_tinfo
        else:
            if not isinstance(typedecl_or_tinfo, ida_typeinf.tinfo_t):
              raise ValueError, "Invalid argument 'typedecl_or_tinfo'"
            tif = typedecl_or_tinfo
        return tif

    @staticmethod
    def proto(name_or_ea, proto_or_tinfo, flags = None):
        """
        Allows you to instantiate an appcall (callable object) with the desired prototype
        @param name_or_ea: The name of the function (will be resolved with LocByName())
        @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
        @return:
            - On failure it raises an exception if the prototype could not be parsed
              or the address is not resolvable
            - Returns a callbable Appcall instance with the given prototypes and flags
        """

        # resolve and raise exception on error
        ea = Appcall__.__name_or_ea(name_or_ea)

        # parse the type if it is given as (prototype, flags)
        tif = Appcall__.__typedecl_or_tinfo(proto_or_tinfo, flags)

        # Return the callable method with type info
        return Appcall_callable__(ea, tif)

    def __getattr__(self, name_or_ea):
        """
        Allows you to call functions as if they were member functions (by returning a callable object)
        """
        # resolve and raise exception on error
        ea = self.__name_or_ea(name_or_ea)
        if ea == _ida_idaapi.BADADDR:
            raise ValueError("Undefined function " + name)
        # Return the callable method
        return Appcall_callable__(ea)

    def __getitem__(self, idx):
        """
        Use self[func_name] syntax if the function name contains invalid characters for an attribute name
        See __getattr___
        """
        return self.__getattr__(idx)

    @staticmethod
    def valueof(name, default=0):
        """
        Returns the numeric value of a given name string.
        If the name could not be resolved then the default value will be returned
        """
        t, v = _ida_name.get_name_value(_ida_idaapi.BADADDR, name)
        if t == 0: # NT_NONE
          v = default
        return v

    @staticmethod
    def int64(v):
        """
        Whenever a 64bit number is needed use this method to construct an object
        """
        return ida_idaapi.PyIdc_cvt_int64__(v)

    @staticmethod
    def byref(val):
        """
        Method to create references to immutable objects
        Currently we support references to int/strings
        Objects need not be passed by reference (this will be done automatically)
        """
        return ida_idaapi.PyIdc_cvt_refclass__(val)

    @staticmethod
    def buffer(str = None, size = 0, fill="\x00"):
        """
        Creates a string buffer. The returned value (r) will be a byref object.
        Use r.value to get the contents and r.size to get the buffer's size
        """
        if str is None:
            str = ""
        left = size - len(str)
        if left > 0:
            str = str + (fill * left)
        r = Appcall__.byref(str)
        r.size = size
        return r

    @staticmethod
    def obj(**kwds):
        """
        Returns an empty object or objects with attributes as passed via its keywords arguments
        """
        return ida_idaapi.object_t(**kwds)

    @staticmethod
    def cstr(val):
        return ida_idaapi.as_cstr(val)

    @staticmethod
    def unicode(s):
        return ida_idaapi.as_unicode(s)

    @staticmethod
    def array(type_name):
        """
        Defines an array type. Later you need to pack() / unpack()
        """
        return Appcall_array__(type_name)

    @staticmethod
    def typedobj(typedecl_or_tinfo, ea=None):
        """
        Returns an appcall object for a type (can be given as tinfo_t object or
        as a string declaration)
        One can then use retrieve() member method
        @param ea: Optional parameter that later can be used to retrieve the type
        @return: Appcall object or raises ValueError exception
        """
        # parse the type if it is given as string
        tif = Appcall__.__typedecl_or_tinfo(typedecl_or_tinfo)
        # Return the callable method with type info
        return Appcall_callable__(ea, tif)

    @staticmethod
    def set_appcall_options(opt):
        """
        Method to change the Appcall options globally (not per Appcall)
        """
        old_opt = Appcall__.get_appcall_options()
        _ida_ida.cvar.inf.appcall_options = opt
        return old_opt

    @staticmethod
    def get_appcall_options():
        """
        Return the global Appcall options
        """
        return _ida_ida.cvar.inf.appcall_options

    @staticmethod
    def cleanup_appcall(tid = 0):
        """
        Equivalent to IDC's CleanupAppcall()
        """
        return _ida_idd.cleanup_appcall(tid)

Appcall = Appcall__()
#</pycode(py_idd)>

if _BC695:
    PROCESS_NO_THREAD=NO_THREAD



