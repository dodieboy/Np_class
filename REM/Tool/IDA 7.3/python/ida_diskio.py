# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: diskio
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_diskio', [dirname(__file__)])
        except ImportError:
            import _ida_diskio
            return _ida_diskio
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_diskio', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_diskio = swig_import_helper()
    del swig_import_helper
else:
    import _ida_diskio
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def idadir(*args):
  """
  idadir(subdir) -> char const *


  Get IDA directory (if subdir==NULL) or the specified subdirectory (see
  'IDA subdirectories' )
  
  @param subdir (C++: const char *)
  """
  return _ida_diskio.idadir(*args)

def getsysfile(*args):
  """
  getsysfile(filename, subdir) -> char *


  Search for IDA system file. This function searches for a file in:each
  directory specified by IDAUSR%ida directory [+ subdir] and returns the
  first match.
  
  @param filename (C++: const char *)
  @param subdir (C++: const char *)
  @return: NULL if not found, otherwise a pointer to full file name.
  """
  return _ida_diskio.getsysfile(*args)
CFG_SUBDIR = _ida_diskio.CFG_SUBDIR
IDC_SUBDIR = _ida_diskio.IDC_SUBDIR
IDS_SUBDIR = _ida_diskio.IDS_SUBDIR
IDP_SUBDIR = _ida_diskio.IDP_SUBDIR
LDR_SUBDIR = _ida_diskio.LDR_SUBDIR
SIG_SUBDIR = _ida_diskio.SIG_SUBDIR
TIL_SUBDIR = _ida_diskio.TIL_SUBDIR
PLG_SUBDIR = _ida_diskio.PLG_SUBDIR
THM_SUBDIR = _ida_diskio.THM_SUBDIR

def get_user_idadir(*args):
  """
  get_user_idadir() -> char const *


  Get user ida related directory.
  
  - if $IDAUSR is defined:
      - the first element in $IDAUSR
  - else
      - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)
  """
  return _ida_diskio.get_user_idadir(*args)

def get_ida_subdirs(*args):
  """
  get_ida_subdirs(subdir, flags=0) -> int


  Get list of directories in which to find a specific IDA resource (see
  'IDA subdirectories' ). The order of the resulting list is as follows:
  
  - [$IDAUSR/subdir (0..N entries)]
  - $IDADIR/subdir
  
  @param subdir: name of the resource to list (C++: const char *)
  @param flags: Subdirectory modification flags  bits (C++: int)
  @return: number of directories appended to 'dirs'
  """
  return _ida_diskio.get_ida_subdirs(*args)
IDA_SUBDIR_IDP = _ida_diskio.IDA_SUBDIR_IDP
"""
append the processor name as a subdirectory
"""
IDA_SUBDIR_IDADIR_FIRST = _ida_diskio.IDA_SUBDIR_IDADIR_FIRST
"""
$IDADIR/subdir will be first, not last
"""
IDA_SUBDIR_ONLY_EXISTING = _ida_diskio.IDA_SUBDIR_ONLY_EXISTING
"""
only existing directories will be present
"""

def get_special_folder(*args):
  """
  get_special_folder(csidl) -> bool


  Get a folder location by CSIDL (see 'Common CSIDLs' ). Path should be
  of at least MAX_PATH size
  
  @param csidl (C++: int)
  """
  return _ida_diskio.get_special_folder(*args)
CSIDL_APPDATA = _ida_diskio.CSIDL_APPDATA
CSIDL_LOCAL_APPDATA = _ida_diskio.CSIDL_LOCAL_APPDATA
CSIDL_PROGRAM_FILES = _ida_diskio.CSIDL_PROGRAM_FILES
CSIDL_PROGRAM_FILES_COMMON = _ida_diskio.CSIDL_PROGRAM_FILES_COMMON
CSIDL_PROGRAM_FILESX86 = _ida_diskio.CSIDL_PROGRAM_FILESX86

def fopenWT(*args):
  """
  fopenWT(file) -> FILE *


  Open a new file for write in text mode, deny write. If a file exists,
  it will be removed.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenWT(*args)

def fopenWB(*args):
  """
  fopenWB(file) -> FILE *


  Open a new file for write in binary mode, deny read/write. If a file
  exists, it will be removed.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenWB(*args)

def fopenRT(*args):
  """
  fopenRT(file) -> FILE *


  Open a file for read in text mode, deny none.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenRT(*args)

def fopenRB(*args):
  """
  fopenRB(file) -> FILE *


  Open a file for read in binary mode, deny none.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenRB(*args)

def fopenM(*args):
  """
  fopenM(file) -> FILE *


  Open a file for read/write in binary mode, deny write.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenM(*args)

def fopenA(*args):
  """
  fopenA(file) -> FILE *


  Open a file for append in text mode, deny none.
  
  @param file (C++: const char *)
  @return: NULL if failure
  """
  return _ida_diskio.fopenA(*args)
LINPUT_NONE = _ida_diskio.LINPUT_NONE
LINPUT_LOCAL = _ida_diskio.LINPUT_LOCAL
LINPUT_RFILE = _ida_diskio.LINPUT_RFILE
LINPUT_PROCMEM = _ida_diskio.LINPUT_PROCMEM
LINPUT_GENERIC = _ida_diskio.LINPUT_GENERIC

def qlgetz(*args):
  """
  qlgetz(li, fpos) -> char *


  Read a zero-terminated string from the input. If fpos == -1 then no
  seek will be performed.
  
  @param li (C++: linput_t *)
  @param fpos (C++: int64)
  """
  return _ida_diskio.qlgetz(*args)

def open_linput(*args):
  """
  open_linput(file, remote) -> linput_t *


  Open loader input.
  
  
  @param file (C++: const char *)
  @param remote (C++: bool)
  """
  return _ida_diskio.open_linput(*args)
class generic_linput_t(object):
    """
    Proxy of C++ generic_linput_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    filesize = _swig_property(_ida_diskio.generic_linput_t_filesize_get, _ida_diskio.generic_linput_t_filesize_set)
    blocksize = _swig_property(_ida_diskio.generic_linput_t_blocksize_get, _ida_diskio.generic_linput_t_blocksize_set)
    def read(self, *args):
        """
        read(self, off, buffer, nbytes) -> ssize_t
        """
        return _ida_diskio.generic_linput_t_read(self, *args)

    __swig_destroy__ = _ida_diskio.delete_generic_linput_t
    __del__ = lambda self : None;
generic_linput_t_swigregister = _ida_diskio.generic_linput_t_swigregister
generic_linput_t_swigregister(generic_linput_t)


def create_generic_linput(*args):
  """
  create_generic_linput(gl) -> linput_t *


  Create a generic linput
  
  @param gl: linput description. this object will be destroyed by
             close_linput()  using "delete gl;" (C++: generic_linput_t
             *)
  """
  return _ida_diskio.create_generic_linput(*args)

def create_memory_linput(*args):
  """
  create_memory_linput(start, size) -> linput_t *


  Create a linput for process memory. This linput will use
  read_dbg_memory() to read data.
  
  @param start: starting address of the input (C++: ea_t)
  @param size: size of the memory area to represent as linput if
               unknown, may be passed as 0 (C++: asize_t)
  """
  return _ida_diskio.create_memory_linput(*args)

def get_linput_type(*args):
  """
  get_linput_type(li) -> linput_type_t


  Get linput type.
  
  
  @param li (C++: linput_t *)
  """
  return _ida_diskio.get_linput_type(*args)

def eclose(*args):
  """
  eclose(fp)
  """
  return _ida_diskio.eclose(*args)

def enumerate_files(*args):
  """
  enumerate_files(path, fname, callback) -> PyObject *


  Enumerate files in the specified directory while the callback returns 0.
  @param path: directory to enumerate files in
  @param fname: mask of file names to enumerate
  @param callback: a callable object that takes the filename as
                   its first argument and it returns 0 to continue
                   enumeration or non-zero to stop enumeration.
  @return:
      None in case of script errors
      tuple(code, fname) : If the callback returns non-zero
  """
  return _ida_diskio.enumerate_files(*args)

def create_bytearray_linput(*args):
  """
  create_bytearray_linput(s) -> linput_t *


  Trivial memory linput.
  """
  return _ida_diskio.create_bytearray_linput(*args)

def close_linput(*args):
  """
  close_linput(li)


  Close loader input.
  
  
  @param li (C++: linput_t *)
  """
  return _ida_diskio.close_linput(*args)
#<pycode(py_diskio)>
#</pycode(py_diskio)>

if _BC695:
    create_generic_linput64=create_generic_linput
    generic_linput64_t=generic_linput_t



