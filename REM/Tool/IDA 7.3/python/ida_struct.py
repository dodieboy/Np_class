# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: struct
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_struct', [dirname(__file__)])
        except ImportError:
            import _ida_struct
            return _ida_struct
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_struct', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_struct = swig_import_helper()
    del swig_import_helper
else:
    import _ida_struct
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def get_member_size(*args):
  """
  get_member_size(nonnul_mptr) -> asize_t


  Get size of structure member. May return 0 for the last member of
  varstruct. For union members, returns 'member_t::eoff' .
  """
  return _ida_struct.get_member_size(*args)
STRUC_SEPARATOR = _ida_struct.STRUC_SEPARATOR
"""
structname.fieldname
"""
class member_t(object):
    """
    Proxy of C++ member_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    id = _swig_property(_ida_struct.member_t_id_get, _ida_struct.member_t_id_set)
    soff = _swig_property(_ida_struct.member_t_soff_get, _ida_struct.member_t_soff_set)
    eoff = _swig_property(_ida_struct.member_t_eoff_get, _ida_struct.member_t_eoff_set)
    flag = _swig_property(_ida_struct.member_t_flag_get, _ida_struct.member_t_flag_set)
    props = _swig_property(_ida_struct.member_t_props_get, _ida_struct.member_t_props_set)
    def unimem(self, *args):
        """
        unimem(self) -> bool
        """
        return _ida_struct.member_t_unimem(self, *args)

    def has_union(self, *args):
        """
        has_union(self) -> bool
        """
        return _ida_struct.member_t_has_union(self, *args)

    def by_til(self, *args):
        """
        by_til(self) -> bool
        """
        return _ida_struct.member_t_by_til(self, *args)

    def has_ti(self, *args):
        """
        has_ti(self) -> bool
        """
        return _ida_struct.member_t_has_ti(self, *args)

    def is_baseclass(self, *args):
        """
        is_baseclass(self) -> bool
        """
        return _ida_struct.member_t_is_baseclass(self, *args)

    def is_dupname(self, *args):
        """
        is_dupname(self) -> bool
        """
        return _ida_struct.member_t_is_dupname(self, *args)

    def is_destructor(self, *args):
        """
        is_destructor(self) -> bool
        """
        return _ida_struct.member_t_is_destructor(self, *args)

    def get_soff(self, *args):
        """
        get_soff(self) -> ea_t
        """
        return _ida_struct.member_t_get_soff(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> member_t
        """
        this = _ida_struct.new_member_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_struct.delete_member_t
    __del__ = lambda self : None;
member_t_swigregister = _ida_struct.member_t_swigregister
member_t_swigregister(member_t)
MF_OK = _ida_struct.MF_OK
"""
is the member ok? (always yes)
"""
MF_UNIMEM = _ida_struct.MF_UNIMEM
"""
is a member of a union?
"""
MF_HASUNI = _ida_struct.MF_HASUNI
"""
has members of type "union"?
"""
MF_BYTIL = _ida_struct.MF_BYTIL
"""
the member was created due to the type system
"""
MF_HASTI = _ida_struct.MF_HASTI
"""
has type information?
"""
MF_BASECLASS = _ida_struct.MF_BASECLASS
"""
a special member representing base class
"""
MF_DTOR = _ida_struct.MF_DTOR
"""
a special member representing destructor
"""
MF_DUPNAME = _ida_struct.MF_DUPNAME
"""
duplicate name resolved with _N suffix (N==soff)
"""

class struc_t(object):
    """
    Proxy of C++ struc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    id = _swig_property(_ida_struct.struc_t_id_get, _ida_struct.struc_t_id_set)
    memqty = _swig_property(_ida_struct.struc_t_memqty_get, _ida_struct.struc_t_memqty_set)
    members = _swig_property(_ida_struct.struc_t_members_get, _ida_struct.struc_t_members_set)
    age = _swig_property(_ida_struct.struc_t_age_get, _ida_struct.struc_t_age_set)
    props = _swig_property(_ida_struct.struc_t_props_get, _ida_struct.struc_t_props_set)
    def is_varstr(self, *args):
        """
        is_varstr(self) -> bool
        """
        return _ida_struct.struc_t_is_varstr(self, *args)

    def is_union(self, *args):
        """
        is_union(self) -> bool
        """
        return _ida_struct.struc_t_is_union(self, *args)

    def has_union(self, *args):
        """
        has_union(self) -> bool
        """
        return _ida_struct.struc_t_has_union(self, *args)

    def is_choosable(self, *args):
        """
        is_choosable(self) -> bool
        """
        return _ida_struct.struc_t_is_choosable(self, *args)

    def from_til(self, *args):
        """
        from_til(self) -> bool
        """
        return _ida_struct.struc_t_from_til(self, *args)

    def is_hidden(self, *args):
        """
        is_hidden(self) -> bool
        """
        return _ida_struct.struc_t_is_hidden(self, *args)

    def is_frame(self, *args):
        """
        is_frame(self) -> bool
        """
        return _ida_struct.struc_t_is_frame(self, *args)

    def get_alignment(self, *args):
        """
        get_alignment(self) -> int
        """
        return _ida_struct.struc_t_get_alignment(self, *args)

    def is_ghost(self, *args):
        """
        is_ghost(self) -> bool
        """
        return _ida_struct.struc_t_is_ghost(self, *args)

    def set_alignment(self, *args):
        """
        set_alignment(self, shift)
        """
        return _ida_struct.struc_t_set_alignment(self, *args)

    def set_ghost(self, *args):
        """
        set_ghost(self, _is_ghost)
        """
        return _ida_struct.struc_t_set_ghost(self, *args)

    ordinal = _swig_property(_ida_struct.struc_t_ordinal_get, _ida_struct.struc_t_ordinal_set)
    def get_member(self, *args):
        """
        get_member(self, index) -> member_t
        """
        return _ida_struct.struc_t_get_member(self, *args)

    __swig_destroy__ = _ida_struct.delete_struc_t
    __del__ = lambda self : None;
struc_t_swigregister = _ida_struct.struc_t_swigregister
struc_t_swigregister(struc_t)
SF_VAR = _ida_struct.SF_VAR
"""
is variable size structure (varstruct)? a variable size structure is
one with the zero size last member. if the last member is a varstruct,
then the current structure is a varstruct too.
"""
SF_UNION = _ida_struct.SF_UNION
"""
varunions are prohibited!

is a union?
"""
SF_HASUNI = _ida_struct.SF_HASUNI
"""
has members of type "union"?
"""
SF_NOLIST = _ida_struct.SF_NOLIST
"""
don't include in the chooser list
"""
SF_TYPLIB = _ida_struct.SF_TYPLIB
"""
the structure comes from type library
"""
SF_HIDDEN = _ida_struct.SF_HIDDEN
"""
the structure is collapsed
"""
SF_FRAME = _ida_struct.SF_FRAME
"""
the structure is a function frame
"""
SF_ALIGN = _ida_struct.SF_ALIGN
"""
alignment (shift amount: 0..31)
"""
SF_GHOST = _ida_struct.SF_GHOST
"""
ghost copy of a local type
"""


def get_struc_qty(*args):
  """
  get_struc_qty() -> size_t


  Get number of known structures.
  """
  return _ida_struct.get_struc_qty(*args)

def get_first_struc_idx(*args):
  """
  get_first_struc_idx() -> uval_t


  Get index of first structure.
  
  @return: BADADDR  if no known structures, 0 otherwise
  """
  return _ida_struct.get_first_struc_idx(*args)

def get_last_struc_idx(*args):
  """
  get_last_struc_idx() -> uval_t


  Get index of last structure.
  
  @return: BADADDR  if no known structures,  get_struc_qty() -1
           otherwise
  """
  return _ida_struct.get_last_struc_idx(*args)

def get_prev_struc_idx(*args):
  """
  get_prev_struc_idx(idx) -> uval_t


  Get previous struct index.
  
  @param idx (C++: uval_t)
  @return: BADADDR  if resulting index is negative, otherwise idx - 1
  """
  return _ida_struct.get_prev_struc_idx(*args)

def get_next_struc_idx(*args):
  """
  get_next_struc_idx(idx) -> uval_t


  Get next struct index.
  
  @param idx (C++: uval_t)
  @return: BADADDR  if resulting index is out of bounds, otherwise idx++
  """
  return _ida_struct.get_next_struc_idx(*args)

def get_struc_idx(*args):
  """
  get_struc_idx(id) -> uval_t


  Get internal number of the structure.
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.get_struc_idx(*args)

def get_struc_by_idx(*args):
  """
  get_struc_by_idx(idx) -> tid_t


  Get struct id by struct number.
  
  
  @param idx (C++: uval_t)
  """
  return _ida_struct.get_struc_by_idx(*args)

def get_struc(*args):
  """
  get_struc(id) -> struc_t


  Get pointer to struct type info.
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.get_struc(*args)

def get_struc_id(*args):
  """
  get_struc_id(name) -> tid_t


  Get struct id by name.
  
  
  @param name (C++: const char *)
  """
  return _ida_struct.get_struc_id(*args)

def get_struc_name(*args):
  """
  get_struc_name(id) -> ssize_t


  Get struct name by id.
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.get_struc_name(*args)

def get_struc_cmt(*args):
  """
  get_struc_cmt(id, repeatable) -> ssize_t


  Get struct comment.
  
  
  @param id (C++: tid_t)
  @param repeatable (C++: bool)
  """
  return _ida_struct.get_struc_cmt(*args)

def get_struc_size(*args):
  """
    get_struc_size(sptr) -> asize_t
    get_struc_size(id) -> asize_t


  Get struct size (also see 'get_struc_size(tid_t)' )
  
  
  @param sptr (C++: const  struc_t  *)
    """
  return _ida_struct.get_struc_size(*args)

def get_struc_prev_offset(*args):
  """
  get_struc_prev_offset(sptr, offset) -> ea_t


  Get offset of member with largest offset less than 'offset'.
  
  @param sptr (C++: const  struc_t  *)
  @param offset (C++: ea_t)
  @return: BADADDR  if no prev offset
  """
  return _ida_struct.get_struc_prev_offset(*args)

def get_struc_next_offset(*args):
  """
  get_struc_next_offset(sptr, offset) -> ea_t


  Get offset of member with smallest offset larger than 'offset'.
  
  @param sptr (C++: const  struc_t  *)
  @param offset (C++: ea_t)
  @return: BADADDR  if no next offset
  """
  return _ida_struct.get_struc_next_offset(*args)

def get_struc_last_offset(*args):
  """
  get_struc_last_offset(sptr) -> ea_t


  Get offset of last member.
  
  @param sptr (C++: const  struc_t  *)
  @return: BADADDR  if memqty == 0
  """
  return _ida_struct.get_struc_last_offset(*args)

def get_struc_first_offset(*args):
  """
  get_struc_first_offset(sptr) -> ea_t


  Get offset of first member.
  
  @param sptr (C++: const  struc_t  *)
  @return: BADADDR  if memqty == 0
  """
  return _ida_struct.get_struc_first_offset(*args)

def get_max_offset(*args):
  """
  get_max_offset(sptr) -> ea_t


  For unions: returns number of members, for structs: returns size of
  structure.
  
  
  @param sptr (C++: struc_t  *)
  """
  return _ida_struct.get_max_offset(*args)

def is_varstr(*args):
  """
  is_varstr(id) -> bool


  Is variable size structure?
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.is_varstr(*args)

def is_union(*args):
  """
  is_union(id) -> bool


  Is a union?
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.is_union(*args)

def get_member_struc(*args):
  """
  get_member_struc(fullname) -> struc_t


  Get containing structure of member by its full name "struct.field".
  
  
  @param fullname (C++: const char *)
  """
  return _ida_struct.get_member_struc(*args)

def get_sptr(*args):
  """
  get_sptr(mptr) -> struc_t


  Get child struct if member is a struct.
  
  
  @param mptr (C++: const  member_t  *)
  """
  return _ida_struct.get_sptr(*args)

def get_member(*args):
  """
  get_member(sptr, offset) -> member_t


  Get member at given offset.
  
  
  @param sptr (C++: const  struc_t  *)
  @param offset (C++: asize_t)
  """
  return _ida_struct.get_member(*args)

def get_member_id(*args):
  """
  get_member_id(sptr, offset) -> tid_t


  Get member id at given offset.
  
  
  @param sptr (C++: const  struc_t  *)
  @param offset (C++: asize_t)
  """
  return _ida_struct.get_member_id(*args)

def get_member_by_name(*args):
  """
  get_member_by_name(sptr, membername) -> member_t


  Get a member by its name, like "field44".
  
  
  @param sptr (C++: const  struc_t  *)
  @param membername (C++: const char *)
  """
  return _ida_struct.get_member_by_name(*args)

def get_member_by_fullname(*args):
  """
  get_member_by_fullname(fullname) -> member_t


  Get a member by its fully qualified name, "struct.field".
  
  
  @param fullname (C++: const char *)
  """
  return _ida_struct.get_member_by_fullname(*args)

def get_member_fullname(*args):
  """
  get_member_fullname(mid) -> ssize_t


  Get a member's fully qualified name, "struct.field".
  
  
  @param mid (C++: tid_t)
  """
  return _ida_struct.get_member_fullname(*args)

def get_member_name(*args):
  """
  get_member_name(mid) -> ssize_t


  Get name of structure member.
  
  
  @param mid (C++: tid_t)
  """
  return _ida_struct.get_member_name(*args)

def get_member_cmt(*args):
  """
  get_member_cmt(mid, repeatable) -> ssize_t


  Get comment of structure member.
  
  
  @param mid (C++: tid_t)
  @param repeatable (C++: bool)
  """
  return _ida_struct.get_member_cmt(*args)

def is_varmember(*args):
  """
  is_varmember(mptr) -> bool


  Is variable size member?
  
  
  @param mptr (C++: const  member_t  *)
  """
  return _ida_struct.is_varmember(*args)

def get_best_fit_member(*args):
  """
  get_best_fit_member(sptr, offset) -> member_t


  Get member that is most likely referenced by the specified offset.
  Useful for offsets > sizeof(struct).
  
  @param sptr (C++: const  struc_t  *)
  @param offset (C++: asize_t)
  """
  return _ida_struct.get_best_fit_member(*args)

def get_next_member_idx(*args):
  """
  get_next_member_idx(sptr, off) -> ssize_t


  Get the next member idx, if it does not exist, return -1.
  
  
  @param sptr (C++: const  struc_t  *)
  @param off (C++: asize_t)
  """
  return _ida_struct.get_next_member_idx(*args)

def get_prev_member_idx(*args):
  """
  get_prev_member_idx(sptr, off) -> ssize_t


  Get the prev member idx, if it does not exist, return -1.
  
  
  @param sptr (C++: const  struc_t  *)
  @param off (C++: asize_t)
  """
  return _ida_struct.get_prev_member_idx(*args)

def add_struc(*args):
  """
  add_struc(idx, name, is_union=False) -> tid_t


  Create a structure type. if idx== 'BADADDR' then add as the last idx.
  if name==NULL then a name will be generated "struct_%d".
  
  @param idx (C++: uval_t)
  @param name (C++: const char *)
  @param is_union (C++: bool)
  """
  return _ida_struct.add_struc(*args)

def del_struc(*args):
  """
  del_struc(sptr) -> bool


  Delete a structure type.
  
  
  @param sptr (C++: struc_t  *)
  """
  return _ida_struct.del_struc(*args)

def set_struc_idx(*args):
  """
  set_struc_idx(sptr, idx) -> bool


  Set internal number of struct. Also see 'get_struc_idx()' ,
  'get_struc_by_idx()' .
  
  @param sptr (C++: const  struc_t  *)
  @param idx (C++: uval_t)
  """
  return _ida_struct.set_struc_idx(*args)

def set_struc_align(*args):
  """
  set_struc_align(sptr, shift) -> bool


  Set structure alignment ( 'SF_ALIGN' )
  
  
  @param sptr (C++: struc_t  *)
  @param shift (C++: int)
  """
  return _ida_struct.set_struc_align(*args)

def set_struc_name(*args):
  """
  set_struc_name(id, name) -> bool


  Set structure name.
  
  
  @param id (C++: tid_t)
  @param name (C++: const char *)
  """
  return _ida_struct.set_struc_name(*args)

def set_struc_cmt(*args):
  """
  set_struc_cmt(id, cmt, repeatable) -> bool


  Set structure comment.
  
  
  @param id (C++: tid_t)
  @param cmt (C++: const char *)
  @param repeatable (C++: bool)
  """
  return _ida_struct.set_struc_cmt(*args)
STRUC_ERROR_MEMBER_OK = _ida_struct.STRUC_ERROR_MEMBER_OK
STRUC_ERROR_MEMBER_NAME = _ida_struct.STRUC_ERROR_MEMBER_NAME
STRUC_ERROR_MEMBER_OFFSET = _ida_struct.STRUC_ERROR_MEMBER_OFFSET
STRUC_ERROR_MEMBER_SIZE = _ida_struct.STRUC_ERROR_MEMBER_SIZE
STRUC_ERROR_MEMBER_TINFO = _ida_struct.STRUC_ERROR_MEMBER_TINFO
STRUC_ERROR_MEMBER_STRUCT = _ida_struct.STRUC_ERROR_MEMBER_STRUCT
STRUC_ERROR_MEMBER_UNIVAR = _ida_struct.STRUC_ERROR_MEMBER_UNIVAR
STRUC_ERROR_MEMBER_VARLAST = _ida_struct.STRUC_ERROR_MEMBER_VARLAST
STRUC_ERROR_MEMBER_NESTED = _ida_struct.STRUC_ERROR_MEMBER_NESTED

def add_struc_member(*args):
  """
  add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t


  Add member to existing structure.
  
  @param sptr: structure to modify (C++: struc_t  *)
  @param fieldname: if NULL, then "anonymous_#" name will be generated
                    (C++: const char *)
  @param offset: BADADDR  means add to the end of structure (C++: ea_t)
  @param flag: type + representation bits (C++: flags_t)
  @param mt: additional info about member type. must be present for
             structs, offsets, enums, strings, struct offsets. (C++:
             const  opinfo_t  *)
  @param nbytes: if == 0 then the structure will be a varstruct. in this
                 case the member should be the last member in the
                 structure (C++: asize_t)
  """
  return _ida_struct.add_struc_member(*args)

def del_struc_member(*args):
  """
  del_struc_member(sptr, offset) -> bool


  Delete member at given offset.
  
  
  @param sptr (C++: struc_t  *)
  @param offset (C++: ea_t)
  """
  return _ida_struct.del_struc_member(*args)

def del_struc_members(*args):
  """
  del_struc_members(sptr, off1, off2) -> int


  Delete members which occupy range of offsets (off1..off2).
  
  @param sptr (C++: struc_t  *)
  @param off1 (C++: ea_t)
  @param off2 (C++: ea_t)
  @return: number of deleted members or -1 on error
  """
  return _ida_struct.del_struc_members(*args)

def set_member_name(*args):
  """
  set_member_name(sptr, offset, name) -> bool


  Set name of member at given offset.
  
  
  @param sptr (C++: struc_t  *)
  @param offset (C++: ea_t)
  @param name (C++: const char *)
  """
  return _ida_struct.set_member_name(*args)

def set_member_type(*args):
  """
  set_member_type(sptr, offset, flag, mt, nbytes) -> bool


  Set type of member at given offset (also see 'add_struc_member()' )
  
  
  @param sptr (C++: struc_t  *)
  @param offset (C++: ea_t)
  @param flag (C++: flags_t)
  @param mt (C++: const  opinfo_t  *)
  @param nbytes (C++: asize_t)
  """
  return _ida_struct.set_member_type(*args)

def set_member_cmt(*args):
  """
  set_member_cmt(mptr, cmt, repeatable) -> bool


  Set member comment.
  
  
  @param mptr (C++: member_t  *)
  @param cmt (C++: const char *)
  @param repeatable (C++: bool)
  """
  return _ida_struct.set_member_cmt(*args)

def expand_struc(*args):
  """
  expand_struc(sptr, offset, delta, recalc=True) -> bool


  Expand/Shrink structure type.
  
  
  @param sptr (C++: struc_t  *)
  @param offset (C++: ea_t)
  @param delta (C++: adiff_t)
  @param recalc (C++: bool)
  """
  return _ida_struct.expand_struc(*args)

def save_struc(*args):
  """
  save_struc(sptr, may_update_ltypes=True)


  Update struct information in the database (internal function)
  
  
  @param sptr (C++: struc_t  *)
  @param may_update_ltypes (C++: bool)
  """
  return _ida_struct.save_struc(*args)

def set_struc_hidden(*args):
  """
  set_struc_hidden(sptr, is_hidden)


  Hide/unhide a struct type.
  
  
  @param sptr (C++: struc_t  *)
  @param is_hidden (C++: bool)
  """
  return _ida_struct.set_struc_hidden(*args)

def set_struc_listed(*args):
  """
  set_struc_listed(sptr, is_listed)


  Add/remove a struct type from the struct list.
  
  
  @param sptr (C++: struc_t  *)
  @param is_listed (C++: bool)
  """
  return _ida_struct.set_struc_listed(*args)
SMT_BADARG = _ida_struct.SMT_BADARG
SMT_NOCOMPAT = _ida_struct.SMT_NOCOMPAT
SMT_WORSE = _ida_struct.SMT_WORSE
SMT_SIZE = _ida_struct.SMT_SIZE
SMT_ARRAY = _ida_struct.SMT_ARRAY
SMT_OVERLAP = _ida_struct.SMT_OVERLAP
SMT_FAILED = _ida_struct.SMT_FAILED
SMT_OK = _ida_struct.SMT_OK
SMT_KEEP = _ida_struct.SMT_KEEP

def get_member_tinfo(*args):
  """
  get_member_tinfo(tif, mptr) -> bool


  Get tinfo for given member.
  
  
  @param tif (C++: tinfo_t  *)
  @param mptr (C++: const  member_t  *)
  """
  return _ida_struct.get_member_tinfo(*args)

def del_member_tinfo(*args):
  """
  del_member_tinfo(sptr, mptr) -> bool


  Delete tinfo for given member.
  
  
  @param sptr (C++: struc_t  *)
  @param mptr (C++: member_t  *)
  """
  return _ida_struct.del_member_tinfo(*args)

def set_member_tinfo(*args):
  """
  set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t


  Set tinfo for given member.
  
  @param sptr: containing struct (C++: struc_t  *)
  @param mptr: target member (C++: member_t  *)
  @param memoff: offset within member (C++: uval_t)
  @param tif: type info (C++: const  tinfo_t  &)
  @param flags: Set member tinfo flags (C++: int)
  """
  return _ida_struct.set_member_tinfo(*args)
SET_MEMTI_MAY_DESTROY = _ida_struct.SET_MEMTI_MAY_DESTROY
"""
may destroy other members
"""
SET_MEMTI_COMPATIBLE = _ida_struct.SET_MEMTI_COMPATIBLE
"""
new type must be compatible with the old
"""
SET_MEMTI_FUNCARG = _ida_struct.SET_MEMTI_FUNCARG
"""
mptr is function argument (cannot create arrays)
"""
SET_MEMTI_BYTIL = _ida_struct.SET_MEMTI_BYTIL
"""
new type was created by the type subsystem
"""
SET_MEMTI_USERTI = _ida_struct.SET_MEMTI_USERTI
"""
user-specified type
"""

def get_or_guess_member_tinfo(*args):
  """
  get_or_guess_member_tinfo(tif, mptr) -> bool


  Try to get tinfo for given member - if failed, generate a tinfo using
  information about the member id from the disassembly
  
  @param tif (C++: tinfo_t  *)
  @param mptr (C++: const  member_t  *)
  """
  return _ida_struct.get_or_guess_member_tinfo(*args)

def retrieve_member_info(*args):
  """
  retrieve_member_info(buf, mptr) -> opinfo_t


  Get operand type info for member.
  
  
  @param buf (C++: opinfo_t  *)
  @param mptr (C++: const  member_t  *)
  """
  return _ida_struct.retrieve_member_info(*args)

def is_anonymous_member_name(*args):
  """
  is_anonymous_member_name(name) -> bool


  Is member name prefixed with "anonymous"?
  
  
  @param name (C++: const char *)
  """
  return _ida_struct.is_anonymous_member_name(*args)

def is_dummy_member_name(*args):
  """
  is_dummy_member_name(name) -> bool


  Is member name an auto-generated name?
  
  
  @param name (C++: const char *)
  """
  return _ida_struct.is_dummy_member_name(*args)

def get_member_by_id(*args):
  """
  get_member_by_id(mid) -> member_t


  Check if the specified member id points to a struct member.
  
  
  @param mid (C++: tid_t)
  """
  return _ida_struct.get_member_by_id(*args)

def is_member_id(*args):
  """
  is_member_id(mid) -> bool


  Is a member id?
  
  
  @param mid (C++: tid_t)
  """
  return _ida_struct.is_member_id(*args)

def is_special_member(*args):
  """
  is_special_member(id) -> bool


  Is a special member with the name beginning with ' '?
  
  
  @param id (C++: tid_t)
  """
  return _ida_struct.is_special_member(*args)
class struct_field_visitor_t(object):
    """
    Proxy of C++ struct_field_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def visit_field(self, *args):
        """
        visit_field(self, sptr, mptr) -> int
        """
        return _ida_struct.struct_field_visitor_t_visit_field(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> struct_field_visitor_t
        """
        if self.__class__ == struct_field_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_struct.new_struct_field_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_struct.delete_struct_field_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_struct.disown_struct_field_visitor_t(self)
        return weakref_proxy(self)
struct_field_visitor_t_swigregister = _ida_struct.struct_field_visitor_t_swigregister
struct_field_visitor_t_swigregister(struct_field_visitor_t)


def visit_stroff_fields(*args):
  """
  visit_stroff_fields(sfv, path, disp, appzero) -> flags_t


  Visit structure fields in a stroff expression or in a reference to a
  struct data variable. This function can be used to enumerate all
  components of an expression like 'a.b.c'.
  
  @param sfv: visitor object (C++: struct_field_visitor_t  &)
  @param path: struct path (path[0] contains the initial struct id)
               (C++: const  tid_t  *)
  @param disp: offset into structure (C++: adiff_t *)
  @param appzero: should visit field at offset zero? (C++: bool)
  """
  return _ida_struct.visit_stroff_fields(*args)

def stroff_as_size(*args):
  """
  stroff_as_size(plen, sptr, value) -> bool


  Should display a structure offset expression as the structure size?
  
  
  @param plen (C++: int)
  @param sptr (C++: const  struc_t  *)
  @param value (C++: asize_t)
  """
  return _ida_struct.stroff_as_size(*args)
if _BC695:
    get_member_name2=get_member_name
    def get_member_tinfo(*args):
        import ida_typeinf
        if isinstance(args[1], ida_typeinf.tinfo_t):  # 6.95: mptr, tinfo_t
            mptr, tif = args
        else:                                         # 7.00: tinfo_t, mptr
            tif, mptr = args
        return _ida_struct.get_member_tinfo(tif, mptr);
    def get_or_guess_member_tinfo(*args):
        import ida_typeinf
        if isinstance(args[1], ida_typeinf.tinfo_t):  # 6.95: mptr, tinfo_t
            mptr, tif = args
        else:                                         # 7.00: tinfo_t, mptr
            tif, mptr = args
        return _ida_struct.get_or_guess_member_tinfo(tif, mptr);
    # note: if needed we might have to re-implement get_member_tinfo()
    # and look whether there is a 2nd, 'tinfo_t' parameter (since the
    # original get_member_tinfo function has a different signature)
    get_member_tinfo2=get_member_tinfo
    # same here
    get_or_guess_member_tinfo2=get_or_guess_member_tinfo
    save_struc2=save_struc
    set_member_tinfo2=set_member_tinfo



