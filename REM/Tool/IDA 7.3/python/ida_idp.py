# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: idp
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_idp', [dirname(__file__)])
        except ImportError:
            import _ida_idp
            return _ida_idp
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_idp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_idp = swig_import_helper()
    del swig_import_helper
else:
    import _ida_idp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def AssembleLine(*args):
  """
  AssembleLine(ea, cs, ip, use32, nonnul_line) -> PyObject *


  Assemble an instruction to a string (display a warning if an error is found)
  
  @param ea: linear address of instruction
  @param cs:  cs of instruction
  @param ip:  ip of instruction
  @param use32: is 32bit segment
  @param line: line to assemble
  @return:
      - None on failure
      - or a string containing the assembled instruction
  """
  return _ida_idp.AssembleLine(*args)
IDP_INTERFACE_VERSION = _ida_idp.IDP_INTERFACE_VERSION
"""
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'
"""

def has_cf_chg(*args):
  """
  has_cf_chg(feature, opnum) -> bool


  Does an instruction with the specified feature modify the i-th
  operand?
  
  
  @param feature (C++: uint32)
  @param opnum (C++: uint)
  """
  return _ida_idp.has_cf_chg(*args)

def has_cf_use(*args):
  """
  has_cf_use(feature, opnum) -> bool


  Does an instruction with the specified feature use a value of the i-th
  operand?
  
  
  @param feature (C++: uint32)
  @param opnum (C++: uint)
  """
  return _ida_idp.has_cf_use(*args)

def has_insn_feature(*args):
  """
  has_insn_feature(icode, bit) -> bool


  Does the specified instruction have the specified feature?
  
  
  @param icode (C++: int)
  @param bit (C++: uint32)
  """
  return _ida_idp.has_insn_feature(*args)

def is_call_insn(*args):
  """
  is_call_insn(insn) -> bool


  Is the instruction a "call"?
  
  
  @param insn (C++: const  insn_t  &)
  """
  return _ida_idp.is_call_insn(*args)

def is_ret_insn(*args):
  """
  is_ret_insn(insn, strict=True) -> bool


  Is the instruction a "return"?
  
  
  @param insn (C++: const  insn_t  &)
  @param strict (C++: bool)
  """
  return _ida_idp.is_ret_insn(*args)

def is_indirect_jump_insn(*args):
  """
  is_indirect_jump_insn(insn) -> bool


  Is the instruction an indirect jump?
  
  
  @param insn (C++: const  insn_t  &)
  """
  return _ida_idp.is_indirect_jump_insn(*args)

def is_basic_block_end(*args):
  """
  is_basic_block_end(insn, call_insn_stops_block) -> bool


  Is the instruction the end of a basic block?
  
  
  @param insn (C++: const  insn_t  &)
  @param call_insn_stops_block (C++: bool)
  """
  return _ida_idp.is_basic_block_end(*args)
class asm_t(object):
    """
    Proxy of C++ asm_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flag = _swig_property(_ida_idp.asm_t_flag_get, _ida_idp.asm_t_flag_set)
    uflag = _swig_property(_ida_idp.asm_t_uflag_get, _ida_idp.asm_t_uflag_set)
    name = _swig_property(_ida_idp.asm_t_name_get, _ida_idp.asm_t_name_set)
    help = _swig_property(_ida_idp.asm_t_help_get, _ida_idp.asm_t_help_set)
    header = _swig_property(_ida_idp.asm_t_header_get, _ida_idp.asm_t_header_set)
    origin = _swig_property(_ida_idp.asm_t_origin_get, _ida_idp.asm_t_origin_set)
    end = _swig_property(_ida_idp.asm_t_end_get, _ida_idp.asm_t_end_set)
    cmnt = _swig_property(_ida_idp.asm_t_cmnt_get, _ida_idp.asm_t_cmnt_set)
    ascsep = _swig_property(_ida_idp.asm_t_ascsep_get, _ida_idp.asm_t_ascsep_set)
    accsep = _swig_property(_ida_idp.asm_t_accsep_get, _ida_idp.asm_t_accsep_set)
    esccodes = _swig_property(_ida_idp.asm_t_esccodes_get, _ida_idp.asm_t_esccodes_set)
    a_ascii = _swig_property(_ida_idp.asm_t_a_ascii_get, _ida_idp.asm_t_a_ascii_set)
    a_byte = _swig_property(_ida_idp.asm_t_a_byte_get, _ida_idp.asm_t_a_byte_set)
    a_word = _swig_property(_ida_idp.asm_t_a_word_get, _ida_idp.asm_t_a_word_set)
    a_dword = _swig_property(_ida_idp.asm_t_a_dword_get, _ida_idp.asm_t_a_dword_set)
    a_qword = _swig_property(_ida_idp.asm_t_a_qword_get, _ida_idp.asm_t_a_qword_set)
    a_oword = _swig_property(_ida_idp.asm_t_a_oword_get, _ida_idp.asm_t_a_oword_set)
    a_float = _swig_property(_ida_idp.asm_t_a_float_get, _ida_idp.asm_t_a_float_set)
    a_double = _swig_property(_ida_idp.asm_t_a_double_get, _ida_idp.asm_t_a_double_set)
    a_tbyte = _swig_property(_ida_idp.asm_t_a_tbyte_get, _ida_idp.asm_t_a_tbyte_set)
    a_packreal = _swig_property(_ida_idp.asm_t_a_packreal_get, _ida_idp.asm_t_a_packreal_set)
    a_dups = _swig_property(_ida_idp.asm_t_a_dups_get, _ida_idp.asm_t_a_dups_set)
    a_bss = _swig_property(_ida_idp.asm_t_a_bss_get, _ida_idp.asm_t_a_bss_set)
    a_equ = _swig_property(_ida_idp.asm_t_a_equ_get, _ida_idp.asm_t_a_equ_set)
    a_seg = _swig_property(_ida_idp.asm_t_a_seg_get, _ida_idp.asm_t_a_seg_set)
    a_curip = _swig_property(_ida_idp.asm_t_a_curip_get, _ida_idp.asm_t_a_curip_set)
    a_public = _swig_property(_ida_idp.asm_t_a_public_get, _ida_idp.asm_t_a_public_set)
    a_weak = _swig_property(_ida_idp.asm_t_a_weak_get, _ida_idp.asm_t_a_weak_set)
    a_extrn = _swig_property(_ida_idp.asm_t_a_extrn_get, _ida_idp.asm_t_a_extrn_set)
    a_comdef = _swig_property(_ida_idp.asm_t_a_comdef_get, _ida_idp.asm_t_a_comdef_set)
    a_align = _swig_property(_ida_idp.asm_t_a_align_get, _ida_idp.asm_t_a_align_set)
    lbrace = _swig_property(_ida_idp.asm_t_lbrace_get, _ida_idp.asm_t_lbrace_set)
    rbrace = _swig_property(_ida_idp.asm_t_rbrace_get, _ida_idp.asm_t_rbrace_set)
    a_mod = _swig_property(_ida_idp.asm_t_a_mod_get, _ida_idp.asm_t_a_mod_set)
    a_band = _swig_property(_ida_idp.asm_t_a_band_get, _ida_idp.asm_t_a_band_set)
    a_bor = _swig_property(_ida_idp.asm_t_a_bor_get, _ida_idp.asm_t_a_bor_set)
    a_xor = _swig_property(_ida_idp.asm_t_a_xor_get, _ida_idp.asm_t_a_xor_set)
    a_bnot = _swig_property(_ida_idp.asm_t_a_bnot_get, _ida_idp.asm_t_a_bnot_set)
    a_shl = _swig_property(_ida_idp.asm_t_a_shl_get, _ida_idp.asm_t_a_shl_set)
    a_shr = _swig_property(_ida_idp.asm_t_a_shr_get, _ida_idp.asm_t_a_shr_set)
    a_sizeof_fmt = _swig_property(_ida_idp.asm_t_a_sizeof_fmt_get, _ida_idp.asm_t_a_sizeof_fmt_set)
    flag2 = _swig_property(_ida_idp.asm_t_flag2_get, _ida_idp.asm_t_flag2_set)
    cmnt2 = _swig_property(_ida_idp.asm_t_cmnt2_get, _ida_idp.asm_t_cmnt2_set)
    low8 = _swig_property(_ida_idp.asm_t_low8_get, _ida_idp.asm_t_low8_set)
    high8 = _swig_property(_ida_idp.asm_t_high8_get, _ida_idp.asm_t_high8_set)
    low16 = _swig_property(_ida_idp.asm_t_low16_get, _ida_idp.asm_t_low16_set)
    high16 = _swig_property(_ida_idp.asm_t_high16_get, _ida_idp.asm_t_high16_set)
    a_include_fmt = _swig_property(_ida_idp.asm_t_a_include_fmt_get, _ida_idp.asm_t_a_include_fmt_set)
    a_vstruc_fmt = _swig_property(_ida_idp.asm_t_a_vstruc_fmt_get, _ida_idp.asm_t_a_vstruc_fmt_set)
    a_rva = _swig_property(_ida_idp.asm_t_a_rva_get, _ida_idp.asm_t_a_rva_set)
    a_yword = _swig_property(_ida_idp.asm_t_a_yword_get, _ida_idp.asm_t_a_yword_set)
    def __init__(self, *args):
        """
        __init__(self) -> asm_t
        """
        this = _ida_idp.new_asm_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idp.delete_asm_t
    __del__ = lambda self : None;
asm_t_swigregister = _ida_idp.asm_t_swigregister
asm_t_swigregister(asm_t)
AS_OFFST = _ida_idp.AS_OFFST
"""
offsets are 'offset xxx' ?
"""
AS_COLON = _ida_idp.AS_COLON
"""
create colons after data names ?
"""
AS_UDATA = _ida_idp.AS_UDATA
"""
can use '?' in data directives
"""
AS_2CHRE = _ida_idp.AS_2CHRE
"""
double char constants are: "xy
"""
AS_NCHRE = _ida_idp.AS_NCHRE
"""
char constants are: 'x
"""
AS_N2CHR = _ida_idp.AS_N2CHR
"""
can't have 2 byte char consts
"""
AS_1TEXT = _ida_idp.AS_1TEXT
"""
1 text per line, no bytes
"""
AS_NHIAS = _ida_idp.AS_NHIAS
"""
no characters with high bit
"""
AS_NCMAS = _ida_idp.AS_NCMAS
"""
no commas in ascii directives
"""
AS_HEXFM = _ida_idp.AS_HEXFM
"""
mask - hex number format
"""
ASH_HEXF0 = _ida_idp.ASH_HEXF0
"""
34h
"""
ASH_HEXF1 = _ida_idp.ASH_HEXF1
"""
h'34
"""
ASH_HEXF2 = _ida_idp.ASH_HEXF2
"""
34
"""
ASH_HEXF3 = _ida_idp.ASH_HEXF3
"""
0x34
"""
ASH_HEXF4 = _ida_idp.ASH_HEXF4
"""
$34
"""
ASH_HEXF5 = _ida_idp.ASH_HEXF5
"""
<^R > (radix)
"""
AS_DECFM = _ida_idp.AS_DECFM
"""
mask - decimal number format
"""
ASD_DECF0 = _ida_idp.ASD_DECF0
"""
34
"""
ASD_DECF1 = _ida_idp.ASD_DECF1
"""
#34
"""
ASD_DECF2 = _ida_idp.ASD_DECF2
ASD_DECF3 = _ida_idp.ASD_DECF3
"""
.34
"""
AS_OCTFM = _ida_idp.AS_OCTFM
"""
mask - octal number format
"""
ASO_OCTF0 = _ida_idp.ASO_OCTF0
"""
123o
"""
ASO_OCTF1 = _ida_idp.ASO_OCTF1
"""
0123
"""
ASO_OCTF2 = _ida_idp.ASO_OCTF2
"""
123
"""
ASO_OCTF3 = _ida_idp.ASO_OCTF3
"""
@123
"""
ASO_OCTF4 = _ida_idp.ASO_OCTF4
"""
o'123
"""
ASO_OCTF5 = _ida_idp.ASO_OCTF5
"""
123q
"""
ASO_OCTF6 = _ida_idp.ASO_OCTF6
"""
~123
"""
ASO_OCTF7 = _ida_idp.ASO_OCTF7
"""
q'123
"""
AS_BINFM = _ida_idp.AS_BINFM
"""
mask - binary number format
"""
ASB_BINF0 = _ida_idp.ASB_BINF0
"""
010101b
"""
ASB_BINF1 = _ida_idp.ASB_BINF1
"""
^B010101
"""
ASB_BINF2 = _ida_idp.ASB_BINF2
"""
%010101
"""
ASB_BINF3 = _ida_idp.ASB_BINF3
"""
0b1010101
"""
ASB_BINF4 = _ida_idp.ASB_BINF4
"""
b'1010101
"""
ASB_BINF5 = _ida_idp.ASB_BINF5
"""
b'1010101'
"""
AS_UNEQU = _ida_idp.AS_UNEQU
"""
replace undefined data items with EQU (for ANTA's A80)
"""
AS_ONEDUP = _ida_idp.AS_ONEDUP
"""
One array definition per line.
"""
AS_NOXRF = _ida_idp.AS_NOXRF
"""
Disable xrefs during the output file generation.
"""
AS_XTRNTYPE = _ida_idp.AS_XTRNTYPE
"""
Assembler understands type of extern symbols as ":type" suffix.
"""
AS_RELSUP = _ida_idp.AS_RELSUP
"""
Checkarg: 'and','or','xor' operations with addresses are possible.
"""
AS_LALIGN = _ida_idp.AS_LALIGN
"""
Labels at "align" keyword are supported.
"""
AS_NOCODECLN = _ida_idp.AS_NOCODECLN
"""
don't create colons after code names
"""
AS_NOSPACE = _ida_idp.AS_NOSPACE
"""
No spaces in expressions.
"""
AS_ALIGN2 = _ida_idp.AS_ALIGN2
"""
(.align 5 means to align at 32byte boundary)

.align directive expects an exponent rather than a power of 2
"""
AS_ASCIIC = _ida_idp.AS_ASCIIC
"""
(\\n,\\x01 and similar)

ascii directive accepts C-like escape sequences
"""
AS_ASCIIZ = _ida_idp.AS_ASCIIZ
"""
ascii directive inserts implicit zero byte at the end
"""
AS2_BRACE = _ida_idp.AS2_BRACE
"""
Use braces for all expressions.
"""
AS2_STRINV = _ida_idp.AS2_STRINV
"""
(For processors with bytes bigger than 8 bits)

Invert meaning of \\inf{wide_high_byte_first} for text strings
"""
AS2_BYTE1CHAR = _ida_idp.AS2_BYTE1CHAR
"""
Meaningful only for wide byte processors.

One symbol per processor byte
"""
AS2_IDEALDSCR = _ida_idp.AS2_IDEALDSCR
"""
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal
"""
AS2_TERSESTR = _ida_idp.AS2_TERSESTR
"""
NAME<fld,fld,...> is supported.

'terse' structure initialization form
"""
AS2_COLONSUF = _ida_idp.AS2_COLONSUF
"""
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor
"""
AS2_YWORD = _ida_idp.AS2_YWORD
"""
a_yword field is present and valid
"""


def str2reg(*args):
  """
  str2reg(p) -> int


  Get any reg number (-1 on error)
  
  
  @param p (C++: const char *)
  """
  return _ida_idp.str2reg(*args)

def is_align_insn(*args):
  """
  is_align_insn(ea) -> int


  If the instruction at 'ea' looks like an alignment instruction, return
  its length in bytes. Otherwise return 0.
  
  @param ea (C++: ea_t)
  """
  return _ida_idp.is_align_insn(*args)

def get_reg_name(*args):
  """
  get_reg_name(reg, width, reghi=-1) -> ssize_t


  Get text representation of a register. For most processors this
  function will just return \ph{reg_names}[reg]. If the processor module
  has implemented processor_t::get_reg_name, it will be used instead
  
  @param reg: internal register number as defined in the processor
              module (C++: int)
  @param width: register width in bytes (C++: size_t)
  @param reghi: if specified, then this function will return the
                register pair (C++: int)
  @return: length of register name in bytes or -1 if failure
  """
  return _ida_idp.get_reg_name(*args)

def get_reg_info(*args):
  """
  get_reg_info(regname, bitrange) -> char const *


  Get register information - useful for registers like al, ah, dil, etc.
  
  @param regname (C++: const char *)
  @param bitrange (C++: bitrange_t  *)
  @return: NULL no such register
  """
  return _ida_idp.get_reg_info(*args)
class reg_info_t(object):
    """
    Proxy of C++ reg_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    reg = _swig_property(_ida_idp.reg_info_t_reg_get, _ida_idp.reg_info_t_reg_set)
    size = _swig_property(_ida_idp.reg_info_t_size_get, _ida_idp.reg_info_t_size_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_idp.reg_info_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_idp.reg_info_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> reg_info_t
        """
        this = _ida_idp.new_reg_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_idp.delete_reg_info_t
    __del__ = lambda self : None;
reg_info_t_swigregister = _ida_idp.reg_info_t_swigregister
reg_info_t_swigregister(reg_info_t)
cvar = _ida_idp.cvar


def parse_reg_name(*args):
  """
  parse_reg_name(ri, regname) -> bool


  Get register info by name.
  
  @param ri: result (C++: reg_info_t  *)
  @param regname: name of register (C++: const char *)
  @return: success
  """
  return _ida_idp.parse_reg_name(*args)

def sizeof_ldbl(*args):
  """
  sizeof_ldbl() -> size_t


  Get size of long double.
  """
  return _ida_idp.sizeof_ldbl(*args)
SETPROC_IDB = _ida_idp.SETPROC_IDB
SETPROC_LOADER = _ida_idp.SETPROC_LOADER
SETPROC_LOADER_NON_FATAL = _ida_idp.SETPROC_LOADER_NON_FATAL
SETPROC_USER = _ida_idp.SETPROC_USER

def set_processor_type(*args):
  """
  set_processor_type(procname, level) -> bool


  Set target processor type. Once a processor module is loaded, it
  cannot be replaced until we close the idb.
  
  @param procname: name of processor type (one of names present in
                   \ph{psnames}) (C++: const char *)
  @param level: SETPROC_ (C++: setproc_level_t)
  @return: success
  """
  return _ida_idp.set_processor_type(*args)

def get_idp_name(*args):
  """
  get_idp_name() -> char *


  Get name of the current processor module. The name is derived from the
  file name. For example, for IBM PC the module is named "pc.w32"
  (windows version), then the module name is "PC" (uppercase). If no
  processor module is loaded, this function will return NULL
  """
  return _ida_idp.get_idp_name(*args)

def set_target_assembler(*args):
  """
  set_target_assembler(asmnum) -> bool


  Set target assembler.
  
  @param asmnum: number of assembler in the current processor module
                 (C++: int)
  @return: success
  """
  return _ida_idp.set_target_assembler(*args)

def delay_slot_insn(*args):
  """
  delay_slot_insn(ea, bexec, fexec) -> bool


  Helper function to get the delay slot instruction.
  
  
  @param ea (C++: ea_t *)
  @param bexec (C++: bool *)
  @param fexec (C++: bool *)
  """
  return _ida_idp.delay_slot_insn(*args)
closebase = _ida_idp.closebase
savebase = _ida_idp.savebase
upgraded = _ida_idp.upgraded
auto_empty = _ida_idp.auto_empty
auto_empty_finally = _ida_idp.auto_empty_finally
determined_main = _ida_idp.determined_main
local_types_changed = _ida_idp.local_types_changed
extlang_changed = _ida_idp.extlang_changed
idasgn_loaded = _ida_idp.idasgn_loaded
kernel_config_loaded = _ida_idp.kernel_config_loaded
loader_finished = _ida_idp.loader_finished
flow_chart_created = _ida_idp.flow_chart_created
compiler_changed = _ida_idp.compiler_changed
changing_ti = _ida_idp.changing_ti
ti_changed = _ida_idp.ti_changed
changing_op_ti = _ida_idp.changing_op_ti
op_ti_changed = _ida_idp.op_ti_changed
changing_op_type = _ida_idp.changing_op_type
op_type_changed = _ida_idp.op_type_changed
enum_created = _ida_idp.enum_created
deleting_enum = _ida_idp.deleting_enum
enum_deleted = _ida_idp.enum_deleted
renaming_enum = _ida_idp.renaming_enum
enum_renamed = _ida_idp.enum_renamed
changing_enum_bf = _ida_idp.changing_enum_bf
enum_bf_changed = _ida_idp.enum_bf_changed
changing_enum_cmt = _ida_idp.changing_enum_cmt
enum_cmt_changed = _ida_idp.enum_cmt_changed
enum_member_created = _ida_idp.enum_member_created
deleting_enum_member = _ida_idp.deleting_enum_member
enum_member_deleted = _ida_idp.enum_member_deleted
struc_created = _ida_idp.struc_created
deleting_struc = _ida_idp.deleting_struc
struc_deleted = _ida_idp.struc_deleted
changing_struc_align = _ida_idp.changing_struc_align
struc_align_changed = _ida_idp.struc_align_changed
renaming_struc = _ida_idp.renaming_struc
struc_renamed = _ida_idp.struc_renamed
expanding_struc = _ida_idp.expanding_struc
struc_expanded = _ida_idp.struc_expanded
struc_member_created = _ida_idp.struc_member_created
deleting_struc_member = _ida_idp.deleting_struc_member
struc_member_deleted = _ida_idp.struc_member_deleted
renaming_struc_member = _ida_idp.renaming_struc_member
struc_member_renamed = _ida_idp.struc_member_renamed
changing_struc_member = _ida_idp.changing_struc_member
struc_member_changed = _ida_idp.struc_member_changed
changing_struc_cmt = _ida_idp.changing_struc_cmt
struc_cmt_changed = _ida_idp.struc_cmt_changed
segm_added = _ida_idp.segm_added
deleting_segm = _ida_idp.deleting_segm
segm_deleted = _ida_idp.segm_deleted
changing_segm_start = _ida_idp.changing_segm_start
segm_start_changed = _ida_idp.segm_start_changed
changing_segm_end = _ida_idp.changing_segm_end
segm_end_changed = _ida_idp.segm_end_changed
changing_segm_name = _ida_idp.changing_segm_name
segm_name_changed = _ida_idp.segm_name_changed
changing_segm_class = _ida_idp.changing_segm_class
segm_class_changed = _ida_idp.segm_class_changed
segm_attrs_updated = _ida_idp.segm_attrs_updated
segm_moved = _ida_idp.segm_moved
allsegs_moved = _ida_idp.allsegs_moved
func_added = _ida_idp.func_added
func_updated = _ida_idp.func_updated
set_func_start = _ida_idp.set_func_start
set_func_end = _ida_idp.set_func_end
deleting_func = _ida_idp.deleting_func
frame_deleted = _ida_idp.frame_deleted
thunk_func_created = _ida_idp.thunk_func_created
func_tail_appended = _ida_idp.func_tail_appended
deleting_func_tail = _ida_idp.deleting_func_tail
func_tail_deleted = _ida_idp.func_tail_deleted
tail_owner_changed = _ida_idp.tail_owner_changed
func_noret_changed = _ida_idp.func_noret_changed
stkpnts_changed = _ida_idp.stkpnts_changed
updating_tryblks = _ida_idp.updating_tryblks
tryblks_updated = _ida_idp.tryblks_updated
deleting_tryblks = _ida_idp.deleting_tryblks
sgr_changed = _ida_idp.sgr_changed
make_code = _ida_idp.make_code
make_data = _ida_idp.make_data
destroyed_items = _ida_idp.destroyed_items
renamed = _ida_idp.renamed
byte_patched = _ida_idp.byte_patched
changing_cmt = _ida_idp.changing_cmt
cmt_changed = _ida_idp.cmt_changed
changing_range_cmt = _ida_idp.changing_range_cmt
range_cmt_changed = _ida_idp.range_cmt_changed
extra_cmt_changed = _ida_idp.extra_cmt_changed
item_color_changed = _ida_idp.item_color_changed
callee_addr_changed = _ida_idp.callee_addr_changed
bookmark_changed = _ida_idp.bookmark_changed
sgr_deleted = _ida_idp.sgr_deleted

def gen_idb_event(*args):
  """
  gen_idb_event(code)


  the kernel will use this function to generate idb_events
  
  
  @param code (C++: idb_event::event_code_t)
  """
  return _ida_idp.gen_idb_event(*args)
IDPOPT_CST = _ida_idp.IDPOPT_CST
IDPOPT_PRI_DEFAULT = _ida_idp.IDPOPT_PRI_DEFAULT
IDPOPT_PRI_HIGH = _ida_idp.IDPOPT_PRI_HIGH
IDPOPT_NUM_INT = _ida_idp.IDPOPT_NUM_INT
IDPOPT_NUM_CHAR = _ida_idp.IDPOPT_NUM_CHAR
IDPOPT_NUM_SHORT = _ida_idp.IDPOPT_NUM_SHORT
IDPOPT_NUM_RANGE = _ida_idp.IDPOPT_NUM_RANGE
IDPOPT_NUM_UNS = _ida_idp.IDPOPT_NUM_UNS
IDPOPT_BIT_UINT = _ida_idp.IDPOPT_BIT_UINT
IDPOPT_BIT_UCHAR = _ida_idp.IDPOPT_BIT_UCHAR
IDPOPT_BIT_USHORT = _ida_idp.IDPOPT_BIT_USHORT
IDPOPT_BIT_BOOL = _ida_idp.IDPOPT_BIT_BOOL
IDPOPT_STR_QSTRING = _ida_idp.IDPOPT_STR_QSTRING
IDPOPT_STR_LONG = _ida_idp.IDPOPT_STR_LONG
IDPOPT_I64_RANGES = _ida_idp.IDPOPT_I64_RANGES
IDPOPT_I64_UNS = _ida_idp.IDPOPT_I64_UNS
IDPOPT_CST_PARAMS = _ida_idp.IDPOPT_CST_PARAMS

def cfg_get_cc_parm(*args):
  """
  cfg_get_cc_parm(compid, name) -> char const *
  """
  return _ida_idp.cfg_get_cc_parm(*args)

def cfg_get_cc_header_path(*args):
  """
  cfg_get_cc_header_path(compid) -> char const *
  """
  return _ida_idp.cfg_get_cc_header_path(*args)

def cfg_get_cc_predefined_macros(*args):
  """
  cfg_get_cc_predefined_macros(compid) -> char const *
  """
  return _ida_idp.cfg_get_cc_predefined_macros(*args)

def assemble(*args):
  """
  assemble(ea, cs, ip, use32, line) -> bool


  Assemble an instruction into the database (display a warning if an error is found)
  @param ea: linear address of instruction
  @param cs: cs of instruction
  @param ip: ip of instruction
  @param use32: is 32bit segment?
  @param line: line to assemble
  
  @return: Boolean. True on success.
  """
  return _ida_idp.assemble(*args)

def ph_get_id(*args):
  """
  ph_get_id() -> size_t


  Returns the 'ph.id' field
  """
  return _ida_idp.ph_get_id(*args)

def ph_get_version(*args):
  """
  ph_get_version() -> size_t


  Returns the 'ph.version'
  """
  return _ida_idp.ph_get_version(*args)

def ph_get_flag(*args):
  """
  ph_get_flag() -> size_t


  Returns the 'ph.flag'
  """
  return _ida_idp.ph_get_flag(*args)

def ph_get_cnbits(*args):
  """
  ph_get_cnbits() -> size_t


  Returns the 'ph.cnbits'
  """
  return _ida_idp.ph_get_cnbits(*args)

def ph_get_dnbits(*args):
  """
  ph_get_dnbits() -> size_t


  Returns the 'ph.dnbits'
  """
  return _ida_idp.ph_get_dnbits(*args)

def ph_get_reg_first_sreg(*args):
  """
  ph_get_reg_first_sreg() -> size_t


  Returns the 'ph.reg_first_sreg'
  """
  return _ida_idp.ph_get_reg_first_sreg(*args)

def ph_get_reg_last_sreg(*args):
  """
  ph_get_reg_last_sreg() -> size_t


  Returns the 'ph.reg_last_sreg'
  """
  return _ida_idp.ph_get_reg_last_sreg(*args)

def ph_get_segreg_size(*args):
  """
  ph_get_segreg_size() -> size_t


  Returns the 'ph.segreg_size'
  """
  return _ida_idp.ph_get_segreg_size(*args)

def ph_get_reg_code_sreg(*args):
  """
  ph_get_reg_code_sreg() -> size_t


  Returns the 'ph.reg_code_sreg'
  """
  return _ida_idp.ph_get_reg_code_sreg(*args)

def ph_get_reg_data_sreg(*args):
  """
  ph_get_reg_data_sreg() -> size_t


  Returns the 'ph.reg_data_sreg'
  """
  return _ida_idp.ph_get_reg_data_sreg(*args)

def ph_get_icode_return(*args):
  """
  ph_get_icode_return() -> size_t


  Returns the 'ph.icode_return'
  """
  return _ida_idp.ph_get_icode_return(*args)

def ph_get_instruc_start(*args):
  """
  ph_get_instruc_start() -> size_t


  Returns the 'ph.instruc_start'
  """
  return _ida_idp.ph_get_instruc_start(*args)

def ph_get_instruc_end(*args):
  """
  ph_get_instruc_end() -> size_t


  Returns the 'ph.instruc_end'
  """
  return _ida_idp.ph_get_instruc_end(*args)

def ph_get_tbyte_size(*args):
  """
  ph_get_tbyte_size() -> size_t


  Returns the 'ph.tbyte_size' field as defined in he processor module
  """
  return _ida_idp.ph_get_tbyte_size(*args)

def ph_get_instruc(*args):
  """
  ph_get_instruc() -> PyObject *


  Returns a list of tuples (instruction_name, instruction_feature) containing the
  instructions list as defined in he processor module
  """
  return _ida_idp.ph_get_instruc(*args)

def ph_get_regnames(*args):
  """
  ph_get_regnames() -> PyObject *


  Returns the list of register names as defined in the processor module
  """
  return _ida_idp.ph_get_regnames(*args)

def ph_get_operand_info(*args):
  """
  ph_get_operand_info(ea, n) -> PyObject *


  Returns the operand information given an ea and operand number.
  
  @param ea: address
  @param n: operand number
  
  @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
           Please refer to idd_opinfo_t structure in the SDK.
  """
  return _ida_idp.ph_get_operand_info(*args)

def ph_calcrel(*args):
  """
  ph_calcrel(ea)
  """
  return _ida_idp.ph_calcrel(*args)

def ph_find_reg_value(*args):
  """
  ph_find_reg_value(insn, reg) -> ssize_t
  """
  return _ida_idp.ph_find_reg_value(*args)

def ph_find_op_value(*args):
  """
  ph_find_op_value(insn, op) -> ssize_t
  """
  return _ida_idp.ph_find_op_value(*args)
class IDP_Hooks(object):
    """
    Proxy of C++ IDP_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _flags=0) -> IDP_Hooks
        """
        if self.__class__ == IDP_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_idp.new_IDP_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def hook(self, *args):
        """
        hook(self) -> bool


        Creates an IDP hook
        
        @return: Boolean true on success
        """
        return _ida_idp.IDP_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool


        Removes the IDP hook
        @return: Boolean true on success
        """
        return _ida_idp.IDP_Hooks_unhook(self, *args)

    def ev_init(self, *args):
        """
        ev_init(self, idp_modname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_init(self, *args)

    def ev_term(self, *args):
        """
        ev_term(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_term(self, *args)

    def ev_newprc(self, *args):
        """
        ev_newprc(self, pnum, keep_cfg) -> int
        """
        return _ida_idp.IDP_Hooks_ev_newprc(self, *args)

    def ev_newasm(self, *args):
        """
        ev_newasm(self, asmnum) -> int
        """
        return _ida_idp.IDP_Hooks_ev_newasm(self, *args)

    def ev_newfile(self, *args):
        """
        ev_newfile(self, fname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_newfile(self, *args)

    def ev_oldfile(self, *args):
        """
        ev_oldfile(self, fname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_oldfile(self, *args)

    def ev_newbinary(self, *args):
        """
        ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
        """
        return _ida_idp.IDP_Hooks_ev_newbinary(self, *args)

    def ev_endbinary(self, *args):
        """
        ev_endbinary(self, ok) -> int
        """
        return _ida_idp.IDP_Hooks_ev_endbinary(self, *args)

    def ev_set_idp_options(self, *args):
        """
        ev_set_idp_options(self, keyword, value_type, value, errbuf, idb_loaded) -> int
        """
        return _ida_idp.IDP_Hooks_ev_set_idp_options(self, *args)

    def ev_set_proc_options(self, *args):
        """
        ev_set_proc_options(self, options, confidence) -> int
        """
        return _ida_idp.IDP_Hooks_ev_set_proc_options(self, *args)

    def ev_ana_insn(self, *args):
        """
        ev_ana_insn(self, out) -> bool


        Analyzes and decodes an instruction at insn.ea
           - insn.itype must be set >= idaapi.CUSTOM_CMD_ITYPE
           - insn.size must be set to the instruction length
        
        @return: Boolean
            - False if the instruction is not recognized
            - True if the instruction was decoded. 'insn' should be filled in that case.
        """
        return _ida_idp.IDP_Hooks_ev_ana_insn(self, *args)

    def ev_emu_insn(self, *args):
        """
        ev_emu_insn(self, insn) -> bool


        Emulate instruction, create cross-references, plan to analyze
        subsequent instructions, modify flags etc. Upon entrance to this function
        all information about the instruction is in 'insn' structure.
        
        @return: Boolean (whether this instruction has been emulated or not)
        """
        return _ida_idp.IDP_Hooks_ev_emu_insn(self, *args)

    def ev_out_header(self, *args):
        """
        ev_out_header(self, outctx)
        """
        return _ida_idp.IDP_Hooks_ev_out_header(self, *args)

    def ev_out_footer(self, *args):
        """
        ev_out_footer(self, outctx)
        """
        return _ida_idp.IDP_Hooks_ev_out_footer(self, *args)

    def ev_out_segstart(self, *args):
        """
        ev_out_segstart(self, outctx, seg) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_segstart(self, *args)

    def ev_out_segend(self, *args):
        """
        ev_out_segend(self, outctx, seg) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_segend(self, *args)

    def ev_out_assumes(self, *args):
        """
        ev_out_assumes(self, outctx) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_assumes(self, *args)

    def ev_out_insn(self, *args):
        """
        ev_out_insn(self, outctx) -> bool


        Outputs the instruction defined in 'ctx.insn'
        
        @return: Boolean (whether this instruction can be outputted or not)
        """
        return _ida_idp.IDP_Hooks_ev_out_insn(self, *args)

    def ev_out_mnem(self, *args):
        """
        ev_out_mnem(self, outctx) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_mnem(self, *args)

    def ev_out_operand(self, *args):
        """
        ev_out_operand(self, outctx, op) -> bool


        Notification to generate operand text.
        If False was returned, then the standard operand output function will be called.
        
        this notification may use out_...() functions to form the operand text
        
        @return: Boolean (whether the operand has been outputted or not)
        """
        return _ida_idp.IDP_Hooks_ev_out_operand(self, *args)

    def ev_out_data(self, *args):
        """
        ev_out_data(self, outctx, analyze_only) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_data(self, *args)

    def ev_out_label(self, *args):
        """
        ev_out_label(self, outctx, colored_name) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_label(self, *args)

    def ev_out_special_item(self, *args):
        """
        ev_out_special_item(self, outctx, segtype) -> int
        """
        return _ida_idp.IDP_Hooks_ev_out_special_item(self, *args)

    def ev_gen_stkvar_def(self, *args):
        """
        ev_gen_stkvar_def(self, outctx, mptr, v) -> int
        """
        return _ida_idp.IDP_Hooks_ev_gen_stkvar_def(self, *args)

    def ev_gen_regvar_def(self, *args):
        """
        ev_gen_regvar_def(self, outctx, v) -> int
        """
        return _ida_idp.IDP_Hooks_ev_gen_regvar_def(self, *args)

    def ev_gen_src_file_lnnum(self, *args):
        """
        ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
        """
        return _ida_idp.IDP_Hooks_ev_gen_src_file_lnnum(self, *args)

    def ev_creating_segm(self, *args):
        """
        ev_creating_segm(self, seg) -> int
        """
        return _ida_idp.IDP_Hooks_ev_creating_segm(self, *args)

    def ev_moving_segm(self, *args):
        """
        ev_moving_segm(self, seg, to, flags) -> int
        """
        return _ida_idp.IDP_Hooks_ev_moving_segm(self, *args)

    def ev_coagulate(self, *args):
        """
        ev_coagulate(self, start_ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_coagulate(self, *args)

    def ev_undefine(self, *args):
        """
        ev_undefine(self, ea) -> int


        An item in the database (insn or data) is being deleted
        @param ea: Address
        @return:
            - 1 - do not delete srranges at the item end
            - 0 - srranges can be deleted
        """
        return _ida_idp.IDP_Hooks_ev_undefine(self, *args)

    def ev_treat_hindering_item(self, *args):
        """
        ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
        """
        return _ida_idp.IDP_Hooks_ev_treat_hindering_item(self, *args)

    def ev_rename(self, *args):
        """
        ev_rename(self, ea, new_name) -> int


        The kernel is going to rename a byte.
        
        @param ea: Address
        @param new_name: The new name
        
        @return:
            - If returns value <0, then the kernel should
              not rename it. See also the 'renamed' event
        """
        return _ida_idp.IDP_Hooks_ev_rename(self, *args)

    def ev_is_far_jump(self, *args):
        """
        ev_is_far_jump(self, icode) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_far_jump(self, *args)

    def ev_is_sane_insn(self, *args):
        """
        ev_is_sane_insn(self, insn, no_crefs) -> int


        is the instruction sane for the current file type?
        @param insn: the instruction
        @param no_crefs:
              - 1: the instruction has no code refs to it.
                   ida just tries to convert unexplored bytes
                   to an instruction (but there is no other
                   reason to convert them into an instruction)
              - 0: the instruction is created because
                   of some coderef, user request or another
                   weighty reason.
        @return: >=0-ok, <0-no, the instruction isn't likely to appear in the program
        """
        return _ida_idp.IDP_Hooks_ev_is_sane_insn(self, *args)

    def ev_is_cond_insn(self, *args):
        """
        ev_is_cond_insn(self, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_cond_insn(self, *args)

    def ev_is_call_insn(self, *args):
        """
        ev_is_call_insn(self, insn) -> int


        Is the instruction a "call"?
        
        @param insn: instruction
        @return: 0-unknown, 1-yes, -1-no
        """
        return _ida_idp.IDP_Hooks_ev_is_call_insn(self, *args)

    def ev_is_ret_insn(self, *args):
        """
        ev_is_ret_insn(self, insn, strict) -> int


        Is the instruction a "return"?
        
        @param insn: instruction
        @param strict: - True: report only ret instructions
                         False: include instructions like "leave" which begins the function epilog
        @return: 0-unknown, 1-yes, -1-no
        """
        return _ida_idp.IDP_Hooks_ev_is_ret_insn(self, *args)

    def ev_may_be_func(self, *args):
        """
        ev_may_be_func(self, insn, state) -> int


        Can a function start here?
        @param insn: the instruction
        @param state: autoanalysis phase
              0: creating functions
              1: creating chunks
        
        @return: integer (probability 0..100)
        """
        return _ida_idp.IDP_Hooks_ev_may_be_func(self, *args)

    def ev_is_basic_block_end(self, *args):
        """
        ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_basic_block_end(self, *args)

    def ev_is_indirect_jump(self, *args):
        """
        ev_is_indirect_jump(self, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_indirect_jump(self, *args)

    def ev_is_insn_table_jump(self, *args):
        """
        ev_is_insn_table_jump(self, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_insn_table_jump(self, *args)

    def ev_is_switch(self, *args):
        """
        ev_is_switch(self, si, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_switch(self, *args)

    def ev_calc_switch_cases(self, *args):
        """
        ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_switch_cases(self, *args)

    def ev_create_switch_xrefs(self, *args):
        """
        ev_create_switch_xrefs(self, jumpea, si) -> int
        """
        return _ida_idp.IDP_Hooks_ev_create_switch_xrefs(self, *args)

    def ev_is_align_insn(self, *args):
        """
        ev_is_align_insn(self, ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_align_insn(self, *args)

    def ev_is_alloca_probe(self, *args):
        """
        ev_is_alloca_probe(self, ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_alloca_probe(self, *args)

    def ev_delay_slot_insn(self, *args):
        """
        ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_delay_slot_insn(self, *args)

    def ev_is_sp_based(self, *args):
        """
        ev_is_sp_based(self, mode, insn, op) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_sp_based(self, *args)

    def ev_can_have_type(self, *args):
        """
        ev_can_have_type(self, op) -> int
        """
        return _ida_idp.IDP_Hooks_ev_can_have_type(self, *args)

    def ev_cmp_operands(self, *args):
        """
        ev_cmp_operands(self, op1, op2) -> int
        """
        return _ida_idp.IDP_Hooks_ev_cmp_operands(self, *args)

    def ev_adjust_refinfo(self, *args):
        """
        ev_adjust_refinfo(self, ri, ea, n, fd) -> int
        """
        return _ida_idp.IDP_Hooks_ev_adjust_refinfo(self, *args)

    def ev_get_operand_string(self, *args):
        """
        ev_get_operand_string(self, insn, opnum) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_get_operand_string(self, *args)

    def ev_get_reg_name(self, *args):
        """
        ev_get_reg_name(self, reg, width, reghi) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_get_reg_name(self, *args)

    def ev_str2reg(self, *args):
        """
        ev_str2reg(self, regname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_str2reg(self, *args)

    def ev_get_autocmt(self, *args):
        """
        ev_get_autocmt(self, insn) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_get_autocmt(self, *args)

    def ev_get_bg_color(self, *args):
        """
        ev_get_bg_color(self, ea) -> int or None
        """
        return _ida_idp.IDP_Hooks_ev_get_bg_color(self, *args)

    def ev_is_jump_func(self, *args):
        """
        ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
        """
        return _ida_idp.IDP_Hooks_ev_is_jump_func(self, *args)

    def ev_func_bounds(self, *args):
        """
        ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea)
        """
        return _ida_idp.IDP_Hooks_ev_func_bounds(self, *args)

    def ev_verify_sp(self, *args):
        """
        ev_verify_sp(self, pfn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_verify_sp(self, *args)

    def ev_verify_noreturn(self, *args):
        """
        ev_verify_noreturn(self, pfn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_verify_noreturn(self, *args)

    def ev_create_func_frame(self, *args):
        """
        ev_create_func_frame(self, pfn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_create_func_frame(self, *args)

    def ev_get_frame_retsize(self, *args):
        """
        ev_get_frame_retsize(self, frsize, pfn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_frame_retsize(self, *args)

    def ev_get_stkvar_scale_factor(self, *args):
        """
        ev_get_stkvar_scale_factor(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_stkvar_scale_factor(self, *args)

    def ev_demangle_name(self, *args):
        """
        ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_demangle_name(self, *args)

    def ev_add_cref(self, *args):
        """
        ev_add_cref(self, _from, to, type) -> int
        """
        return _ida_idp.IDP_Hooks_ev_add_cref(self, *args)

    def ev_add_dref(self, *args):
        """
        ev_add_dref(self, _from, to, type) -> int
        """
        return _ida_idp.IDP_Hooks_ev_add_dref(self, *args)

    def ev_del_cref(self, *args):
        """
        ev_del_cref(self, _from, to, expand) -> int
        """
        return _ida_idp.IDP_Hooks_ev_del_cref(self, *args)

    def ev_del_dref(self, *args):
        """
        ev_del_dref(self, _from, to) -> int
        """
        return _ida_idp.IDP_Hooks_ev_del_dref(self, *args)

    def ev_coagulate_dref(self, *args):
        """
        ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_coagulate_dref(self, *args)

    def ev_may_show_sreg(self, *args):
        """
        ev_may_show_sreg(self, current_ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_may_show_sreg(self, *args)

    def ev_auto_queue_empty(self, *args):
        """
        ev_auto_queue_empty(self, type)
        """
        return _ida_idp.IDP_Hooks_ev_auto_queue_empty(self, *args)

    def ev_validate_flirt_func(self, *args):
        """
        ev_validate_flirt_func(self, start_ea, funcname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_validate_flirt_func(self, *args)

    def ev_adjust_libfunc_ea(self, *args):
        """
        ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_adjust_libfunc_ea(self, *args)

    def ev_assemble(self, *args):
        """
        ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *


        Assembles an instruction
        
        @param ea: linear address of instruction
        @param cs: cs of instruction
        @param ip: ip of instruction
        @param use32: is 32bit segment?
        @param line: line to assemble
        
        @return: - None to let the underlying processor module assemble the line
                 - or a string containing the assembled buffer
        """
        return _ida_idp.IDP_Hooks_ev_assemble(self, *args)

    def ev_extract_address(self, *args):
        """
        ev_extract_address(self, out_ea, screen_ea, string, position) -> int
        """
        return _ida_idp.IDP_Hooks_ev_extract_address(self, *args)

    def ev_realcvt(self, *args):
        """
        ev_realcvt(self, m, e, swt) -> int
        """
        return _ida_idp.IDP_Hooks_ev_realcvt(self, *args)

    def ev_gen_asm_or_lst(self, *args):
        """
        ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline)
        """
        return _ida_idp.IDP_Hooks_ev_gen_asm_or_lst(self, *args)

    def ev_gen_map_file(self, *args):
        """
        ev_gen_map_file(self, nlines, fp) -> int
        """
        return _ida_idp.IDP_Hooks_ev_gen_map_file(self, *args)

    def ev_create_flat_group(self, *args):
        """
        ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
        """
        return _ida_idp.IDP_Hooks_ev_create_flat_group(self, *args)

    def ev_getreg(self, *args):
        """
        ev_getreg(self, regval, regnum) -> int
        """
        return _ida_idp.IDP_Hooks_ev_getreg(self, *args)

    def ev_analyze_prolog(self, *args):
        """
        ev_analyze_prolog(self, ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_analyze_prolog(self, *args)

    def ev_calc_spdelta(self, *args):
        """
        ev_calc_spdelta(self, spdelta, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_spdelta(self, *args)

    def ev_calcrel(self, *args):
        """
        ev_calcrel(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calcrel(self, *args)

    def ev_find_reg_value(self, *args):
        """
        ev_find_reg_value(self, pinsn, reg) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_find_reg_value(self, *args)

    def ev_find_op_value(self, *args):
        """
        ev_find_op_value(self, pinsn, opn) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_find_op_value(self, *args)

    def ev_replaying_undo(self, *args):
        """
        ev_replaying_undo(self, action_name, vec, is_undo) -> int
        """
        return _ida_idp.IDP_Hooks_ev_replaying_undo(self, *args)

    def ev_ending_undo(self, *args):
        """
        ev_ending_undo(self, action_name, is_undo) -> int
        """
        return _ida_idp.IDP_Hooks_ev_ending_undo(self, *args)

    def ev_next_exec_insn(self, *args):
        """
        ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
        """
        return _ida_idp.IDP_Hooks_ev_next_exec_insn(self, *args)

    def ev_calc_step_over(self, *args):
        """
        ev_calc_step_over(self, target, ip) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_step_over(self, *args)

    def ev_calc_next_eas(self, *args):
        """
        ev_calc_next_eas(self, res, insn, over) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_next_eas(self, *args)

    def ev_get_macro_insn_head(self, *args):
        """
        ev_get_macro_insn_head(self, head, ip) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_macro_insn_head(self, *args)

    def ev_get_dbr_opnum(self, *args):
        """
        ev_get_dbr_opnum(self, opnum, insn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_dbr_opnum(self, *args)

    def ev_insn_reads_tbit(self, *args):
        """
        ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
        """
        return _ida_idp.IDP_Hooks_ev_insn_reads_tbit(self, *args)

    def ev_clean_tbit(self, *args):
        """
        ev_clean_tbit(self, ea, getreg, regvalues) -> int
        """
        return _ida_idp.IDP_Hooks_ev_clean_tbit(self, *args)

    def ev_get_reg_info(self, *args):
        """
        ev_get_reg_info(self, main_regname, bitrange, regname) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_reg_info(self, *args)

    def ev_setup_til(self, *args):
        """
        ev_setup_til(self)
        """
        return _ida_idp.IDP_Hooks_ev_setup_til(self, *args)

    def ev_get_abi_info(self, *args):
        """
        ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_abi_info(self, *args)

    def ev_max_ptr_size(self, *args):
        """
        ev_max_ptr_size(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_max_ptr_size(self, *args)

    def ev_get_default_enum_size(self, *args):
        """
        ev_get_default_enum_size(self, cm) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_default_enum_size(self, *args)

    def ev_get_cc_regs(self, *args):
        """
        ev_get_cc_regs(self, regs, cc) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_cc_regs(self, *args)

    def ev_get_stkarg_offset(self, *args):
        """
        ev_get_stkarg_offset(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_stkarg_offset(self, *args)

    def ev_shadow_args_size(self, *args):
        """
        ev_shadow_args_size(self, shadow_args_size, pfn) -> int
        """
        return _ida_idp.IDP_Hooks_ev_shadow_args_size(self, *args)

    def ev_get_simd_types(self, *args):
        """
        ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
        """
        return _ida_idp.IDP_Hooks_ev_get_simd_types(self, *args)

    def ev_calc_cdecl_purged_bytes(self, *args):
        """
        ev_calc_cdecl_purged_bytes(self, ea) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_cdecl_purged_bytes(self, *args)

    def ev_calc_purged_bytes(self, *args):
        """
        ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_purged_bytes(self, *args)

    def ev_calc_retloc(self, *args):
        """
        ev_calc_retloc(self, retloc, rettype, cc) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_retloc(self, *args)

    def ev_calc_arglocs(self, *args):
        """
        ev_calc_arglocs(self, fti) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_arglocs(self, *args)

    def ev_calc_varglocs(self, *args):
        """
        ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
        """
        return _ida_idp.IDP_Hooks_ev_calc_varglocs(self, *args)

    def ev_adjust_argloc(self, *args):
        """
        ev_adjust_argloc(self, argloc, optional_type, size) -> int
        """
        return _ida_idp.IDP_Hooks_ev_adjust_argloc(self, *args)

    def ev_lower_func_type(self, *args):
        """
        ev_lower_func_type(self, argnums, fti) -> int
        """
        return _ida_idp.IDP_Hooks_ev_lower_func_type(self, *args)

    def ev_equal_reglocs(self, *args):
        """
        ev_equal_reglocs(self, a1, a2) -> int
        """
        return _ida_idp.IDP_Hooks_ev_equal_reglocs(self, *args)

    def ev_use_stkarg_type(self, *args):
        """
        ev_use_stkarg_type(self, ea, arg) -> int
        """
        return _ida_idp.IDP_Hooks_ev_use_stkarg_type(self, *args)

    def ev_use_regarg_type(self, *args):
        """
        ev_use_regarg_type(self, ea, rargs) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_use_regarg_type(self, *args)

    def ev_use_arg_types(self, *args):
        """
        ev_use_arg_types(self, ea, fti, rargs) -> int
        """
        return _ida_idp.IDP_Hooks_ev_use_arg_types(self, *args)

    def ev_arg_addrs_ready(self, *args):
        """
        ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
        """
        return _ida_idp.IDP_Hooks_ev_arg_addrs_ready(self, *args)

    def ev_decorate_name(self, *args):
        """
        ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
        """
        return _ida_idp.IDP_Hooks_ev_decorate_name(self, *args)

    def ev_last_cb_before_loader(self, *args):
        """
        ev_last_cb_before_loader(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_last_cb_before_loader(self, *args)

    def ev_loader(self, *args):
        """
        ev_loader(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_loader(self, *args)

    __swig_destroy__ = _ida_idp.delete_IDP_Hooks
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_idp.disown_IDP_Hooks(self)
        return weakref_proxy(self)
IDP_Hooks_swigregister = _ida_idp.IDP_Hooks_swigregister
IDP_Hooks_swigregister(IDP_Hooks)


def get_idp_notifier_addr(*args):
  """
  get_idp_notifier_addr(arg1) -> PyObject *
  """
  return _ida_idp.get_idp_notifier_addr(*args)

def get_idp_notifier_ud_addr(*args):
  """
  get_idp_notifier_ud_addr(hooks) -> PyObject *
  """
  return _ida_idp.get_idp_notifier_ud_addr(*args)
#<pycode(py_idp)>

#----------------------------------------------------------------------------
#               P R O C E S S O R  M O D U L E S  C O N S T A N T S
#----------------------------------------------------------------------------

# ----------------------------------------------------------------------
# processor_t related constants

CUSTOM_INSN_ITYPE   = 0x8000
"""
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this
"""
REG_SPOIL           = 0x80000000
"""
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled
"""

REAL_ERROR_FORMAT   = -1   #  not supported format for current .idp
REAL_ERROR_RANGE    = -2   #  number too big (small) for store (mem NOT modifyed)
REAL_ERROR_BADDATA  = -3   #  illegal real data for load (IEEE data not filled)

#
#  Check whether the operand is relative to stack pointer or frame pointer.
#  This function is used to determine how to output a stack variable
#  This function may be absent. If it is absent, then all operands
#  are sp based by default.
#  Define this function only if some stack references use frame pointer
#  instead of stack pointer.
#  returns flags:
OP_FP_BASED   = 0x00000000   #  operand is FP based
"""
operand is FP based
"""
OP_SP_BASED   = 0x00000001   #  operand is SP based
"""
operand is SP based
"""
OP_SP_ADD     = 0x00000000   #  operand value is added to the pointer
"""
operand value is added to the pointer
"""
OP_SP_SUB     = 0x00000002   #  operand value is substracted from the pointer
"""
operand value is subtracted from the pointer
"""

# processor_t.id
PLFM_386             = 0        # Intel 80x86
"""
Intel 80x86.
"""
PLFM_Z80             = 1        # 8085, Z80
"""
8085, Z80
"""
PLFM_I860            = 2        # Intel 860
"""
Intel 860.
"""
PLFM_8051            = 3        # 8051
"""
8051
"""
PLFM_TMS             = 4        # Texas Instruments TMS320C5x
"""
Texas Instruments TMS320C5x.
"""
PLFM_6502            = 5        # 6502
"""
6502
"""
PLFM_PDP             = 6        # PDP11
"""
PDP11.
"""
PLFM_68K             = 7        # Motorola 680x0
"""
Motorola 680x0.
"""
PLFM_JAVA            = 8        # Java
"""
Java.
"""
PLFM_6800            = 9        # Motorola 68xx
"""
Motorola 68xx.
"""
PLFM_ST7             = 10       # SGS-Thomson ST7
"""
SGS-Thomson ST7.
"""
PLFM_MC6812          = 11       # Motorola 68HC12
"""
Motorola 68HC12.
"""
PLFM_MIPS            = 12       # MIPS
"""
MIPS.
"""
PLFM_ARM             = 13       # Advanced RISC Machines
"""
Advanced RISC Machines.
"""
PLFM_TMSC6           = 14       # Texas Instruments TMS320C6x
"""
Texas Instruments TMS320C6x.
"""
PLFM_PPC             = 15       # PowerPC
"""
PowerPC.
"""
PLFM_80196           = 16       # Intel 80196
"""
Intel 80196.
"""
PLFM_Z8              = 17       # Z8
"""
Z8.
"""
PLFM_SH              = 18       # Renesas (formerly Hitachi) SuperH
"""
Renesas (formerly Hitachi) SuperH.
"""
PLFM_NET             = 19       # Microsoft Visual Studio.Net
"""
Microsoft Visual Studio.Net.
"""
PLFM_AVR             = 20       # Atmel 8-bit RISC processor(s)
"""
Atmel 8-bit RISC processor(s)
"""
PLFM_H8              = 21       # Hitachi H8/300, H8/2000
"""
Hitachi H8/300, H8/2000.
"""
PLFM_PIC             = 22       # Microchip's PIC
"""
Microchip's PIC.
"""
PLFM_SPARC           = 23       # SPARC
"""
SPARC.
"""
PLFM_ALPHA           = 24       # DEC Alpha
"""
DEC Alpha.
"""
PLFM_HPPA            = 25       # Hewlett-Packard PA-RISC
"""
Hewlett-Packard PA-RISC.
"""
PLFM_H8500           = 26       # Hitachi H8/500
"""
Hitachi H8/500.
"""
PLFM_TRICORE         = 27       # Tasking Tricore
"""
Tasking Tricore.
"""
PLFM_DSP56K          = 28       # Motorola DSP5600x
"""
Motorola DSP5600x.
"""
PLFM_C166            = 29       # Siemens C166 family
"""
Siemens C166 family.
"""
PLFM_ST20            = 30       # SGS-Thomson ST20
"""
SGS-Thomson ST20.
"""
PLFM_IA64            = 31       # Intel Itanium IA64
"""
Intel Itanium IA64.
"""
PLFM_I960            = 32       # Intel 960
"""
Intel 960.
"""
PLFM_F2MC            = 33       # Fujistu F2MC-16
"""
Fujistu F2MC-16.
"""
PLFM_TMS320C54       = 34       # Texas Instruments TMS320C54xx
"""
Texas Instruments TMS320C54xx.
"""
PLFM_TMS320C55       = 35       # Texas Instruments TMS320C55xx
"""
Texas Instruments TMS320C55xx.
"""
PLFM_TRIMEDIA        = 36       # Trimedia
"""
Trimedia.
"""
PLFM_M32R            = 37       # Mitsubishi 32bit RISC
"""
Mitsubishi 32bit RISC.
"""
PLFM_NEC_78K0        = 38       # NEC 78K0
"""
NEC 78K0.
"""
PLFM_NEC_78K0S       = 39       # NEC 78K0S
"""
NEC 78K0S.
"""
PLFM_M740            = 40       # Mitsubishi 8bit
"""
Mitsubishi 8bit.
"""
PLFM_M7700           = 41       # Mitsubishi 16bit
"""
Mitsubishi 16bit.
"""
PLFM_ST9             = 42       # ST9+
"""
ST9+.
"""
PLFM_FR              = 43       # Fujitsu FR Family
"""
Fujitsu FR Family.
"""
PLFM_MC6816          = 44       # Motorola 68HC16
"""
Motorola 68HC16.
"""
PLFM_M7900           = 45       # Mitsubishi 7900
"""
Mitsubishi 7900.
"""
PLFM_TMS320C3        = 46       # Texas Instruments TMS320C3
"""
Texas Instruments TMS320C3.
"""
PLFM_KR1878          = 47       # Angstrem KR1878
"""
Angstrem KR1878.
"""
PLFM_AD218X          = 48       # Analog Devices ADSP 218X
"""
Analog Devices ADSP 218X.
"""
PLFM_OAKDSP          = 49       # Atmel OAK DSP
"""
Atmel OAK DSP.
"""
PLFM_TLCS900         = 50       # Toshiba TLCS-900
"""
Toshiba TLCS-900.
"""
PLFM_C39             = 51       # Rockwell C39
"""
Rockwell C39.
"""
PLFM_CR16            = 52       # NSC CR16
"""
NSC CR16.
"""
PLFM_MN102L00        = 53       # Panasonic MN10200
"""
Panasonic MN10200.
"""
PLFM_TMS320C1X       = 54       # Texas Instruments TMS320C1x
"""
Texas Instruments TMS320C1x.
"""
PLFM_NEC_V850X       = 55       # NEC V850 and V850ES/E1/E2
"""
NEC V850 and V850ES/E1/E2.
"""
PLFM_SCR_ADPT        = 56       # Processor module adapter for processor modules written in scripting languages
"""
Processor module adapter for processor modules written in scripting
languages.
"""
PLFM_EBC             = 57       # EFI Bytecode
"""
EFI Bytecode.
"""
PLFM_MSP430          = 58       # Texas Instruments MSP430
"""
Texas Instruments MSP430.
"""
PLFM_SPU             = 59       # Cell Broadband Engine Synergistic Processor Unit
"""
Cell Broadband Engine Synergistic Processor Unit.
"""
PLFM_DALVIK          = 60       # Android Dalvik Virtual Machine
"""
Android Dalvik Virtual Machine.
"""
PLFM_65C816          = 61       # 65802/65816
"""
65802/65816
"""
PLFM_M16C            = 62       # Renesas M16C
"""
Renesas M16C.
"""
PLFM_ARC             = 63       # Argonaut RISC Core
"""
Argonaut RISC Core.
"""
PLFM_UNSP            = 64       # SunPlus unSP
"""
SunPlus unSP.
"""
PLFM_TMS320C28       = 65       # Texas Instruments TMS320C28x
"""
Texas Instruments TMS320C28x.
"""
PLFM_DSP96K          = 66       # Motorola DSP96000
"""
Motorola DSP96000.
"""
PLFM_SPC700          = 67       # Sony SPC700
"""
Sony SPC700.
"""
PLFM_AD2106X         = 68       # Analog Devices ADSP 2106X
"""
Analog Devices ADSP 2106X.
"""
PLFM_PIC16           = 69       # Microchip's 16-bit PIC
"""
Microchip's 16-bit PIC.
"""

#
# processor_t.flag
#
PR_SEGS        = 0x000001    #  has segment registers?
"""
has segment registers?
"""
PR_USE32       = 0x000002    #  supports 32-bit addressing?
"""
supports 32-bit addressing?
"""
PR_DEFSEG32    = 0x000004    #  segments are 32-bit by default
"""
segments are 32-bit by default
"""
PR_RNAMESOK    = 0x000008    #  allow to user register names for location names
"""
allow user register names for location names
"""
PR_ADJSEGS     = 0x000020    #  IDA may adjust segments moving their starting/ending addresses.
"""
IDA may adjust segments' starting/ending addresses.
"""
PR_DEFNUM      = 0x0000C0    #  default number representation:
"""
mask - default number representation
"""
PRN_HEX        = 0x000000    #       hex
"""
hex
"""
PRN_OCT        = 0x000040    #       octal
"""
octal
"""
PRN_DEC        = 0x000080    #       decimal
"""
decimal
"""
PRN_BIN        = 0x0000C0    #       binary
"""
binary
"""
PR_WORD_INS    = 0x000100    #  instruction codes are grouped 2bytes in binrary line prefix
"""
instruction codes are grouped 2bytes in binary line prefix
"""
PR_NOCHANGE    = 0x000200    #  The user can't change segments and code/data attributes (display only)
"""
(display only)

The user can't change segments and code/data attributes
"""
PR_ASSEMBLE    = 0x000400    #  Module has a built-in assembler and understands IDP_ASSEMBLE
"""
Module has a built-in assembler and will react to ev_assemble.
"""
PR_ALIGN       = 0x000800    #  All data items should be aligned properly
"""
All data items should be aligned properly.
"""
PR_TYPEINFO    = 0x001000    #  the processor module supports
"""
ALL OF THEM SHOULD BE IMPLEMENTED!

the processor module supports type information callbacks
"""
                             #     type information callbacks
                             #     ALL OF THEM SHOULD BE IMPLEMENTED!
PR_USE64       = 0x002000    #  supports 64-bit addressing?
"""
supports 64-bit addressing?
"""
PR_SGROTHER    = 0x004000    #  the segment registers don't contain
"""
the segment registers don't contain the segment selectors.
"""
                             #     the segment selectors, something else
PR_STACK_UP    = 0x008000    #  the stack grows up
"""
the stack grows up
"""
PR_BINMEM      = 0x010000    #  the processor module provides correct
"""
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes
"""
                             #     segmentation for binary files
                             #     (i.e. it creates additional segments)
                             #     The kernel will not ask the user
                             #     to specify the RAM/ROM sizes
PR_SEGTRANS    = 0x020000    #  the processor module supports
"""
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)
"""
                             #     the segment translation feature
                             #     (it means it calculates the code
                             #     addresses using the map_code_ea() function)
PR_CHK_XREF    = 0x040000    #  don't allow near xrefs between segments
"""
don't allow near xrefs between segments with different bases
"""
                             #     with different bases
PR_NO_SEGMOVE  = 0x080000    #  the processor module doesn't support move_segm()
"""
(i.e. the user can't move segments)

the processor module doesn't support 'move_segm()'
"""
                             #     (i.e. the user can't move segments)
PR_USE_ARG_TYPES = 0x200000  #  use ph.use_arg_types callback
"""
use \\ph{use_arg_types} callback
"""
PR_SCALE_STKVARS = 0x400000  #  use ph.get_stkvar_scale callback
"""
use \\ph{get_stkvar_scale} callback
"""
PR_DELAYED     = 0x800000    #  has delayed jumps and calls
"""
has delayed jumps and calls if this flag is set,
\\ph{is_basic_block_end}, \\ph{has_delay_slot} should be implemented
"""
PR_ALIGN_INSN  = 0x1000000   #  allow ida to create alignment instructions
"""
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore
"""
                             #     arbirtrarily. Since these instructions
                             #     might lead to other wrong instructions
                             #     and spoil the listing, IDA does not create
                             #     them by default anymore
PR_PURGING     = 0x2000000   #  there are calling conventions which may
"""
there are calling conventions which may purge bytes from the stack
"""
                             #     purge bytes from the stack
PR_CNDINSNS    = 0x4000000   #  has conditional instructions
"""
has conditional instructions
"""
PR_USE_TBYTE   = 0x8000000   #  BTMT_SPECFLT means _TBYTE type
"""
 'BTMT_SPECFLT' means _TBYTE type
"""
PR_DEFSEG64    = 0x10000000  #  segments are 64-bit by default
"""
segments are 64-bit by default
"""


# ----------------------------------------------------------------------
# instruc_t related constants

#
# instruc_t.feature
#
CF_STOP = 0x00001 #  Instruction doesn't pass execution to the next instruction
"""
next instruction

Instruction doesn't pass execution to the
"""
CF_CALL = 0x00002 #  CALL instruction (should make a procedure here)
"""
CALL instruction (should make a procedure here)
"""
CF_CHG1 = 0x00004 #  The instruction modifies the first operand
"""
The instruction modifies the first operand.
"""
CF_CHG2 = 0x00008 #  The instruction modifies the second operand
"""
The instruction modifies the second operand.
"""
CF_CHG3 = 0x00010 #  The instruction modifies the third operand
"""
The instruction modifies the third operand.
"""
CF_CHG4 = 0x00020 #  The instruction modifies 4 operand
"""
The instruction modifies 4 operand.
"""
CF_CHG5 = 0x00040 #  The instruction modifies 5 operand
"""
The instruction modifies 5 operand.
"""
CF_CHG6 = 0x00080 #  The instruction modifies 6 operand
"""
The instruction modifies 6 operand.
"""
CF_USE1 = 0x00100 #  The instruction uses value of the first operand
"""
The instruction uses value of the first operand.
"""
CF_USE2 = 0x00200 #  The instruction uses value of the second operand
"""
The instruction uses value of the second operand.
"""
CF_USE3 = 0x00400 #  The instruction uses value of the third operand
"""
The instruction uses value of the third operand.
"""
CF_USE4 = 0x00800 #  The instruction uses value of the 4 operand
"""
The instruction uses value of the 4 operand.
"""
CF_USE5 = 0x01000 #  The instruction uses value of the 5 operand
"""
The instruction uses value of the 5 operand.
"""
CF_USE6 = 0x02000 #  The instruction uses value of the 6 operand
"""
The instruction uses value of the 6 operand.
"""
CF_JUMP = 0x04000 #  The instruction passes execution using indirect jump or call (thus needs additional analysis)
"""
jump or call (thus needs additional analysis)

The instruction passes execution using indirect
"""
CF_SHFT = 0x08000 #  Bit-shift instruction (shl,shr...)
"""
Bit-shift instruction (shl,shr...)
"""
CF_HLL  = 0x10000 #  Instruction may be present in a high level language function.
"""
language function.

Instruction may be present in a high level
"""

#
# Set IDP options constants
#
IDPOPT_STR        =  1    # string constant
IDPOPT_NUM        =  2    # number
IDPOPT_BIT        =  3    # bit, yes/no
IDPOPT_FLT        =  4    # float
IDPOPT_I64        =  5    # 64bit number

IDPOPT_OK         =  0    # ok
IDPOPT_BADKEY     =  1    # illegal keyword
IDPOPT_BADTYPE    =  2    # illegal type of value
IDPOPT_BADVALUE   =  3    # illegal value (bad range, for example)

# ----------------------------------------------------------------------
import ida_pro
import ida_funcs
import ida_segment
import ida_ua
class processor_t(IDP_Hooks):
    __idc_cvt_id__ = ida_idaapi.PY_ICID_OPAQUE

    """
    Base class for all processor module scripts

    A processor_t instance is both an ida_idp.IDP_Hooks, and
    an ida_idp.IDB_Hooks at the same time: any method of
    those two classes can be overridden in your processor_t
    subclass.
    """
    def __init__(self):
        IDP_Hooks.__init__(self, ida_idaapi.HBF_CALL_WITH_NEW_EXEC)
        self.idb_hooks = _processor_t_Trampoline_IDB_Hooks(self)

    def get_idpdesc(self):
        """
        This function must be present and should return the list of
        short processor names similar to the one in ph.psnames.
        This method can be overridden to return to the kernel a different IDP description.
        """
        return '\x01'.join(map(lambda t: '\x01'.join(t), zip(self.plnames, self.psnames)))

    def get_uFlag(self):
        """
        Use this utility function to retrieve the 'uFlag' global variable
        """
        return ida_ua.cvar.uFlag

    def get_auxpref(self, insn):
        """
        This function returns insn.auxpref value
        """
        return insn.auxpref

    def _get_idp_notifier_addr(self):
        return _ida_idp.get_idp_notifier_addr(self)

    def _get_idp_notifier_ud_addr(self):
        return _ida_idp.get_idp_notifier_ud_addr(self)

    def _get_idb_notifier_addr(self):
        return _ida_idp.get_idb_notifier_addr(self)

    def _get_idb_notifier_ud_addr(self):
        return _ida_idp.get_idb_notifier_ud_addr(self.idb_hooks)

    def _make_forced_value_wrapper(self, val, meth=None):
        def f(*args):
            if meth:
                meth(*args)
            return val
        return f

    def _make_int_returning_wrapper(self, meth, intval=0):
        def f(*args):
            val = meth(*args)
            if val is None:
                val = intval
            return val
        return f

    def _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None):
        """
        This helper is used to implement backward-compatibility
        of pre IDA 7.3 processor_t interfaces.
        """
        if add_prefix:
            what = "notify_%s" % what
        meth = getattr(self, what, None)
        if meth is None:
            if mandatory_impl:
                raise Exception("processor_t.%s() must be implemented" % mandatory_impl)
            meth = self._make_forced_value_wrapper(unimp_val)
        else:
            if imp_forced_val is not None:
                meth = self._make_forced_value_wrapper(imp_forced_val, meth)
            else:
                meth = self._make_int_returning_wrapper(meth)
        return meth

    # The default implementations below are what guarantees that
    # pre IDA 7.3 processor_t subclasses, will continue working

    def ev_newprc(self, *args):
        return self._get_notify("newprc")(*args)

    def ev_newfile(self, *args):
        return self._get_notify("newfile")(*args)

    def ev_oldfile(self, *args):
        return self._get_notify("oldfile")(*args)

    def ev_newbinary(self, *args):
        return self._get_notify("newbinary")(*args)

    def ev_endbinary(self, *args):
        return self._get_notify("endbinary")(*args)

    def ev_set_idp_options(self, keyword, value_type, value):
        res = self._get_notify("set_idp_options", unimp_val=None)(keyword, value_type, value)
        if res is None:
            return 0
        return 1 if res == IDPOPT_OK else -1

    def ev_set_proc_options(self, *args):
        return self._get_notify("set_proc_options")(*args)

    def ev_ana_insn(self, *args):
        rc = self._get_notify("ana", mandatory_impl="ev_ana_insn")(*args)
        return rc > 0

    def ev_emu_insn(self, *args):
        rc = self._get_notify("emu", mandatory_impl="ev_emu_insn")(*args)
        return rc > 0

    def ev_out_header(self, *args):
        return self._get_notify("out_header", imp_forced_val=1)(*args)

    def ev_out_footer(self, *args):
        return self._get_notify("out_footer", imp_forced_val=1)(*args)

    def ev_out_segstart(self, ctx, s):
        return self._get_notify("out_segstart", imp_forced_val=1)(ctx, s.start_ea)

    def ev_out_segend(self, ctx, s):
        return self._get_notify("out_segend", imp_forced_val=1)(ctx, s.end_ea)

    def ev_out_assumes(self, *args):
        return self._get_notify("out_assumes", imp_forced_val=1)(*args)

    def ev_out_insn(self, *args):
        return self._get_notify("out_insn", mandatory_impl="ev_out_insn", imp_forced_val=True)(*args)

    def ev_out_mnem(self, *args):
        return self._get_notify("out_mnem", add_prefix=False, imp_forced_val=1)(*args)

    def ev_out_operand(self, *args):
        rc = self._get_notify("out_operand", mandatory_impl="ev_out_operand", imp_forced_val=1)(*args)
        return rc > 0

    def ev_out_data(self, *args):
        return self._get_notify("out_data", imp_forced_val=1)(*args)

    def ev_out_label(self, *args):
        return self._get_notify("out_label")(*args)

    def ev_out_special_item(self, *args):
        return self._get_notify("out_special_item")(*args)

    def ev_gen_regvar_def(self, ctx, v):
        return self._get_notify("gen_regvar_def")(ctx, v.canon, v.user, v.cmt)

    def ev_gen_src_file_lnnum(self, *args):
        return self._get_notify("gen_src_file_lnnum")(*args)

    def ev_creating_segm(self, s):
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        return self._get_notify("creating_segm")(s.start_ea, sname, sclass)

    def ev_moving_segm(self, s, to_ea, flags):
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        return self._get_notify("moving_segm")(s.start_ea, sname, sclass, to_ea, flags)

    def ev_coagulate(self, *args):
        return self._get_notify("coagulate")(*args)

    def ev_undefine(self, *args):
        return self._get_notify("undefine")(*args)

    def ev_treat_hindering_item(self, *args):
        return self._get_notify("treat_hindering_item")(*args)

    def ev_rename(self, *args):
        return self._get_notify("rename")(*args)

    def ev_is_far_jump(self, *args):
        rc = self._get_notify("is_far_jump", unimp_val=False)(*args)
        return 1 if rc else -1

    def ev_is_sane_insn(self, *args):
        return self._get_notify("is_sane_insn")(*args)

    def ev_is_call_insn(self, *args):
        return self._get_notify("is_call_insn")(*args)

    def ev_is_ret_insn(self, *args):
        return self._get_notify("is_ret_insn")(*args)

    def ev_may_be_func(self, *args):
        return self._get_notify("may_be_func")(*args)

    def ev_is_basic_block_end(self, *args):
        return self._get_notify("is_basic_block_end")(*args)

    def ev_is_indirect_jump(self, *args):
        return self._get_notify("is_indirect_jump")(*args)

    def ev_is_insn_table_jump(self, *args):
        return self._get_notify("is_insn_table_jump")(*args)

    def ev_is_switch(self, *args):
        rc = self._get_notify("is_switch")(*args)
        return 1 if rc else 0

    def ev_create_switch_xrefs(self, *args):
        return self._get_notify("create_switch_xrefs", imp_forced_val=1)(*args)

    def ev_is_align_insn(self, *args):
        return self._get_notify("is_align_insn")(*args)

    def ev_is_alloca_probe(self, *args):
        return self._get_notify("is_alloca_probe")(*args)

    def ev_is_sp_based(self, mode, insn, op):
        rc = self._get_notify("is_sp_based", unimp_val=None)(insn, op)
        if type(rc) == int:
            ida_pro.int_pointer.frompointer(mode).assign(rc)
            return 1
        return 0

    def ev_can_have_type(self, *args):
        rc = self._get_notify("can_have_type")(*args)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return 0

    def ev_cmp_operands(self, *args):
        rc = self._get_notify("cmp_operands")(*args)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return 0

    def ev_get_operand_string(self, buf, insn, opnum):
        rc = self._get_notify("get_operand_string")(insn, opnum)
        if rc:
            return 1
        return 0

    def ev_str2reg(self, *args):
        rc = self._get_notify("notify_str2reg", unimp_val=-1)(*args)
        return 0 if rc < 0 else rc + 1

    def ev_get_autocmt(self, *args):
        return self._get_notify("get_autocmt")(*args)

    def ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea):
        possible_return_code = ida_pro.int_pointer.frompointer(_possible_return_code)
        rc = self._get_notify("func_bounds", unimp_val=None)(
            possible_return_code.value(),
            pfn.start_ea,
            max_func_end_ea)
        if type(rc) == int:
            possible_return_code.assign(rc)
        return 0

    def ev_verify_sp(self, pfn):
        return self._get_notify("verify_sp")(pfn.start_ea)

    def ev_verify_noreturn(self, pfn):
        return self._get_notify("verify_noreturn")(pfn.start_ea)

    def ev_create_func_frame(self, pfn):
        rc = self._get_notify("create_func_frame", imp_forced_val=1)(pfn.start_ea)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return rc

    def ev_get_frame_retsize(self, frsize, pfn):
        rc = self._get_notify("get_frame_retsize", unimp_val=None)(pfn.start_ea)
        if type(rc) == int:
            ida_pro.int_pointer.frompointer(frsize).assign(rc)
            return 1
        return 0

    def ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea):
        code_ea = ida_pro.ea_pointer.frompointer(_code_ea)
        rc = self._get_notify("coagulate_dref")(from_ea, to_ea, may_define, code_ea.value())
        if rc == -1:
            return -1
        if rc != 0:
            code_ea.assign(rc)
        return 0

    def ev_may_show_sreg(self, *args):
        return self._get_notify("may_show_sreg")(*args)

    def ev_auto_queue_empty(self, *args):
        return self._get_notify("auto_queue_empty")(*args)

    def ev_validate_flirt_func(self, *args):
        return self._get_notify("validate_flirt_func")(*args)

    def ev_assemble(self, *args):
        return self._get_notify("assemble")(*args)

    def ev_gen_map_file(self, nlines, fp):
        import ida_fpro
        qfile = ida_fpro.qfile_t_from_fp(fp)
        rc = self._get_notify("gen_map_file")(qfile)
        if rc > 0:
            ida_pro.int_pointer.frompointer(nlines).assign(rc)
            return 1
        else:
            return 0

    def ev_calc_step_over(self, target, ip):
        rc = self._get_notify("calc_step_over", unimp_val=None)(ip)
        if rc is not None and rc != ida_idaapi.BADADDR:
            ida_pro.ea_pointer.frompointer(target).assign(rc)
            return 1
        return 0

    # IDB hooks handling

    def closebase(self, *args):
        self._get_notify("closebase")(*args)

    def savebase(self, *args):
        self._get_notify("savebase")(*args)

    def auto_empty(self, *args):
        self._get_notify("auto_empty")(*args)

    def auto_empty_finally(self, *args):
        self._get_notify("auto_empty_finally")(*args)

    def determined_main(self, *args):
        self._get_notify("determined_main")(*args)

    def idasgn_loaded(self, *args):
        self._get_notify("load_idasgn")(*args)

    def kernel_config_loaded(self, *args):
        self._get_notify("kernel_config_loaded")(*args)

    def compiler_changed(self, *args):
        self._get_notify("set_compiler")(*args)

    def segm_moved(self, from_ea, to_ea, size, changed_netmap):
        s = ida_segment.getseg(to_ea)
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        self._get_notify("move_segm")(from_ea, to_ea, sname, sclass, changed_netmap)

    def func_added(self, pfn):
        self._get_notify("add_func")(pfn.start_ea)

    def set_func_start(self, *args):
        self._get_notify("set_func_start")(*args)

    def set_func_end(self, *args):
        self._get_notify("set_func_end")(*args)

    def deleting_func(self, pfn):
        self._get_notify("del_func")(pfn.start_ea)

    def sgr_changed(self, *args):
        self._get_notify("setsgr")(*args)

    def make_code(self, *args):
        self._get_notify("make_code")(*args)

    def make_data(self, *args):
        self._get_notify("make_data")(*args)

    def renamed(self, *args):
        self._get_notify("renamed")(*args)


# ----------------------------------------------------------------------
class __ph(object):
    id = property(lambda self: ph_get_id())
    cnbits = property(lambda self: ph_get_cnbits())
    dnbits = property(lambda self: ph_get_dnbits())
    flag = property(lambda self: ph_get_flag())
    icode_return = property(lambda self: ph_get_icode_return())
    instruc = property(lambda self: ph_get_instruc())
    instruc_end = property(lambda self: ph_get_instruc_end())
    instruc_start = property(lambda self: ph_get_instruc_start())
    reg_code_sreg = property(lambda self: ph_get_reg_code_sreg())
    reg_data_sreg = property(lambda self: ph_get_reg_data_sreg())
    reg_first_sreg = property(lambda self: ph_get_reg_first_sreg())
    reg_last_sreg = property(lambda self: ph_get_reg_last_sreg())
    regnames = property(lambda self: ph_get_regnames())
    segreg_size = property(lambda self: ph_get_segreg_size())
    tbyte_size = property(lambda self: ph_get_tbyte_size())
    version = property(lambda self: ph_get_version())

ph = __ph()

#</pycode(py_idp)>

class IDB_Hooks(object):
    """
    Proxy of C++ IDB_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, _flags=0) -> IDB_Hooks
        """
        if self.__class__ == IDB_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_idp.new_IDB_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def hook(self, *args):
        """
        hook(self) -> bool
        """
        return _ida_idp.IDB_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool
        """
        return _ida_idp.IDB_Hooks_unhook(self, *args)

    def closebase(self, *args):
        """
        closebase(self)
        """
        return _ida_idp.IDB_Hooks_closebase(self, *args)

    def savebase(self, *args):
        """
        savebase(self)
        """
        return _ida_idp.IDB_Hooks_savebase(self, *args)

    def upgraded(self, *args):
        """
        upgraded(self, _from)
        """
        return _ida_idp.IDB_Hooks_upgraded(self, *args)

    def auto_empty(self, *args):
        """
        auto_empty(self)
        """
        return _ida_idp.IDB_Hooks_auto_empty(self, *args)

    def auto_empty_finally(self, *args):
        """
        auto_empty_finally(self)
        """
        return _ida_idp.IDB_Hooks_auto_empty_finally(self, *args)

    def determined_main(self, *args):
        """
        determined_main(self, main)
        """
        return _ida_idp.IDB_Hooks_determined_main(self, *args)

    def local_types_changed(self, *args):
        """
        local_types_changed(self)
        """
        return _ida_idp.IDB_Hooks_local_types_changed(self, *args)

    def extlang_changed(self, *args):
        """
        extlang_changed(self, kind, el, idx)
        """
        return _ida_idp.IDB_Hooks_extlang_changed(self, *args)

    def idasgn_loaded(self, *args):
        """
        idasgn_loaded(self, short_sig_name)
        """
        return _ida_idp.IDB_Hooks_idasgn_loaded(self, *args)

    def kernel_config_loaded(self, *args):
        """
        kernel_config_loaded(self)
        """
        return _ida_idp.IDB_Hooks_kernel_config_loaded(self, *args)

    def loader_finished(self, *args):
        """
        loader_finished(self, li, neflags, filetypename)
        """
        return _ida_idp.IDB_Hooks_loader_finished(self, *args)

    def flow_chart_created(self, *args):
        """
        flow_chart_created(self, fc)
        """
        return _ida_idp.IDB_Hooks_flow_chart_created(self, *args)

    def compiler_changed(self, *args):
        """
        compiler_changed(self)
        """
        return _ida_idp.IDB_Hooks_compiler_changed(self, *args)

    def changing_ti(self, *args):
        """
        changing_ti(self, ea, new_type, new_fnames)
        """
        return _ida_idp.IDB_Hooks_changing_ti(self, *args)

    def ti_changed(self, *args):
        """
        ti_changed(self, ea, type, fnames)
        """
        return _ida_idp.IDB_Hooks_ti_changed(self, *args)

    def changing_op_ti(self, *args):
        """
        changing_op_ti(self, ea, n, new_type, new_fnames)
        """
        return _ida_idp.IDB_Hooks_changing_op_ti(self, *args)

    def op_ti_changed(self, *args):
        """
        op_ti_changed(self, ea, n, type, fnames)
        """
        return _ida_idp.IDB_Hooks_op_ti_changed(self, *args)

    def changing_op_type(self, *args):
        """
        changing_op_type(self, ea, n, opinfo)
        """
        return _ida_idp.IDB_Hooks_changing_op_type(self, *args)

    def op_type_changed(self, *args):
        """
        op_type_changed(self, ea, n)
        """
        return _ida_idp.IDB_Hooks_op_type_changed(self, *args)

    def enum_created(self, *args):
        """
        enum_created(self, id)
        """
        return _ida_idp.IDB_Hooks_enum_created(self, *args)

    def deleting_enum(self, *args):
        """
        deleting_enum(self, id)
        """
        return _ida_idp.IDB_Hooks_deleting_enum(self, *args)

    def enum_deleted(self, *args):
        """
        enum_deleted(self, id)
        """
        return _ida_idp.IDB_Hooks_enum_deleted(self, *args)

    def renaming_enum(self, *args):
        """
        renaming_enum(self, id, is_enum, newname)
        """
        return _ida_idp.IDB_Hooks_renaming_enum(self, *args)

    def enum_renamed(self, *args):
        """
        enum_renamed(self, id)
        """
        return _ida_idp.IDB_Hooks_enum_renamed(self, *args)

    def changing_enum_bf(self, *args):
        """
        changing_enum_bf(self, id, new_bf)
        """
        return _ida_idp.IDB_Hooks_changing_enum_bf(self, *args)

    def enum_bf_changed(self, *args):
        """
        enum_bf_changed(self, id)
        """
        return _ida_idp.IDB_Hooks_enum_bf_changed(self, *args)

    def changing_enum_cmt(self, *args):
        """
        changing_enum_cmt(self, id, repeatable, newcmt)
        """
        return _ida_idp.IDB_Hooks_changing_enum_cmt(self, *args)

    def enum_cmt_changed(self, *args):
        """
        enum_cmt_changed(self, id, repeatable)
        """
        return _ida_idp.IDB_Hooks_enum_cmt_changed(self, *args)

    def enum_member_created(self, *args):
        """
        enum_member_created(self, id, cid)
        """
        return _ida_idp.IDB_Hooks_enum_member_created(self, *args)

    def deleting_enum_member(self, *args):
        """
        deleting_enum_member(self, id, cid)
        """
        return _ida_idp.IDB_Hooks_deleting_enum_member(self, *args)

    def enum_member_deleted(self, *args):
        """
        enum_member_deleted(self, id, cid)
        """
        return _ida_idp.IDB_Hooks_enum_member_deleted(self, *args)

    def struc_created(self, *args):
        """
        struc_created(self, struc_id)
        """
        return _ida_idp.IDB_Hooks_struc_created(self, *args)

    def deleting_struc(self, *args):
        """
        deleting_struc(self, sptr)
        """
        return _ida_idp.IDB_Hooks_deleting_struc(self, *args)

    def struc_deleted(self, *args):
        """
        struc_deleted(self, struc_id)
        """
        return _ida_idp.IDB_Hooks_struc_deleted(self, *args)

    def changing_struc_align(self, *args):
        """
        changing_struc_align(self, sptr)
        """
        return _ida_idp.IDB_Hooks_changing_struc_align(self, *args)

    def struc_align_changed(self, *args):
        """
        struc_align_changed(self, sptr)
        """
        return _ida_idp.IDB_Hooks_struc_align_changed(self, *args)

    def renaming_struc(self, *args):
        """
        renaming_struc(self, id, oldname, newname)
        """
        return _ida_idp.IDB_Hooks_renaming_struc(self, *args)

    def struc_renamed(self, *args):
        """
        struc_renamed(self, sptr)
        """
        return _ida_idp.IDB_Hooks_struc_renamed(self, *args)

    def expanding_struc(self, *args):
        """
        expanding_struc(self, sptr, offset, delta)
        """
        return _ida_idp.IDB_Hooks_expanding_struc(self, *args)

    def struc_expanded(self, *args):
        """
        struc_expanded(self, sptr)
        """
        return _ida_idp.IDB_Hooks_struc_expanded(self, *args)

    def struc_member_created(self, *args):
        """
        struc_member_created(self, sptr, mptr)
        """
        return _ida_idp.IDB_Hooks_struc_member_created(self, *args)

    def deleting_struc_member(self, *args):
        """
        deleting_struc_member(self, sptr, mptr)
        """
        return _ida_idp.IDB_Hooks_deleting_struc_member(self, *args)

    def struc_member_deleted(self, *args):
        """
        struc_member_deleted(self, sptr, member_id, offset)
        """
        return _ida_idp.IDB_Hooks_struc_member_deleted(self, *args)

    def renaming_struc_member(self, *args):
        """
        renaming_struc_member(self, sptr, mptr, newname)
        """
        return _ida_idp.IDB_Hooks_renaming_struc_member(self, *args)

    def struc_member_renamed(self, *args):
        """
        struc_member_renamed(self, sptr, mptr)
        """
        return _ida_idp.IDB_Hooks_struc_member_renamed(self, *args)

    def changing_struc_member(self, *args):
        """
        changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
        """
        return _ida_idp.IDB_Hooks_changing_struc_member(self, *args)

    def struc_member_changed(self, *args):
        """
        struc_member_changed(self, sptr, mptr)
        """
        return _ida_idp.IDB_Hooks_struc_member_changed(self, *args)

    def changing_struc_cmt(self, *args):
        """
        changing_struc_cmt(self, struc_id, repeatable, newcmt)
        """
        return _ida_idp.IDB_Hooks_changing_struc_cmt(self, *args)

    def struc_cmt_changed(self, *args):
        """
        struc_cmt_changed(self, struc_id, repeatable_cmt)
        """
        return _ida_idp.IDB_Hooks_struc_cmt_changed(self, *args)

    def segm_added(self, *args):
        """
        segm_added(self, s)
        """
        return _ida_idp.IDB_Hooks_segm_added(self, *args)

    def deleting_segm(self, *args):
        """
        deleting_segm(self, start_ea)
        """
        return _ida_idp.IDB_Hooks_deleting_segm(self, *args)

    def segm_deleted(self, *args):
        """
        segm_deleted(self, start_ea, end_ea)
        """
        return _ida_idp.IDB_Hooks_segm_deleted(self, *args)

    def changing_segm_start(self, *args):
        """
        changing_segm_start(self, s, new_start, segmod_flags)
        """
        return _ida_idp.IDB_Hooks_changing_segm_start(self, *args)

    def segm_start_changed(self, *args):
        """
        segm_start_changed(self, s, oldstart)
        """
        return _ida_idp.IDB_Hooks_segm_start_changed(self, *args)

    def changing_segm_end(self, *args):
        """
        changing_segm_end(self, s, new_end, segmod_flags)
        """
        return _ida_idp.IDB_Hooks_changing_segm_end(self, *args)

    def segm_end_changed(self, *args):
        """
        segm_end_changed(self, s, oldend)
        """
        return _ida_idp.IDB_Hooks_segm_end_changed(self, *args)

    def changing_segm_name(self, *args):
        """
        changing_segm_name(self, s, oldname)
        """
        return _ida_idp.IDB_Hooks_changing_segm_name(self, *args)

    def segm_name_changed(self, *args):
        """
        segm_name_changed(self, s, name)
        """
        return _ida_idp.IDB_Hooks_segm_name_changed(self, *args)

    def changing_segm_class(self, *args):
        """
        changing_segm_class(self, s)
        """
        return _ida_idp.IDB_Hooks_changing_segm_class(self, *args)

    def segm_class_changed(self, *args):
        """
        segm_class_changed(self, s, sclass)
        """
        return _ida_idp.IDB_Hooks_segm_class_changed(self, *args)

    def segm_attrs_updated(self, *args):
        """
        segm_attrs_updated(self, s)
        """
        return _ida_idp.IDB_Hooks_segm_attrs_updated(self, *args)

    def segm_moved(self, *args):
        """
        segm_moved(self, _from, to, size, changed_netmap)
        """
        return _ida_idp.IDB_Hooks_segm_moved(self, *args)

    def allsegs_moved(self, *args):
        """
        allsegs_moved(self, info)
        """
        return _ida_idp.IDB_Hooks_allsegs_moved(self, *args)

    def func_added(self, *args):
        """
        func_added(self, pfn)
        """
        return _ida_idp.IDB_Hooks_func_added(self, *args)

    def func_updated(self, *args):
        """
        func_updated(self, pfn)
        """
        return _ida_idp.IDB_Hooks_func_updated(self, *args)

    def set_func_start(self, *args):
        """
        set_func_start(self, pfn, new_start)
        """
        return _ida_idp.IDB_Hooks_set_func_start(self, *args)

    def set_func_end(self, *args):
        """
        set_func_end(self, pfn, new_end)
        """
        return _ida_idp.IDB_Hooks_set_func_end(self, *args)

    def deleting_func(self, *args):
        """
        deleting_func(self, pfn)
        """
        return _ida_idp.IDB_Hooks_deleting_func(self, *args)

    def frame_deleted(self, *args):
        """
        frame_deleted(self, pfn)
        """
        return _ida_idp.IDB_Hooks_frame_deleted(self, *args)

    def thunk_func_created(self, *args):
        """
        thunk_func_created(self, pfn)
        """
        return _ida_idp.IDB_Hooks_thunk_func_created(self, *args)

    def func_tail_appended(self, *args):
        """
        func_tail_appended(self, pfn, tail)
        """
        return _ida_idp.IDB_Hooks_func_tail_appended(self, *args)

    def deleting_func_tail(self, *args):
        """
        deleting_func_tail(self, pfn, tail)
        """
        return _ida_idp.IDB_Hooks_deleting_func_tail(self, *args)

    def func_tail_deleted(self, *args):
        """
        func_tail_deleted(self, pfn, tail_ea)
        """
        return _ida_idp.IDB_Hooks_func_tail_deleted(self, *args)

    def tail_owner_changed(self, *args):
        """
        tail_owner_changed(self, tail, owner_func, old_owner)
        """
        return _ida_idp.IDB_Hooks_tail_owner_changed(self, *args)

    def func_noret_changed(self, *args):
        """
        func_noret_changed(self, pfn)
        """
        return _ida_idp.IDB_Hooks_func_noret_changed(self, *args)

    def stkpnts_changed(self, *args):
        """
        stkpnts_changed(self, pfn)
        """
        return _ida_idp.IDB_Hooks_stkpnts_changed(self, *args)

    def updating_tryblks(self, *args):
        """
        updating_tryblks(self, tbv)
        """
        return _ida_idp.IDB_Hooks_updating_tryblks(self, *args)

    def tryblks_updated(self, *args):
        """
        tryblks_updated(self, tbv)
        """
        return _ida_idp.IDB_Hooks_tryblks_updated(self, *args)

    def deleting_tryblks(self, *args):
        """
        deleting_tryblks(self, range)
        """
        return _ida_idp.IDB_Hooks_deleting_tryblks(self, *args)

    def sgr_changed(self, *args):
        """
        sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
        """
        return _ida_idp.IDB_Hooks_sgr_changed(self, *args)

    def make_code(self, *args):
        """
        make_code(self, insn)
        """
        return _ida_idp.IDB_Hooks_make_code(self, *args)

    def make_data(self, *args):
        """
        make_data(self, ea, flags, tid, len)
        """
        return _ida_idp.IDB_Hooks_make_data(self, *args)

    def destroyed_items(self, *args):
        """
        destroyed_items(self, ea1, ea2, will_disable_range)
        """
        return _ida_idp.IDB_Hooks_destroyed_items(self, *args)

    def renamed(self, *args):
        """
        renamed(self, ea, new_name, local_name)
        """
        return _ida_idp.IDB_Hooks_renamed(self, *args)

    def byte_patched(self, *args):
        """
        byte_patched(self, ea, old_value)
        """
        return _ida_idp.IDB_Hooks_byte_patched(self, *args)

    def changing_cmt(self, *args):
        """
        changing_cmt(self, ea, repeatable_cmt, newcmt)
        """
        return _ida_idp.IDB_Hooks_changing_cmt(self, *args)

    def cmt_changed(self, *args):
        """
        cmt_changed(self, ea, repeatable_cmt)
        """
        return _ida_idp.IDB_Hooks_cmt_changed(self, *args)

    def changing_range_cmt(self, *args):
        """
        changing_range_cmt(self, kind, a, cmt, repeatable)
        """
        return _ida_idp.IDB_Hooks_changing_range_cmt(self, *args)

    def range_cmt_changed(self, *args):
        """
        range_cmt_changed(self, kind, a, cmt, repeatable)
        """
        return _ida_idp.IDB_Hooks_range_cmt_changed(self, *args)

    def extra_cmt_changed(self, *args):
        """
        extra_cmt_changed(self, ea, line_idx, cmt)
        """
        return _ida_idp.IDB_Hooks_extra_cmt_changed(self, *args)

    def item_color_changed(self, *args):
        """
        item_color_changed(self, ea, color)
        """
        return _ida_idp.IDB_Hooks_item_color_changed(self, *args)

    def callee_addr_changed(self, *args):
        """
        callee_addr_changed(self, ea, callee)
        """
        return _ida_idp.IDB_Hooks_callee_addr_changed(self, *args)

    def bookmark_changed(self, *args):
        """
        bookmark_changed(self, index, pos, desc)
        """
        return _ida_idp.IDB_Hooks_bookmark_changed(self, *args)

    def sgr_deleted(self, *args):
        """
        sgr_deleted(self, start_ea, end_ea, regnum)
        """
        return _ida_idp.IDB_Hooks_sgr_deleted(self, *args)

    __swig_destroy__ = _ida_idp.delete_IDB_Hooks
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_idp.disown_IDB_Hooks(self)
        return weakref_proxy(self)
IDB_Hooks_swigregister = _ida_idp.IDB_Hooks_swigregister
IDB_Hooks_swigregister(IDB_Hooks)


def get_idb_notifier_addr(*args):
  """
  get_idb_notifier_addr(arg1) -> PyObject *
  """
  return _ida_idp.get_idb_notifier_addr(*args)

def get_idb_notifier_ud_addr(*args):
  """
  get_idb_notifier_ud_addr(hooks) -> PyObject *
  """
  return _ida_idp.get_idb_notifier_ud_addr(*args)
#<pycode(py_idp_idbhooks)>

class _processor_t_Trampoline_IDB_Hooks(IDB_Hooks):
    def __init__(self, proc):
        IDB_Hooks.__init__(self, ida_idaapi.HBF_CALL_WITH_NEW_EXEC | ida_idaapi.HBF_VOLATILE_METHOD_SET)
        import weakref
        self.proc = weakref.ref(proc)
        for key in dir(self):
            if not key.startswith("_") and not key in ["proc"]:
                thing = getattr(self, key)
                if hasattr(thing, "__call__"):
                    setattr(self, key, self.__make_parent_caller(key))

    def __dummy(self, *args):
        return 0

    def __make_parent_caller(self, key):
        # we can't get the method at this point, as it'll be bound
        # to the processor_t instance, which means it'll increase
        # the reference counting
        def call_parent(*args):
            return getattr(self.proc(), key, self.__dummy)(*args)
        return call_parent

#</pycode(py_idp_idbhooks)>

#<pycode(py_idp_notify_when)>
import weakref
class _notify_when_dispatcher_t:

    class _callback_t:
        def __init__(self, fun):
            self.fun = fun
            self.slots = 0

    class _IDP_Hooks(IDP_Hooks):
        def __init__(self, dispatcher):
            IDP_Hooks.__init__(self)
            self.dispatcher = weakref.ref(dispatcher)

        def ev_newfile(self, name):
            return self.dispatcher().dispatch(ida_idaapi.NW_OPENIDB, 0)

        def ev_oldfile(self, name):
            return self.dispatcher().dispatch(ida_idaapi.NW_OPENIDB, 1)

    class _IDB_Hooks(IDB_Hooks):
        def __init__(self, dispatcher):
            IDB_Hooks.__init__(self)
            self.dispatcher = weakref.ref(dispatcher)

        def closebase(self):
            return self.dispatcher().dispatch(ida_idaapi.NW_CLOSEIDB)


    def __init__(self):
        self.idp_hooks = self._IDP_Hooks(self)
        self.idp_hooks.hook()
        self.idb_hooks = self._IDB_Hooks(self)
        self.idb_hooks.hook()
        self.callbacks = []

    def _find(self, fun):
        for idx, cb in enumerate(self.callbacks):
            if cb.fun == fun:
                return idx, cb
        return None, None

    def dispatch(self, slot, *args):
        for cb in self.callbacks[:]: # make a copy, since dispatch() could cause some callbacks to disappear
            if (cb.slots & slot) != 0:
                cb.fun(slot, *args)
        return 0

    def notify_when(self, when, fun):
        _, cb = self._find(fun)
        if cb is None:
            cb = self._callback_t(fun)
            self.callbacks.append(cb)
        if (when & ida_idaapi.NW_REMOVE) != 0:
            cb.slots &= ~(when & ~ida_idaapi.NW_REMOVE)
        else:
            cb.slots |= when
        if cb.slots == 0:
            idx, cb = self._find(cb.fun)
            del self.callbacks[idx]
        return True

#</pycode(py_idp_notify_when)>

if _BC695:
    AS_NOTAB=0
    CUSTOM_CMD_ITYPE=CUSTOM_INSN_ITYPE
    InstrIsSet=has_insn_feature
    NEXTEAS_ANSWER_SIZE=0
    PR_FULL_HIFXP=0
    SETPROC_ALL=SETPROC_LOADER_NON_FATAL
    SETPROC_COMPAT=SETPROC_IDB
    SETPROC_FATAL=SETPROC_LOADER
    area_cmt_changed=range_cmt_changed
    changed_stkpnts=stkpnts_changed
    changed_struc=struc_align_changed
    changing_area_cmt=changing_range_cmt
    changing_struc=changing_struc_align
    func_tail_removed=func_tail_deleted
    get_reg_info2=get_reg_info
    ph_get_regCodeSreg=ph_get_reg_code_sreg
    ph_get_regDataSreg=ph_get_reg_data_sreg
    ph_get_regFirstSreg=ph_get_reg_first_sreg
    ph_get_regLastSreg=ph_get_reg_last_sreg
    removing_func_tail=deleting_func_tail
    segm_attrs_changed=segm_attrs_updated
    str2regf=str2reg
    def __wrap_insn_func(name):
        def __wrapper(*args):
            arg0 = args[0]
            import ida_ua
            if not isinstance(arg0, ida_ua.insn_t):
                tmp = ida_ua.insn_t()
                if not ida_ua.decode_insn(tmp, arg0):
                    return False
                arg0 = tmp
            return getattr(_ida_idp, name)(arg0, *args[1:])
        globals()[name] = __wrapper
    __wrap_insn_func("is_call_insn")
    __wrap_insn_func("is_ret_insn")
    __wrap_insn_func("is_indirect_jump_insn")
    __wrap_insn_func("is_basic_block_end")
    def parse_reg_name(*args):
        if isinstance(args[1], reg_info_t): # 6.95: regname, reg_info_t
              regname, ri = args
        else:                               # 7.00: reg_info_t, regname
              ri, regname = args
        return _ida_idp.parse_reg_name(ri, regname)
    def __call_IDP_Hooks_auto_queue_empty(cb, qtype):
        old_rc = cb(qtype)
        if old_rc == 0: # 6.95's queue not empty anymore
            rc = -1 # 7.0's queue not empty anymore
        else:
            rc = old_rc
        return rc
    import ida_ida
    ida_ida.__wrap_hooks_callback(
        IDP_Hooks,
        "ev_auto_queue_empty",
        "auto_queue_empty",
        __call_IDP_Hooks_auto_queue_empty)



