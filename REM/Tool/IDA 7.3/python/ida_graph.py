# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: graph
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_graph', [dirname(__file__)])
        except ImportError:
            import _ida_graph
            return _ida_graph
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_graph', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_graph = swig_import_helper()
    del swig_import_helper
else:
    import _ida_graph
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class screen_graph_selection_base_t(object):
    """
    Proxy of C++ qvector<(selection_item_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> screen_graph_selection_base_t
        __init__(self, x) -> screen_graph_selection_base_t
        """
        this = _ida_graph.new_screen_graph_selection_base_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_screen_graph_selection_base_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_graph.screen_graph_selection_base_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_graph.screen_graph_selection_base_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.screen_graph_selection_base_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.screen_graph_selection_base_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=selection_item_t())
        """
        return _ida_graph.screen_graph_selection_base_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_graph.screen_graph_selection_base_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_graph.screen_graph_selection_base_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_graph.screen_graph_selection_base_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_graph.screen_graph_selection_base_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> selection_item_t
        begin(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> selection_item_t
        end(self) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> selection_item_t
        erase(self, first, last) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> selection_item_t
        find(self, x) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_graph.screen_graph_selection_base_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_base_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> selection_item_t
        """
        return _ida_graph.screen_graph_selection_base_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_graph.screen_graph_selection_base_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

screen_graph_selection_base_t_swigregister = _ida_graph.screen_graph_selection_base_t_swigregister
screen_graph_selection_base_t_swigregister(screen_graph_selection_base_t)

class node_layout_t(object):
    """
    Proxy of C++ qvector<(rect_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> node_layout_t
        __init__(self, x) -> node_layout_t
        """
        this = _ida_graph.new_node_layout_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_node_layout_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> rect_t
        """
        return _ida_graph.node_layout_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_graph.node_layout_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_graph.node_layout_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.node_layout_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> rect_t
        """
        return _ida_graph.node_layout_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_graph.node_layout_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.node_layout_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.node_layout_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=rect_t())
        """
        return _ida_graph.node_layout_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_graph.node_layout_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_graph.node_layout_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_graph.node_layout_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_graph.node_layout_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> rect_t
        """
        return _ida_graph.node_layout_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_graph.node_layout_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.node_layout_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.node_layout_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> rect_t
        begin(self) -> rect_t
        """
        return _ida_graph.node_layout_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> rect_t
        end(self) -> rect_t
        """
        return _ida_graph.node_layout_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> rect_t
        """
        return _ida_graph.node_layout_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> rect_t
        erase(self, first, last) -> rect_t
        """
        return _ida_graph.node_layout_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> rect_t
        find(self, x) -> rect_t
        """
        return _ida_graph.node_layout_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_graph.node_layout_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_graph.node_layout_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_graph.node_layout_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_graph.node_layout_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> rect_t
        """
        return _ida_graph.node_layout_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_graph.node_layout_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

node_layout_t_swigregister = _ida_graph.node_layout_t_swigregister
node_layout_t_swigregister(node_layout_t)

class pointvec_t(object):
    """
    Proxy of C++ qvector<(point_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> pointvec_t
        __init__(self, x) -> pointvec_t
        """
        this = _ida_graph.new_pointvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_pointvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> point_t
        """
        return _ida_graph.pointvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_graph.pointvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_graph.pointvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.pointvec_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> point_t
        """
        return _ida_graph.pointvec_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_graph.pointvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.pointvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_graph.pointvec_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=point_t())
        """
        return _ida_graph.pointvec_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_graph.pointvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_graph.pointvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_graph.pointvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_graph.pointvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> point_t
        """
        return _ida_graph.pointvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_graph.pointvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.pointvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.pointvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> point_t
        begin(self) -> point_t
        """
        return _ida_graph.pointvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> point_t
        end(self) -> point_t
        """
        return _ida_graph.pointvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> point_t
        """
        return _ida_graph.pointvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> point_t
        erase(self, first, last) -> point_t
        """
        return _ida_graph.pointvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> point_t
        find(self, x) -> point_t
        """
        return _ida_graph.pointvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_graph.pointvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_graph.pointvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_graph.pointvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_graph.pointvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> point_t
        """
        return _ida_graph.pointvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_graph.pointvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

pointvec_t_swigregister = _ida_graph.pointvec_t_swigregister
pointvec_t_swigregister(pointvec_t)

NIF_BG_COLOR = _ida_graph.NIF_BG_COLOR
"""
 'node_info_t::bg_color'
"""
NIF_FRAME_COLOR = _ida_graph.NIF_FRAME_COLOR
"""
 'node_info_t::frame_color'
"""
NIF_EA = _ida_graph.NIF_EA
"""
 'node_info_t::ea'
"""
NIF_TEXT = _ida_graph.NIF_TEXT
"""
 'node_info_t::text'
"""
NIF_FLAGS = _ida_graph.NIF_FLAGS
"""
 'node_info_t::flags'
"""
NIF_ALL = _ida_graph.NIF_ALL
GLICTL_CENTER = _ida_graph.GLICTL_CENTER
"""
the gli should be set/get as center
"""
class node_info_t(object):
    """
    Proxy of C++ node_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> node_info_t
        """
        this = _ida_graph.new_node_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    bg_color = _swig_property(_ida_graph.node_info_t_bg_color_get, _ida_graph.node_info_t_bg_color_set)
    frame_color = _swig_property(_ida_graph.node_info_t_frame_color_get, _ida_graph.node_info_t_frame_color_set)
    flags = _swig_property(_ida_graph.node_info_t_flags_get, _ida_graph.node_info_t_flags_set)
    ea = _swig_property(_ida_graph.node_info_t_ea_get, _ida_graph.node_info_t_ea_set)
    text = _swig_property(_ida_graph.node_info_t_text_get, _ida_graph.node_info_t_text_set)
    def valid_bg_color(self, *args):
        """
        valid_bg_color(self) -> bool
        """
        return _ida_graph.node_info_t_valid_bg_color(self, *args)

    def valid_frame_color(self, *args):
        """
        valid_frame_color(self) -> bool
        """
        return _ida_graph.node_info_t_valid_frame_color(self, *args)

    def valid_ea(self, *args):
        """
        valid_ea(self) -> bool
        """
        return _ida_graph.node_info_t_valid_ea(self, *args)

    def valid_text(self, *args):
        """
        valid_text(self) -> bool
        """
        return _ida_graph.node_info_t_valid_text(self, *args)

    def valid_flags(self, *args):
        """
        valid_flags(self) -> bool
        """
        return _ida_graph.node_info_t_valid_flags(self, *args)

    def get_flags_for_valid(self, *args):
        """
        get_flags_for_valid(self) -> uint32
        """
        return _ida_graph.node_info_t_get_flags_for_valid(self, *args)

    __swig_destroy__ = _ida_graph.delete_node_info_t
    __del__ = lambda self : None;
node_info_t_swigregister = _ida_graph.node_info_t_swigregister
node_info_t_swigregister(node_info_t)
NIFF_SHOW_CONTENTS = _ida_graph.NIFF_SHOW_CONTENTS


def get_node_info(*args):
  """
  get_node_info(out, gid, node) -> bool


  Get node info.
  
  @param out: result (C++: node_info_t  *)
  @param gid: id of desired graph (C++: graph_id_t)
  @param node: node number (C++: int)
  @return: success
  """
  return _ida_graph.get_node_info(*args)

def set_node_info(*args):
  """
  set_node_info(gid, node, ni, flags)


  Set node info.
  
  @param gid: id of desired graph (C++: graph_id_t)
  @param node: node number (C++: int)
  @param ni: node info to use (C++: const  node_info_t  &)
  @param flags: combination of  Node info flags , identifying which
                fields of 'ni' will be used (C++: uint32)
  """
  return _ida_graph.set_node_info(*args)

def del_node_info(*args):
  """
  del_node_info(gid, node)


  Delete the 'node_info_t' for the given node.
  
  
  @param gid (C++: graph_id_t)
  @param node (C++: int)
  """
  return _ida_graph.del_node_info(*args)

def clr_node_info(*args):
  """
  clr_node_info(gid, node, flags)


  Clear node info for the given node.
  
  @param gid: id of desired graph (C++: graph_id_t)
  @param node: node number (C++: int)
  @param flags: combination of  Node info flags , identifying which
                fields of  node_info_t  will be cleared (C++: uint32)
  """
  return _ida_graph.clr_node_info(*args)
class node_ordering_t(object):
    """
    Proxy of C++ node_ordering_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.node_ordering_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, n)
        """
        return _ida_graph.node_ordering_t_resize(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_graph.node_ordering_t_size(self, *args)

    def set(self, *args):
        """
        set(self, _node, num)
        """
        return _ida_graph.node_ordering_t_set(self, *args)

    def node(self, *args):
        """
        node(self, _order) -> int
        """
        return _ida_graph.node_ordering_t_node(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> node_ordering_t
        """
        this = _ida_graph.new_node_ordering_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_node_ordering_t
    __del__ = lambda self : None;
node_ordering_t_swigregister = _ida_graph.node_ordering_t_swigregister
node_ordering_t_swigregister(node_ordering_t)

class edge_t(object):
    """
    Proxy of C++ edge_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    src = _swig_property(_ida_graph.edge_t_src_get, _ida_graph.edge_t_src_set)
    dst = _swig_property(_ida_graph.edge_t_dst_get, _ida_graph.edge_t_dst_set)
    def __init__(self, *args):
        """
        __init__(self) -> edge_t
        __init__(self, x, y) -> edge_t
        """
        this = _ida_graph.new_edge_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __lt__(self, *args):
        """
        __lt__(self, y) -> bool
        """
        return _ida_graph.edge_t___lt__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, y) -> bool
        """
        return _ida_graph.edge_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, y) -> bool
        """
        return _ida_graph.edge_t___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_edge_t
    __del__ = lambda self : None;
edge_t_swigregister = _ida_graph.edge_t_swigregister
edge_t_swigregister(edge_t)

edge_error = _ida_graph.edge_error
edge_tree = _ida_graph.edge_tree
edge_forward = _ida_graph.edge_forward
edge_back = _ida_graph.edge_back
edge_cross = _ida_graph.edge_cross
edge_subgraph = _ida_graph.edge_subgraph
class graph_node_visitor_t(object):
    """
    Proxy of C++ graph_node_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def reinit(self, *args):
        """
        reinit(self)
        """
        return _ida_graph.graph_node_visitor_t_reinit(self, *args)

    def set_visited(self, *args):
        """
        set_visited(self, n)
        """
        return _ida_graph.graph_node_visitor_t_set_visited(self, *args)

    def is_visited(self, *args):
        """
        is_visited(self, n) -> bool
        """
        return _ida_graph.graph_node_visitor_t_is_visited(self, *args)

    def visit_node(self, *args):
        """
        visit_node(self, arg0) -> int
        """
        return _ida_graph.graph_node_visitor_t_visit_node(self, *args)

    def is_forbidden_edge(self, *args):
        """
        is_forbidden_edge(self, arg0, arg1) -> bool
        """
        return _ida_graph.graph_node_visitor_t_is_forbidden_edge(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> graph_node_visitor_t
        """
        if self.__class__ == graph_node_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_graph.new_graph_node_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_graph_node_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_node_visitor_t(self)
        return weakref_proxy(self)
graph_node_visitor_t_swigregister = _ida_graph.graph_node_visitor_t_swigregister
graph_node_visitor_t_swigregister(graph_node_visitor_t)

class graph_path_visitor_t(object):
    """
    Proxy of C++ graph_path_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    path = _swig_property(_ida_graph.graph_path_visitor_t_path_get, _ida_graph.graph_path_visitor_t_path_set)
    prune = _swig_property(_ida_graph.graph_path_visitor_t_prune_get, _ida_graph.graph_path_visitor_t_prune_set)
    def walk_forward(self, *args):
        """
        walk_forward(self, arg0) -> int
        """
        return _ida_graph.graph_path_visitor_t_walk_forward(self, *args)

    def walk_backward(self, *args):
        """
        walk_backward(self, arg0) -> int
        """
        return _ida_graph.graph_path_visitor_t_walk_backward(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> graph_path_visitor_t
        """
        if self.__class__ == graph_path_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_graph.new_graph_path_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_graph_path_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_path_visitor_t(self)
        return weakref_proxy(self)
graph_path_visitor_t_swigregister = _ida_graph.graph_path_visitor_t_swigregister
graph_path_visitor_t_swigregister(graph_path_visitor_t)

class point_t(object):
    """
    Proxy of C++ point_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_graph.point_t_x_get, _ida_graph.point_t_x_set)
    y = _swig_property(_ida_graph.point_t_y_get, _ida_graph.point_t_y_set)
    def __init__(self, *args):
        """
        __init__(self) -> point_t
        __init__(self, _x, _y) -> point_t
        """
        this = _ida_graph.new_point_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args):
        """
        add(self, r) -> point_t
        """
        return _ida_graph.point_t_add(self, *args)

    def sub(self, *args):
        """
        sub(self, r) -> point_t
        """
        return _ida_graph.point_t_sub(self, *args)

    def negate(self, *args):
        """
        negate(self)
        """
        return _ida_graph.point_t_negate(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.point_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.point_t___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_point_t
    __del__ = lambda self : None;
point_t_swigregister = _ida_graph.point_t_swigregister
point_t_swigregister(point_t)


def calc_dist(*args):
  """
  calc_dist(p, q) -> double


  Calculate distance between p and q.
  
  
  @param p (C++: point_t)
  @param q (C++: point_t)
  """
  return _ida_graph.calc_dist(*args)
class pointseq_t(pointvec_t):
    """
    Proxy of C++ pointseq_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> pointseq_t
        """
        this = _ida_graph.new_pointseq_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_pointseq_t
    __del__ = lambda self : None;
pointseq_t_swigregister = _ida_graph.pointseq_t_swigregister
pointseq_t_swigregister(pointseq_t)

class rect_t(object):
    """
    Proxy of C++ rect_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    left = _swig_property(_ida_graph.rect_t_left_get, _ida_graph.rect_t_left_set)
    top = _swig_property(_ida_graph.rect_t_top_get, _ida_graph.rect_t_top_set)
    right = _swig_property(_ida_graph.rect_t_right_get, _ida_graph.rect_t_right_set)
    bottom = _swig_property(_ida_graph.rect_t_bottom_get, _ida_graph.rect_t_bottom_set)
    def __init__(self, *args):
        """
        __init__(self) -> rect_t
        __init__(self, l, t, r, b) -> rect_t
        __init__(self, p0, p1) -> rect_t
        """
        this = _ida_graph.new_rect_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def width(self, *args):
        """
        width(self) -> int
        """
        return _ida_graph.rect_t_width(self, *args)

    def height(self, *args):
        """
        height(self) -> int
        """
        return _ida_graph.rect_t_height(self, *args)

    def move_to(self, *args):
        """
        move_to(self, p)
        """
        return _ida_graph.rect_t_move_to(self, *args)

    def move_by(self, *args):
        """
        move_by(self, p)
        """
        return _ida_graph.rect_t_move_by(self, *args)

    def center(self, *args):
        """
        center(self) -> point_t
        """
        return _ida_graph.rect_t_center(self, *args)

    def topleft(self, *args):
        """
        topleft(self) -> point_t
        """
        return _ida_graph.rect_t_topleft(self, *args)

    def bottomright(self, *args):
        """
        bottomright(self) -> point_t
        """
        return _ida_graph.rect_t_bottomright(self, *args)

    def grow(self, *args):
        """
        grow(self, delta)
        """
        return _ida_graph.rect_t_grow(self, *args)

    def intersect(self, *args):
        """
        intersect(self, r)
        """
        return _ida_graph.rect_t_intersect(self, *args)

    def make_union(self, *args):
        """
        make_union(self, r)
        """
        return _ida_graph.rect_t_make_union(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.rect_t_empty(self, *args)

    def is_intersection_empty(self, *args):
        """
        is_intersection_empty(self, r) -> bool
        """
        return _ida_graph.rect_t_is_intersection_empty(self, *args)

    def contains(self, *args):
        """
        contains(self, p) -> bool
        """
        return _ida_graph.rect_t_contains(self, *args)

    def area(self, *args):
        """
        area(self) -> int
        """
        return _ida_graph.rect_t_area(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.rect_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.rect_t___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_rect_t
    __del__ = lambda self : None;
rect_t_swigregister = _ida_graph.rect_t_swigregister
rect_t_swigregister(rect_t)

class TPointDouble(object):
    """
    Proxy of C++ TPointDouble class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_graph.TPointDouble_x_get, _ida_graph.TPointDouble_x_set)
    y = _swig_property(_ida_graph.TPointDouble_y_get, _ida_graph.TPointDouble_y_set)
    def __init__(self, *args):
        """
        __init__(self) -> TPointDouble
        __init__(self, a, b) -> TPointDouble
        __init__(self, r) -> TPointDouble
        """
        this = _ida_graph.new_TPointDouble(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args):
        """
        add(self, r)
        """
        return _ida_graph.TPointDouble_add(self, *args)

    def sub(self, *args):
        """
        sub(self, r)
        """
        return _ida_graph.TPointDouble_sub(self, *args)

    def negate(self, *args):
        """
        negate(self)
        """
        return _ida_graph.TPointDouble_negate(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.TPointDouble___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.TPointDouble___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_TPointDouble
    __del__ = lambda self : None;
TPointDouble_swigregister = _ida_graph.TPointDouble_swigregister
TPointDouble_swigregister(TPointDouble)

class edge_info_t(object):
    """
    Proxy of C++ edge_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    color = _swig_property(_ida_graph.edge_info_t_color_get, _ida_graph.edge_info_t_color_set)
    width = _swig_property(_ida_graph.edge_info_t_width_get, _ida_graph.edge_info_t_width_set)
    srcoff = _swig_property(_ida_graph.edge_info_t_srcoff_get, _ida_graph.edge_info_t_srcoff_set)
    dstoff = _swig_property(_ida_graph.edge_info_t_dstoff_get, _ida_graph.edge_info_t_dstoff_set)
    layout = _swig_property(_ida_graph.edge_info_t_layout_get, _ida_graph.edge_info_t_layout_set)
    def reverse_layout(self, *args):
        """
        reverse_layout(self)
        """
        return _ida_graph.edge_info_t_reverse_layout(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> edge_info_t
        """
        this = _ida_graph.new_edge_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_edge_info_t
    __del__ = lambda self : None;
edge_info_t_swigregister = _ida_graph.edge_info_t_swigregister
edge_info_t_swigregister(edge_info_t)
cvar = _ida_graph.cvar
layout_none = cvar.layout_none
layout_digraph = cvar.layout_digraph
layout_tree = cvar.layout_tree
layout_circle = cvar.layout_circle
layout_polar_tree = cvar.layout_polar_tree
layout_orthogonal = cvar.layout_orthogonal
layout_radial_tree = cvar.layout_radial_tree

class edge_layout_point_t(object):
    """
    Proxy of C++ edge_layout_point_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pidx = _swig_property(_ida_graph.edge_layout_point_t_pidx_get, _ida_graph.edge_layout_point_t_pidx_set)
    e = _swig_property(_ida_graph.edge_layout_point_t_e_get, _ida_graph.edge_layout_point_t_e_set)
    def __init__(self, *args):
        """
        __init__(self) -> edge_layout_point_t
        __init__(self, r) -> edge_layout_point_t
        __init__(self, _e, _pidx) -> edge_layout_point_t
        """
        this = _ida_graph.new_edge_layout_point_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_graph.edge_layout_point_t_compare(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.edge_layout_point_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.edge_layout_point_t___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_edge_layout_point_t
    __del__ = lambda self : None;
edge_layout_point_t_swigregister = _ida_graph.edge_layout_point_t_swigregister
edge_layout_point_t_swigregister(edge_layout_point_t)

class selection_item_t(object):
    """
    Proxy of C++ selection_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    is_node = _swig_property(_ida_graph.selection_item_t_is_node_get, _ida_graph.selection_item_t_is_node_set)
    node = _swig_property(_ida_graph.selection_item_t_node_get, _ida_graph.selection_item_t_node_set)
    elp = _swig_property(_ida_graph.selection_item_t_elp_get, _ida_graph.selection_item_t_elp_set)
    def __init__(self, *args):
        """
        __init__(self) -> selection_item_t
        __init__(self, n) -> selection_item_t
        __init__(self, _elp) -> selection_item_t
        __init__(self, e, idx) -> selection_item_t
        """
        this = _ida_graph.new_selection_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_graph.selection_item_t_compare(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_graph.selection_item_t___lt__(self, *args)

    __swig_destroy__ = _ida_graph.delete_selection_item_t
    __del__ = lambda self : None;
selection_item_t_swigregister = _ida_graph.selection_item_t_swigregister
selection_item_t_swigregister(selection_item_t)

class screen_graph_selection_t(screen_graph_selection_base_t):
    """
    Proxy of C++ screen_graph_selection_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def has(self, *args):
        """
        has(self, item) -> bool
        """
        return _ida_graph.screen_graph_selection_t_has(self, *args)

    def add(self, *args):
        """
        add(self, s)
        """
        return _ida_graph.screen_graph_selection_t_add(self, *args)

    def sub(self, *args):
        """
        sub(self, s)
        """
        return _ida_graph.screen_graph_selection_t_sub(self, *args)

    def add_node(self, *args):
        """
        add_node(self, node)
        """
        return _ida_graph.screen_graph_selection_t_add_node(self, *args)

    def del_node(self, *args):
        """
        del_node(self, node)
        """
        return _ida_graph.screen_graph_selection_t_del_node(self, *args)

    def add_point(self, *args):
        """
        add_point(self, e, idx)
        """
        return _ida_graph.screen_graph_selection_t_add_point(self, *args)

    def del_point(self, *args):
        """
        del_point(self, e, idx)
        """
        return _ida_graph.screen_graph_selection_t_del_point(self, *args)

    def nodes_count(self, *args):
        """
        nodes_count(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_nodes_count(self, *args)

    def points_count(self, *args):
        """
        points_count(self) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_points_count(self, *args)

    def items_count(self, *args):
        """
        items_count(self, look_for_nodes) -> size_t
        """
        return _ida_graph.screen_graph_selection_t_items_count(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> screen_graph_selection_t
        """
        this = _ida_graph.new_screen_graph_selection_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_screen_graph_selection_t
    __del__ = lambda self : None;
screen_graph_selection_t_swigregister = _ida_graph.screen_graph_selection_t_swigregister
screen_graph_selection_t_swigregister(screen_graph_selection_t)

class edge_segment_t(object):
    """
    Proxy of C++ edge_segment_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e = _swig_property(_ida_graph.edge_segment_t_e_get, _ida_graph.edge_segment_t_e_set)
    nseg = _swig_property(_ida_graph.edge_segment_t_nseg_get, _ida_graph.edge_segment_t_nseg_set)
    x0 = _swig_property(_ida_graph.edge_segment_t_x0_get, _ida_graph.edge_segment_t_x0_set)
    x1 = _swig_property(_ida_graph.edge_segment_t_x1_get, _ida_graph.edge_segment_t_x1_set)
    def length(self, *args):
        """
        length(self) -> size_t
        """
        return _ida_graph.edge_segment_t_length(self, *args)

    def toright(self, *args):
        """
        toright(self) -> bool
        """
        return _ida_graph.edge_segment_t_toright(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_graph.edge_segment_t___lt__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> edge_segment_t
        """
        this = _ida_graph.new_edge_segment_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_edge_segment_t
    __del__ = lambda self : None;
edge_segment_t_swigregister = _ida_graph.edge_segment_t_swigregister
edge_segment_t_swigregister(edge_segment_t)

git_none = _ida_graph.git_none
git_edge = _ida_graph.git_edge
git_node = _ida_graph.git_node
git_tool = _ida_graph.git_tool
git_text = _ida_graph.git_text
git_elp = _ida_graph.git_elp
class graph_item_t(object):
    """
    Proxy of C++ graph_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    type = _swig_property(_ida_graph.graph_item_t_type_get, _ida_graph.graph_item_t_type_set)
    e = _swig_property(_ida_graph.graph_item_t_e_get, _ida_graph.graph_item_t_e_set)
    n = _swig_property(_ida_graph.graph_item_t_n_get, _ida_graph.graph_item_t_n_set)
    b = _swig_property(_ida_graph.graph_item_t_b_get, _ida_graph.graph_item_t_b_set)
    p = _swig_property(_ida_graph.graph_item_t_p_get, _ida_graph.graph_item_t_p_set)
    elp = _swig_property(_ida_graph.graph_item_t_elp_get, _ida_graph.graph_item_t_elp_set)
    def is_node(self, *args):
        """
        is_node(self) -> bool
        """
        return _ida_graph.graph_item_t_is_node(self, *args)

    def is_edge(self, *args):
        """
        is_edge(self) -> bool
        """
        return _ida_graph.graph_item_t_is_edge(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> graph_item_t
        """
        this = _ida_graph.new_graph_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_graph_item_t
    __del__ = lambda self : None;
graph_item_t_swigregister = _ida_graph.graph_item_t_swigregister
graph_item_t_swigregister(graph_item_t)

class interval_t(object):
    """
    Proxy of C++ interval_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x0 = _swig_property(_ida_graph.interval_t_x0_get, _ida_graph.interval_t_x0_set)
    x1 = _swig_property(_ida_graph.interval_t_x1_get, _ida_graph.interval_t_x1_set)
    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.interval_t_empty(self, *args)

    def intersect(self, *args):
        """
        intersect(self, r)
        """
        return _ida_graph.interval_t_intersect(self, *args)

    def make_union(self, *args):
        """
        make_union(self, r)
        """
        return _ida_graph.interval_t_make_union(self, *args)

    def move_by(self, *args):
        """
        move_by(self, shift)
        """
        return _ida_graph.interval_t_move_by(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> interval_t
        __init__(self, y0, y1) -> interval_t
        __init__(self, s) -> interval_t
        """
        this = _ida_graph.new_interval_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def length(self, *args):
        """
        length(self) -> int
        """
        return _ida_graph.interval_t_length(self, *args)

    def contains(self, *args):
        """
        contains(self, x) -> bool
        """
        return _ida_graph.interval_t_contains(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_graph.interval_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_graph.interval_t___ne__(self, *args)

    __swig_destroy__ = _ida_graph.delete_interval_t
    __del__ = lambda self : None;
interval_t_swigregister = _ida_graph.interval_t_swigregister
interval_t_swigregister(interval_t)

class row_info_t(object):
    """
    Proxy of C++ row_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nodes = _swig_property(_ida_graph.row_info_t_nodes_get, _ida_graph.row_info_t_nodes_set)
    top = _swig_property(_ida_graph.row_info_t_top_get, _ida_graph.row_info_t_top_set)
    bottom = _swig_property(_ida_graph.row_info_t_bottom_get, _ida_graph.row_info_t_bottom_set)
    def height(self, *args):
        """
        height(self) -> int
        """
        return _ida_graph.row_info_t_height(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> row_info_t
        """
        this = _ida_graph.new_row_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_row_info_t
    __del__ = lambda self : None;
row_info_t_swigregister = _ida_graph.row_info_t_swigregister
row_info_t_swigregister(row_info_t)

class edge_infos_wrapper_t(object):
    """
    Proxy of C++ edge_infos_wrapper_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.edge_infos_wrapper_t_clear(self, *args)

    ptr = _swig_property(_ida_graph.edge_infos_wrapper_t_ptr_get, _ida_graph.edge_infos_wrapper_t_ptr_set)
edge_infos_wrapper_t_swigregister = _ida_graph.edge_infos_wrapper_t_swigregister
edge_infos_wrapper_t_swigregister(edge_infos_wrapper_t)
ygap = cvar.ygap
xgap = cvar.xgap
arrow_height = cvar.arrow_height
arrow_width = cvar.arrow_width

class mutable_graph_t(object):
    """
    Proxy of C++ mutable_graph_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    gid = _swig_property(_ida_graph.mutable_graph_t_gid_get, _ida_graph.mutable_graph_t_gid_set)
    belongs = _swig_property(_ida_graph.mutable_graph_t_belongs_get, _ida_graph.mutable_graph_t_belongs_set)
    node_flags = _swig_property(_ida_graph.mutable_graph_t_node_flags_get, _ida_graph.mutable_graph_t_node_flags_set)
    org_succs = _swig_property(_ida_graph.mutable_graph_t_org_succs_get, _ida_graph.mutable_graph_t_org_succs_set)
    org_preds = _swig_property(_ida_graph.mutable_graph_t_org_preds_get, _ida_graph.mutable_graph_t_org_preds_set)
    succs = _swig_property(_ida_graph.mutable_graph_t_succs_get, _ida_graph.mutable_graph_t_succs_set)
    preds = _swig_property(_ida_graph.mutable_graph_t_preds_get, _ida_graph.mutable_graph_t_preds_set)
    nodes = _swig_property(_ida_graph.mutable_graph_t_nodes_get, _ida_graph.mutable_graph_t_nodes_set)
    edges = _swig_property(_ida_graph.mutable_graph_t_edges_get, _ida_graph.mutable_graph_t_edges_set)
    def size(self, *args):
        """
        size(self) -> int
        """
        return _ida_graph.mutable_graph_t_size(self, *args)

    def node_qty(self, *args):
        """
        node_qty(self) -> int
        """
        return _ida_graph.mutable_graph_t_node_qty(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_graph.mutable_graph_t_clear(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_graph.mutable_graph_t_empty(self, *args)

    def exists(self, *args):
        """
        exists(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_exists(self, *args)

    def get_node_representative(self, *args):
        """
        get_node_representative(self, node) -> int
        """
        return _ida_graph.mutable_graph_t_get_node_representative(self, *args)

    def get_node_group(self, *args):
        """
        get_node_group(self, node) -> int
        """
        return _ida_graph.mutable_graph_t_get_node_group(self, *args)

    def set_node_group(self, *args):
        """
        set_node_group(self, node, group)
        """
        return _ida_graph.mutable_graph_t_set_node_group(self, *args)

    def is_deleted_node(self, *args):
        """
        is_deleted_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_deleted_node(self, *args)

    def set_deleted_node(self, *args):
        """
        set_deleted_node(self, node)
        """
        return _ida_graph.mutable_graph_t_set_deleted_node(self, *args)

    def is_subgraph_node(self, *args):
        """
        is_subgraph_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_subgraph_node(self, *args)

    def is_dot_node(self, *args):
        """
        is_dot_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_dot_node(self, *args)

    def is_group_node(self, *args):
        """
        is_group_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_group_node(self, *args)

    def is_displayable_node(self, *args):
        """
        is_displayable_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_displayable_node(self, *args)

    def is_simple_node(self, *args):
        """
        is_simple_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_simple_node(self, *args)

    def is_collapsed_node(self, *args):
        """
        is_collapsed_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_collapsed_node(self, *args)

    def is_uncollapsed_node(self, *args):
        """
        is_uncollapsed_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_uncollapsed_node(self, *args)

    def is_visible_node(self, *args):
        """
        is_visible_node(self, node) -> bool
        """
        return _ida_graph.mutable_graph_t_is_visible_node(self, *args)

    def get_first_subgraph_node(self, *args):
        """
        get_first_subgraph_node(self, group) -> int
        """
        return _ida_graph.mutable_graph_t_get_first_subgraph_node(self, *args)

    def get_next_subgraph_node(self, *args):
        """
        get_next_subgraph_node(self, group, current) -> int
        """
        return _ida_graph.mutable_graph_t_get_next_subgraph_node(self, *args)

    def create_group(self, *args):
        """
        create_group(self, nodes) -> int
        """
        return _ida_graph.mutable_graph_t_create_group(self, *args)

    def delete_group(self, *args):
        """
        delete_group(self, group) -> bool
        """
        return _ida_graph.mutable_graph_t_delete_group(self, *args)

    def change_group_visibility(self, *args):
        """
        change_group_visibility(self, group, expand) -> bool
        """
        return _ida_graph.mutable_graph_t_change_group_visibility(self, *args)

    def nsucc(self, *args):
        """
        nsucc(self, b) -> int
        """
        return _ida_graph.mutable_graph_t_nsucc(self, *args)

    def npred(self, *args):
        """
        npred(self, b) -> int
        """
        return _ida_graph.mutable_graph_t_npred(self, *args)

    def succ(self, *args):
        """
        succ(self, b, i) -> int
        """
        return _ida_graph.mutable_graph_t_succ(self, *args)

    def pred(self, *args):
        """
        pred(self, b, i) -> int
        """
        return _ida_graph.mutable_graph_t_pred(self, *args)

    def succset(self, *args):
        """
        succset(self, b) -> intvec_t const &
        """
        return _ida_graph.mutable_graph_t_succset(self, *args)

    def predset(self, *args):
        """
        predset(self, b) -> intvec_t const &
        """
        return _ida_graph.mutable_graph_t_predset(self, *args)

    def reset(self, *args):
        """
        reset(self)
        """
        return _ida_graph.mutable_graph_t_reset(self, *args)

    def nrect(self, *args):
        """
        nrect(self, n) -> rect_t
        nrect(self, n) -> rect_t
        """
        return _ida_graph.mutable_graph_t_nrect(self, *args)

    def set_edge(self, *args):
        """
        set_edge(self, e, ei) -> bool
        """
        return _ida_graph.mutable_graph_t_set_edge(self, *args)

    def create_digraph_layout(self, *args):
        """
        create_digraph_layout(self) -> bool
        """
        return _ida_graph.mutable_graph_t_create_digraph_layout(self, *args)

    def del_custom_layout(self, *args):
        """
        del_custom_layout(self)
        """
        return _ida_graph.mutable_graph_t_del_custom_layout(self, *args)

    def get_custom_layout(self, *args):
        """
        get_custom_layout(self) -> bool
        """
        return _ida_graph.mutable_graph_t_get_custom_layout(self, *args)

    def set_custom_layout(self, *args):
        """
        set_custom_layout(self)
        """
        return _ida_graph.mutable_graph_t_set_custom_layout(self, *args)

    def get_graph_groups(self, *args):
        """
        get_graph_groups(self) -> bool
        """
        return _ida_graph.mutable_graph_t_get_graph_groups(self, *args)

    def set_graph_groups(self, *args):
        """
        set_graph_groups(self)
        """
        return _ida_graph.mutable_graph_t_set_graph_groups(self, *args)

    def calc_group_ea(self, *args):
        """
        calc_group_ea(self, arg0) -> ea_t
        """
        return _ida_graph.mutable_graph_t_calc_group_ea(self, *args)

    def is_user_graph(self, *args):
        """
        is_user_graph(self) -> bool
        """
        return _ida_graph.mutable_graph_t_is_user_graph(self, *args)

    def get_edge(self, *args):
        """
        get_edge(self, e) -> edge_info_t
        """
        return _ida_graph.mutable_graph_t_get_edge(self, *args)

    __swig_destroy__ = _ida_graph.delete_mutable_graph_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_mutable_graph_t(self)
        return weakref_proxy(self)
mutable_graph_t_swigregister = _ida_graph.mutable_graph_t_swigregister
mutable_graph_t_swigregister(mutable_graph_t)
MTG_GROUP_NODE = _ida_graph.MTG_GROUP_NODE
"""
is group node?
"""
MTG_DOT_NODE = _ida_graph.MTG_DOT_NODE
"""
is dot node?
"""
MTG_NON_DISPLAYABLE_NODE = _ida_graph.MTG_NON_DISPLAYABLE_NODE
"""
for disassembly graphs - non-displayable nodes have a visible area
that is too large to generate disassembly lines for without IDA
slowing down significantly (see MAX_VISIBLE_NODE_AREA)
"""
COLLAPSED_NODE = _ida_graph.COLLAPSED_NODE

class graph_visitor_t(object):
    """
    Proxy of C++ graph_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def visit_node(self, *args):
        """
        visit_node(self, arg2, arg3) -> int
        """
        return _ida_graph.graph_visitor_t_visit_node(self, *args)

    def visit_edge(self, *args):
        """
        visit_edge(self, arg2, arg3) -> int
        """
        return _ida_graph.graph_visitor_t_visit_edge(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> graph_visitor_t
        """
        if self.__class__ == graph_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_graph.new_graph_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_graph_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_graph.disown_graph_visitor_t(self)
        return weakref_proxy(self)
graph_visitor_t_swigregister = _ida_graph.graph_visitor_t_swigregister
graph_visitor_t_swigregister(graph_visitor_t)

grcode_calculating_layout = _ida_graph.grcode_calculating_layout
grcode_layout_calculated = _ida_graph.grcode_layout_calculated
grcode_changed_graph = _ida_graph.grcode_changed_graph
grcode_changed_current = _ida_graph.grcode_changed_current
grcode_clicked = _ida_graph.grcode_clicked
grcode_dblclicked = _ida_graph.grcode_dblclicked
grcode_creating_group = _ida_graph.grcode_creating_group
grcode_deleting_group = _ida_graph.grcode_deleting_group
grcode_group_visibility = _ida_graph.grcode_group_visibility
grcode_gotfocus = _ida_graph.grcode_gotfocus
grcode_lostfocus = _ida_graph.grcode_lostfocus
grcode_user_refresh = _ida_graph.grcode_user_refresh
grcode_user_gentext = _ida_graph.grcode_user_gentext
grcode_user_text = _ida_graph.grcode_user_text
grcode_user_size = _ida_graph.grcode_user_size
grcode_user_title = _ida_graph.grcode_user_title
grcode_user_draw = _ida_graph.grcode_user_draw
grcode_user_hint = _ida_graph.grcode_user_hint
grcode_destroyed = _ida_graph.grcode_destroyed
grcode_create_graph_viewer = _ida_graph.grcode_create_graph_viewer
grcode_get_graph_viewer = _ida_graph.grcode_get_graph_viewer
grcode_get_viewer_graph = _ida_graph.grcode_get_viewer_graph
grcode_create_mutable_graph = _ida_graph.grcode_create_mutable_graph
grcode_set_viewer_graph = _ida_graph.grcode_set_viewer_graph
grcode_refresh_viewer = _ida_graph.grcode_refresh_viewer
grcode_fit_window = _ida_graph.grcode_fit_window
grcode_get_curnode = _ida_graph.grcode_get_curnode
grcode_center_on = _ida_graph.grcode_center_on
grcode_get_selection = _ida_graph.grcode_get_selection
grcode_del_custom_layout = _ida_graph.grcode_del_custom_layout
grcode_set_custom_layout = _ida_graph.grcode_set_custom_layout
grcode_set_graph_groups = _ida_graph.grcode_set_graph_groups
grcode_clear = _ida_graph.grcode_clear
grcode_create_digraph_layout = _ida_graph.grcode_create_digraph_layout
grcode_create_tree_layout = _ida_graph.grcode_create_tree_layout
grcode_create_circle_layout = _ida_graph.grcode_create_circle_layout
grcode_get_node_representative = _ida_graph.grcode_get_node_representative
grcode_find_subgraph_node = _ida_graph.grcode_find_subgraph_node
grcode_create_group = _ida_graph.grcode_create_group
grcode_get_custom_layout = _ida_graph.grcode_get_custom_layout
grcode_get_graph_groups = _ida_graph.grcode_get_graph_groups
grcode_empty = _ida_graph.grcode_empty
grcode_is_visible_node = _ida_graph.grcode_is_visible_node
grcode_delete_group = _ida_graph.grcode_delete_group
grcode_change_group_visibility = _ida_graph.grcode_change_group_visibility
grcode_set_edge = _ida_graph.grcode_set_edge
grcode_node_qty = _ida_graph.grcode_node_qty
grcode_nrect = _ida_graph.grcode_nrect
grcode_set_titlebar_height = _ida_graph.grcode_set_titlebar_height
grcode_create_user_graph_place = _ida_graph.grcode_create_user_graph_place
grcode_create_disasm_graph1 = _ida_graph.grcode_create_disasm_graph1
grcode_create_disasm_graph2 = _ida_graph.grcode_create_disasm_graph2
grcode_set_node_info = _ida_graph.grcode_set_node_info
grcode_get_node_info = _ida_graph.grcode_get_node_info
grcode_del_node_info = _ida_graph.grcode_del_node_info
grcode_viewer_create_groups = _ida_graph.grcode_viewer_create_groups
grcode_viewer_delete_groups = _ida_graph.grcode_viewer_delete_groups
grcode_viewer_groups_visibility = _ida_graph.grcode_viewer_groups_visibility
grcode_viewer_create_groups_vec = _ida_graph.grcode_viewer_create_groups_vec
grcode_viewer_delete_groups_vec = _ida_graph.grcode_viewer_delete_groups_vec
grcode_viewer_groups_visibility_vec = _ida_graph.grcode_viewer_groups_visibility_vec
grcode_delete_mutable_graph = _ida_graph.grcode_delete_mutable_graph
grcode_edge_infos_wrapper_copy = _ida_graph.grcode_edge_infos_wrapper_copy
grcode_edge_infos_wrapper_clear = _ida_graph.grcode_edge_infos_wrapper_clear
grcode_attach_menu_item = _ida_graph.grcode_attach_menu_item
grcode_set_gli = _ida_graph.grcode_set_gli
grcode_get_gli = _ida_graph.grcode_get_gli
class group_crinfo_t(object):
    """
    Proxy of C++ group_crinfo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nodes = _swig_property(_ida_graph.group_crinfo_t_nodes_get, _ida_graph.group_crinfo_t_nodes_set)
    text = _swig_property(_ida_graph.group_crinfo_t_text_get, _ida_graph.group_crinfo_t_text_set)
    def __init__(self, *args):
        """
        __init__(self) -> group_crinfo_t
        """
        this = _ida_graph.new_group_crinfo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_graph.delete_group_crinfo_t
    __del__ = lambda self : None;
group_crinfo_t_swigregister = _ida_graph.group_crinfo_t_swigregister
group_crinfo_t_swigregister(group_crinfo_t)


def create_graph_viewer(*args):
  """
  create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *


  Create a custom graph viewer.
  
  @param title: the widget title (C++: const char *)
  @param id: graph id (C++: uval_t)
  @param callback: callback to handle graph notifications (
                   graph_notification_t ) (C++: hook_cb_t  *)
  @param ud: user data passed to callback (C++: void *)
  @param title_height: node title height (C++: int)
  @param parent (C++: TWidget *)
  @return: new viewer
  """
  return _ida_graph.create_graph_viewer(*args)

def get_graph_viewer(*args):
  """
  get_graph_viewer(parent) -> graph_viewer_t *


  Get custom graph viewer for given form.
  
  
  @param parent (C++: TWidget *)
  """
  return _ida_graph.get_graph_viewer(*args)

def create_mutable_graph(*args):
  """
  create_mutable_graph(id) -> mutable_graph_t


  Create a new empty graph with given id.
  
  
  @param id (C++: uval_t)
  """
  return _ida_graph.create_mutable_graph(*args)

def create_disasm_graph(*args):
  """
    create_disasm_graph(ea) -> mutable_graph_t
    create_disasm_graph(ranges) -> mutable_graph_t


  Create a graph for the function that contains 'ea'.
  
  
  @param ea (C++: ea_t)
    """
  return _ida_graph.create_disasm_graph(*args)

def get_viewer_graph(*args):
  """
  get_viewer_graph(gv) -> mutable_graph_t


  Get graph object for given custom graph viewer.
  
  
  @param gv (C++: graph_viewer_t  *)
  """
  return _ida_graph.get_viewer_graph(*args)

def set_viewer_graph(*args):
  """
  set_viewer_graph(gv, g)


  Set the underlying graph object for the given viewer.
  
  
  @param gv (C++: graph_viewer_t  *)
  @param g (C++: mutable_graph_t  *)
  """
  return _ida_graph.set_viewer_graph(*args)

def refresh_viewer(*args):
  """
  refresh_viewer(gv)


  Redraw the graph in the given view.
  
  
  @param gv (C++: graph_viewer_t  *)
  """
  return _ida_graph.refresh_viewer(*args)

def viewer_fit_window(*args):
  """
  viewer_fit_window(gv)


  Fit graph viewer to its parent form.
  
  
  @param gv (C++: graph_viewer_t  *)
  """
  return _ida_graph.viewer_fit_window(*args)

def viewer_get_curnode(*args):
  """
  viewer_get_curnode(gv) -> int


  Get number of currently selected node (-1 if none)
  
  
  @param gv (C++: graph_viewer_t  *)
  """
  return _ida_graph.viewer_get_curnode(*args)

def viewer_center_on(*args):
  """
  viewer_center_on(gv, node)


  Center the graph view on the given node.
  
  
  @param gv (C++: graph_viewer_t  *)
  @param node (C++: int)
  """
  return _ida_graph.viewer_center_on(*args)

def viewer_set_gli(*args):
  """
  viewer_set_gli(gv, gli, flags=0)


  Set location info for given graph view If flags contains
  GLICTL_CENTER, then the gli will be set to be the center of the view.
  Otherwise it will be the top-left.
  
  @param gv (C++: graph_viewer_t  *)
  @param gli (C++: const  graph_location_info_t  *)
  @param flags (C++: uint32)
  """
  return _ida_graph.viewer_set_gli(*args)

def viewer_get_gli(*args):
  """
  viewer_get_gli(out, gv, flags=0) -> bool


  Get location info for given graph view If flags contains
  GLICTL_CENTER, then the gli that will be retrieved, will be the one at
  the center of the view. Otherwise it will be the top-left.
  
  @param out (C++: graph_location_info_t  *)
  @param gv (C++: graph_viewer_t  *)
  @param flags (C++: uint32)
  """
  return _ida_graph.viewer_get_gli(*args)

def viewer_set_node_info(*args):
  """
  viewer_set_node_info(gv, n, ni, flags)


  Set node info for node in given viewer (see 'set_node_info()' )
  
  
  @param gv (C++: graph_viewer_t  *)
  @param n (C++: int)
  @param ni (C++: const  node_info_t  &)
  @param flags (C++: uint32)
  """
  return _ida_graph.viewer_set_node_info(*args)

def viewer_get_node_info(*args):
  """
  viewer_get_node_info(gv, out, n) -> bool


  Get node info for node in given viewer (see 'get_node_info()' )
  
  
  @param gv (C++: graph_viewer_t  *)
  @param out (C++: node_info_t  *)
  @param n (C++: int)
  """
  return _ida_graph.viewer_get_node_info(*args)

def viewer_del_node_info(*args):
  """
  viewer_del_node_info(gv, n)


  Delete node info for node in given viewer (see 'del_node_info()' )
  
  
  @param gv (C++: graph_viewer_t  *)
  @param n (C++: int)
  """
  return _ida_graph.viewer_del_node_info(*args)

def viewer_create_groups(*args):
  """
  viewer_create_groups(gv, out_group_nodes, gi) -> bool


  This will perform an operation similar to what happens when a user
  manually selects a set of nodes, right-clicks and selects "Create
  group". This is a wrapper around mutable_graph_t::create_group that
  will, in essence:clone the current graphfor each 'group_crinfo_t' ,
  attempt creating group in that new graphif all were successful,
  animate to that new graph.this accepts parameters that allow creating
  of multiple groups at once; which means only one graph animation will
  be triggered.
  
  @param gv (C++: graph_viewer_t  *)
  @param out_group_nodes (C++: intvec_t  *)
  @param gi (C++: const  groups_crinfos_t  &)
  """
  return _ida_graph.viewer_create_groups(*args)

def viewer_delete_groups(*args):
  """
  viewer_delete_groups(gv, groups, new_current=-1) -> bool


  Wrapper around mutable_graph_t::delete_group. This function will:clone
  the current graphattempt deleting the groups in that new graphif
  successful, animate to that new graph.
  
  @param gv (C++: graph_viewer_t  *)
  @param groups (C++: const  intvec_t  &)
  @param new_current (C++: int)
  """
  return _ida_graph.viewer_delete_groups(*args)

def viewer_set_groups_visibility(*args):
  """
  viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool


  Wrapper around mutable_graph_t::change_visibility. This function
  will:clone the current graphattempt changing visibility of the groups
  in that new graphif successful, animate to that new graph.
  
  @param gv (C++: graph_viewer_t  *)
  @param groups (C++: const  intvec_t  &)
  @param expand (C++: bool)
  @param new_current (C++: int)
  """
  return _ida_graph.viewer_set_groups_visibility(*args)

def viewer_attach_menu_item(*args):
  """
  viewer_attach_menu_item(g, name) -> bool


  Attach a previously-registered action to the view's context menu. See
  'kernwin.hpp' for how to register actions.
  
  @param g (C++: graph_viewer_t  *)
  @param name: action name (C++: const char *)
  @return: success
  """
  return _ida_graph.viewer_attach_menu_item(*args)

def viewer_get_selection(*args):
  """
  viewer_get_selection(gv, sgs) -> bool


  Get currently selected items for graph viewer.
  
  
  @param gv (C++: graph_viewer_t  *)
  @param sgs (C++: screen_graph_selection_t  *)
  """
  return _ida_graph.viewer_get_selection(*args)

def viewer_set_titlebar_height(*args):
  """
  viewer_set_titlebar_height(gv, height) -> int


  Set height of node title bars ( 'grcode_set_titlebar_height' )
  
  
  @param gv (C++: graph_viewer_t  *)
  @param height (C++: int)
  """
  return _ida_graph.viewer_set_titlebar_height(*args)

def delete_mutable_graph(*args):
  """
  delete_mutable_graph(g)


  Delete graph object.use this only if you are dealing with
  'mutable_graph_t' instances that have not been used together with a
  'graph_viewer_t' . If you have called 'set_viewer_graph()' with your
  graph, the graph's lifecycle will be managed by the viewer, and you
  shouldn't interfere with it
  
  @param g (C++: mutable_graph_t  *)
  """
  return _ida_graph.delete_mutable_graph(*args)
class user_graph_place_t(object):
    """
    Proxy of C++ user_graph_place_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    node = _swig_property(_ida_graph.user_graph_place_t_node_get, _ida_graph.user_graph_place_t_node_set)
    __swig_destroy__ = _ida_graph.delete_user_graph_place_t
    __del__ = lambda self : None;
user_graph_place_t_swigregister = _ida_graph.user_graph_place_t_swigregister
user_graph_place_t_swigregister(user_graph_place_t)


def create_user_graph_place(*args):
  """
  create_user_graph_place(node, lnnum) -> user_graph_place_t


  Get a copy of a 'user_graph_place_t' (returns a pointer to static
  storage)
  
  
  @param node (C++: int)
  @param lnnum (C++: int)
  """
  return _ida_graph.create_user_graph_place(*args)

def pyg_close(*args):
  """
  pyg_close(self)
  """
  return _ida_graph.pyg_close(*args)

def pyg_select_node(*args):
  """
  pyg_select_node(self, nid)
  """
  return _ida_graph.pyg_select_node(*args)

def pyg_show(*args):
  """
  pyg_show(self) -> bool
  """
  return _ida_graph.pyg_show(*args)
#<pycode(py_graph)>
import ida_idaapi
import ida_kernwin
try:
    if _BC695:
        from ida_kernwin import BC695_control_cmd
except:
    pass # BC695 not defined at compile-time

class GraphViewer(ida_kernwin.CustomIDAMemo):
    class UI_Hooks_Trampoline(ida_kernwin.UI_Hooks):
        def __init__(self, v):
            ida_kernwin.UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            my_form = self.v().GetWidget()
            if form == my_form:
                self.v().OnPopup(my_form, popup_handle)

    """
    This class wraps the user graphing facility provided by the graph.hpp file
    """
    def __init__(self, title, close_open = False):
        """
        Constructs the GraphView object.
        Please do not remove or rename the private fields

        @param title: The title of the graph window
        @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
        """
        self._title = title
        self._nodes = []
        self._edges = []
        self._close_open = close_open
        ida_kernwin.CustomIDAMemo.__init__(self)
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)

    def AddNode(self, obj):
        """
        Creates a node associated with the given object and returns the node id
        """
        id = len(self._nodes)
        self._nodes.append(obj)
        return id

    def AddEdge(self, src_node, dest_node):
        """
        Creates an edge between two given node ids
        """
        assert src_node < len(self._nodes), "Source node %d is out of bounds" % src_node
        assert dest_node < len(self._nodes), "Destination node %d is out of bounds" % dest_node
        self._edges.append( (src_node, dest_node) )

    def Clear(self):
        """
        Clears all the nodes and edges
        """
        self._nodes = []
        self._edges = []

    def OnPopup(self, form, popup_handle):
        pass

    def __iter__(self):
        return (self._nodes[index] for index in xrange(0, len(self._nodes)))


    def __getitem__(self, idx):
        """
        Returns a reference to the object associated with this node id
        """
        if idx >= len(self._nodes):
            raise KeyError
        else:
            return self._nodes[idx]

    def Count(self):
        """
        Returns the node count
        """
        return len(self._nodes)

    def Close(self):
        """
        Closes the graph.
        It is possible to call Show() again (which will recreate the graph)
        """
        _ida_graph.pyg_close(self)

    def Show(self):
        """
        Shows an existing graph or creates a new one

        @return: Boolean
        """
        if self._close_open:
            import ida_kernwin
            frm = ida_kernwin.find_widget(self._title)
            if frm:
                ida_kernwin.close_widget(frm, 0)
        return _ida_graph.pyg_show(self)

    def Select(self, node_id):
        """
        Selects a node on the graph
        """
        _ida_graph.pyg_select_node(self, node_id)

    def OnRefresh(self):
        """
        Event called when the graph is refreshed or first created.
        From this event you are supposed to create nodes and edges.
        This callback is mandatory.

        @note: ***It is important to clear previous nodes before adding nodes.***
        @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
        """
        self.Clear()

        return True

    def AddCommand(self, title, hotkey):
        return BC695_control_cmd.add_to_control(
            self,
            title,
            ida_kernwin.CHOOSER_POPUP_MENU, # KLUDGE
            -1, # menu index
            -1, # icon
            None, # emb
            hotkey,
            is_chooser=False)

    def OnPopup(self, widget, popup_handle):
        BC695_control_cmd.populate_popup(self, widget, popup_handle)

    def OnCommand(self, cmd_id):
        return 0


#<pydoc>
#    def OnGetText(self, node_id):
#        """
#        Triggered when the graph viewer wants the text and color for a given node.
#        This callback is triggered one time for a given node (the value will be cached and used later without calling Python).
#        When you call refresh then again this callback will be called for each node.
#
#        This callback is mandatory.
#
#        @return: Return a string to describe the node text or return a tuple (node_text, node_color) to describe both text and color
#        """
#        return str(self[node_id])
#
#    def OnActivate(self):
#        """
#        Triggered when the graph window gets the focus
#        @return: None
#        """
#        print "Activated...."
#
#    def OnDeactivate(self):
#        """Triggered when the graph window loses the focus
#        @return: None
#        """
#        print "Deactivated...."
#
#    def OnSelect(self, node_id):
#        """
#        Triggered when a node is being selected
#        @return: Return True to allow the node to be selected or False to disallow node selection change
#        """
#        # allow selection change
#        return True
#
#    def OnHint(self, node_id):
#        """
#        Triggered when the graph viewer wants to retrieve hint text associated with a given node
#
#        @return: None if no hint is avail or a string designating the hint
#        """
#        return "hint for " + str(node_id)
#
#    def OnEdgeHint(self, src, dst):
#        """
#        Triggered when the graph viewer wants to retrieve hint text associated with a edge
#
#        @return: None if no hint is avail or a string designating the hint
#        """
#        return "hint for edge %d -> %d" % (src, dst)
#
#    def OnClose(self):
#        """Triggered when the graph viewer window is being closed
#        @return: None
#        """
#        print "Closing......."
#
#    def OnClick(self, node_id):
#        """
#        Triggered when a node is clicked
#        @return: False to ignore the click and True otherwise
#        """
#        print "clicked on", self[node_id]
#        return True
#
#    def OnDblClick(self, node_id):
#        """
#        Triggerd when a node is double-clicked.
#        @return: False to ignore the click and True otherwise
#        """
#        print "dblclicked on", self[node_id]
#        return True
#</pydoc>
#</pycode(py_graph)>

if _BC695:
    clr_node_info2=clr_node_info
    del_node_info2=del_node_info
    get_node_info2=get_node_info
    set_node_info2=set_node_info
    GraphViewer.GetTForm = GraphViewer.GetWidget



